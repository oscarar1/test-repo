/// <reference types="react" />
import { CatalogApi } from '@backstage/catalog-client';
export { CatalogApi } from '@backstage/catalog-client';
import { ApiRef } from '@backstage/core-plugin-api';
import { Entity, EntityName, SystemEntity, ComponentEntity, UserEntity } from '@backstage/catalog-model';
import React, { ReactNode, Context, PropsWithChildren } from 'react';
import { LinkProps, TableColumn, RouteRef } from '@backstage/core';
import { AsyncState } from 'react-use/lib/useAsync';

declare const catalogApiRef: ApiRef<CatalogApi>;

declare type EntityKindFilterProps = {
    initialFilter?: string;
    hidden: boolean;
};
declare const EntityKindPicker: ({ initialFilter, hidden, }: EntityKindFilterProps) => JSX.Element | null;

declare type EntityProviderProps = {
    entity: Entity;
    children: ReactNode;
};
declare const EntityProvider: ({ entity, children }: EntityProviderProps) => JSX.Element;

declare type EntityRefLinkProps = {
    entityRef: Entity | EntityName;
    defaultKind?: string;
    children?: React.ReactNode;
} & Omit<LinkProps, 'to'>;
declare const EntityRefLink: React.ForwardRefExoticComponent<Pick<EntityRefLinkProps, "replace" | "media" | "hidden" | "dir" | "slot" | "style" | "title" | "color" | "underline" | "children" | "key" | "id" | "display" | "translate" | "prefix" | "classes" | "defaultChecked" | "defaultValue" | "suppressContentEditableWarning" | "suppressHydrationWarning" | "accessKey" | "className" | "contentEditable" | "contextMenu" | "draggable" | "lang" | "placeholder" | "spellCheck" | "tabIndex" | "radioGroup" | "role" | "about" | "datatype" | "inlist" | "property" | "resource" | "typeof" | "vocab" | "autoCapitalize" | "autoCorrect" | "autoSave" | "itemProp" | "itemScope" | "itemType" | "itemID" | "itemRef" | "results" | "security" | "unselectable" | "inputMode" | "is" | "aria-activedescendant" | "aria-atomic" | "aria-autocomplete" | "aria-busy" | "aria-checked" | "aria-colcount" | "aria-colindex" | "aria-colspan" | "aria-controls" | "aria-current" | "aria-describedby" | "aria-details" | "aria-disabled" | "aria-dropeffect" | "aria-errormessage" | "aria-expanded" | "aria-flowto" | "aria-grabbed" | "aria-haspopup" | "aria-hidden" | "aria-invalid" | "aria-keyshortcuts" | "aria-label" | "aria-labelledby" | "aria-level" | "aria-live" | "aria-modal" | "aria-multiline" | "aria-multiselectable" | "aria-orientation" | "aria-owns" | "aria-placeholder" | "aria-posinset" | "aria-pressed" | "aria-readonly" | "aria-relevant" | "aria-required" | "aria-roledescription" | "aria-rowcount" | "aria-rowindex" | "aria-rowspan" | "aria-selected" | "aria-setsize" | "aria-sort" | "aria-valuemax" | "aria-valuemin" | "aria-valuenow" | "aria-valuetext" | "dangerouslySetInnerHTML" | "onCopy" | "onCopyCapture" | "onCut" | "onCutCapture" | "onPaste" | "onPasteCapture" | "onCompositionEnd" | "onCompositionEndCapture" | "onCompositionStart" | "onCompositionStartCapture" | "onCompositionUpdate" | "onCompositionUpdateCapture" | "onFocus" | "onFocusCapture" | "onBlur" | "onBlurCapture" | "onChange" | "onChangeCapture" | "onBeforeInput" | "onBeforeInputCapture" | "onInput" | "onInputCapture" | "onReset" | "onResetCapture" | "onSubmit" | "onSubmitCapture" | "onInvalid" | "onInvalidCapture" | "onLoad" | "onLoadCapture" | "onError" | "onErrorCapture" | "onKeyDown" | "onKeyDownCapture" | "onKeyPress" | "onKeyPressCapture" | "onKeyUp" | "onKeyUpCapture" | "onAbort" | "onAbortCapture" | "onCanPlay" | "onCanPlayCapture" | "onCanPlayThrough" | "onCanPlayThroughCapture" | "onDurationChange" | "onDurationChangeCapture" | "onEmptied" | "onEmptiedCapture" | "onEncrypted" | "onEncryptedCapture" | "onEnded" | "onEndedCapture" | "onLoadedData" | "onLoadedDataCapture" | "onLoadedMetadata" | "onLoadedMetadataCapture" | "onLoadStart" | "onLoadStartCapture" | "onPause" | "onPauseCapture" | "onPlay" | "onPlayCapture" | "onPlaying" | "onPlayingCapture" | "onProgress" | "onProgressCapture" | "onRateChange" | "onRateChangeCapture" | "onSeeked" | "onSeekedCapture" | "onSeeking" | "onSeekingCapture" | "onStalled" | "onStalledCapture" | "onSuspend" | "onSuspendCapture" | "onTimeUpdate" | "onTimeUpdateCapture" | "onVolumeChange" | "onVolumeChangeCapture" | "onWaiting" | "onWaitingCapture" | "onAuxClick" | "onAuxClickCapture" | "onClick" | "onClickCapture" | "onContextMenu" | "onContextMenuCapture" | "onDoubleClick" | "onDoubleClickCapture" | "onDrag" | "onDragCapture" | "onDragEnd" | "onDragEndCapture" | "onDragEnter" | "onDragEnterCapture" | "onDragExit" | "onDragExitCapture" | "onDragLeave" | "onDragLeaveCapture" | "onDragOver" | "onDragOverCapture" | "onDragStart" | "onDragStartCapture" | "onDrop" | "onDropCapture" | "onMouseDown" | "onMouseDownCapture" | "onMouseEnter" | "onMouseLeave" | "onMouseMove" | "onMouseMoveCapture" | "onMouseOut" | "onMouseOutCapture" | "onMouseOver" | "onMouseOverCapture" | "onMouseUp" | "onMouseUpCapture" | "onSelect" | "onSelectCapture" | "onTouchCancel" | "onTouchCancelCapture" | "onTouchEnd" | "onTouchEndCapture" | "onTouchMove" | "onTouchMoveCapture" | "onTouchStart" | "onTouchStartCapture" | "onPointerDown" | "onPointerDownCapture" | "onPointerMove" | "onPointerMoveCapture" | "onPointerUp" | "onPointerUpCapture" | "onPointerCancel" | "onPointerCancelCapture" | "onPointerEnter" | "onPointerEnterCapture" | "onPointerLeave" | "onPointerLeaveCapture" | "onPointerOver" | "onPointerOverCapture" | "onPointerOut" | "onPointerOutCapture" | "onGotPointerCapture" | "onGotPointerCaptureCapture" | "onLostPointerCapture" | "onLostPointerCaptureCapture" | "onScroll" | "onScrollCapture" | "onWheel" | "onWheelCapture" | "onAnimationStart" | "onAnimationStartCapture" | "onAnimationEnd" | "onAnimationEndCapture" | "onAnimationIteration" | "onAnimationIterationCapture" | "onTransitionEnd" | "onTransitionEndCapture" | "component" | "variant" | "innerRef" | "download" | "href" | "hrefLang" | "ping" | "rel" | "target" | "type" | "referrerPolicy" | "noWrap" | "gutterBottom" | "paragraph" | "align" | "variantMapping" | "state" | "TypographyClasses" | "entityRef" | "defaultKind"> & React.RefAttributes<any>>;

declare type EntityRefLinksProps = {
    entityRefs: (Entity | EntityName)[];
    defaultKind?: string;
} & Omit<LinkProps, 'to'>;
declare const EntityRefLinks: ({ entityRefs, defaultKind, ...linkProps }: EntityRefLinksProps) => JSX.Element;

declare function formatEntityRefTitle(entityRef: Entity | EntityName, opts?: {
    defaultKind?: string;
}): string;

declare function createEntityRefColumn<T extends Entity>({ defaultKind, }: {
    defaultKind?: string;
}): TableColumn<T>;
declare function createEntityRelationColumn<T extends Entity>({ title, relation, defaultKind, filter: entityFilter, }: {
    title: string;
    relation: string;
    defaultKind?: string;
    filter?: {
        kind: string;
    };
}): TableColumn<T>;
declare function createOwnerColumn<T extends Entity>(): TableColumn<T>;
declare function createDomainColumn<T extends Entity>(): TableColumn<T>;
declare function createSystemColumn<T extends Entity>(): TableColumn<T>;
declare function createMetadataDescriptionColumn<T extends Entity>(): TableColumn<T>;
declare function createSpecLifecycleColumn<T extends Entity>(): TableColumn<T>;
declare function createSpecTypeColumn<T extends Entity>(): TableColumn<T>;

declare const columnFactories_createEntityRefColumn: typeof createEntityRefColumn;
declare const columnFactories_createEntityRelationColumn: typeof createEntityRelationColumn;
declare const columnFactories_createOwnerColumn: typeof createOwnerColumn;
declare const columnFactories_createDomainColumn: typeof createDomainColumn;
declare const columnFactories_createSystemColumn: typeof createSystemColumn;
declare const columnFactories_createMetadataDescriptionColumn: typeof createMetadataDescriptionColumn;
declare const columnFactories_createSpecLifecycleColumn: typeof createSpecLifecycleColumn;
declare const columnFactories_createSpecTypeColumn: typeof createSpecTypeColumn;
declare namespace columnFactories {
  export {
    columnFactories_createEntityRefColumn as createEntityRefColumn,
    columnFactories_createEntityRelationColumn as createEntityRelationColumn,
    columnFactories_createOwnerColumn as createOwnerColumn,
    columnFactories_createDomainColumn as createDomainColumn,
    columnFactories_createSystemColumn as createSystemColumn,
    columnFactories_createMetadataDescriptionColumn as createMetadataDescriptionColumn,
    columnFactories_createSpecLifecycleColumn as createSpecLifecycleColumn,
    columnFactories_createSpecTypeColumn as createSpecTypeColumn,
  };
}

declare type Props<T extends Entity> = {
    title: string;
    variant?: 'gridItem';
    entities: T[];
    emptyContent?: ReactNode;
    columns: TableColumn<T>[];
};
declare function EntityTable<T extends Entity>({ entities, title, emptyContent, variant, columns, }: Props<T>): JSX.Element;
declare namespace EntityTable {
    var columns: typeof columnFactories;
    var systemEntityColumns: TableColumn<SystemEntity>[];
    var componentEntityColumns: TableColumn<ComponentEntity>[];
}

declare const EntityTagPicker: () => JSX.Element | null;

declare const EntityTypePicker: () => JSX.Element | null;

declare type EntityFilter = {
    /**
     * Get filters to add to the catalog-backend request. These are a dot-delimited field with
     * value(s) to accept, extracted on the backend by parseEntityFilterParams. For example:
     *   { field: 'kind', values: ['component'] }
     *   { field: 'metadata.name', values: ['component-1', 'component-2'] }
     */
    getCatalogFilters?: () => Record<string, string | string[]>;
    /**
     * Filter entities on the frontend after a catalog-backend request. This function will be called
     * with each backend-resolved entity. This is used when frontend information is required for
     * filtering, such as a user's starred entities.
     *
     * @param entity
     * @param env
     */
    filterEntity?: (entity: Entity) => boolean;
};
declare class EntityKindFilter implements EntityFilter {
    readonly value: string;
    constructor(value: string);
    getCatalogFilters(): Record<string, string | string[]>;
}
declare class EntityTypeFilter implements EntityFilter {
    readonly value: string;
    constructor(value: string);
    getCatalogFilters(): Record<string, string | string[]>;
}
declare class EntityTagFilter implements EntityFilter {
    readonly values: string[];
    constructor(values: string[]);
    filterEntity(entity: Entity): boolean;
}
declare type UserListFilterKind = 'owned' | 'starred' | 'all';
declare class UserListFilter implements EntityFilter {
    readonly value: UserListFilterKind;
    readonly user: UserEntity | undefined;
    readonly isStarredEntity: (entity: Entity) => boolean;
    constructor(value: UserListFilterKind, user: UserEntity | undefined, isStarredEntity: (entity: Entity) => boolean);
    filterEntity(entity: Entity): boolean;
}

declare type UserListPickerProps = {
    initialFilter?: UserListFilterKind;
};
declare const UserListPicker: ({ initialFilter }: UserListPickerProps) => JSX.Element;

declare type EntityLoadingStatus = {
    entity?: Entity;
    loading: boolean;
    error?: Error;
};
declare const EntityContext: Context<EntityLoadingStatus>;
declare const useEntityFromUrl: () => EntityLoadingStatus;
/**
 * Grab the current entity from the context and its current loading state.
 */
declare function useEntity<T extends Entity = Entity>(): {
    entity: T;
    loading: boolean;
    error: Error | undefined;
};

/**
 * Grabs entity kind, namespace, and name from the location
 */
declare const useEntityCompoundName: () => {
    kind: string;
    namespace: string;
    name: string;
};

declare type DefaultEntityFilters = {
    kind?: EntityKindFilter;
    type?: EntityTypeFilter;
    user?: UserListFilter;
    tags?: EntityTagFilter;
};
declare type EntityListContextProps<EntityFilters extends DefaultEntityFilters = DefaultEntityFilters> = {
    /**
     * The currently registered filters, adhering to the shape of DefaultEntityFilters or an extension
     * of that default (to add custom filter types).
     */
    filters: EntityFilters;
    /**
     * The resolved list of catalog entities, after all filters are applied.
     */
    entities: Entity[];
    /**
     * The resolved list of catalog entities, after _only catalog-backend_ filters are applied.
     */
    backendEntities: Entity[];
    /**
     * Update one or more of the registered filters. Optional filters can be set to `undefined` to
     * reset the filter.
     */
    updateFilters: (filters: Partial<EntityFilters> | ((prevFilters: EntityFilters) => Partial<EntityFilters>)) => void;
    loading: boolean;
    error?: Error;
};
declare const EntityListContext: React.Context<EntityListContextProps<any> | undefined>;
declare const EntityListProvider: <EntityFilters extends DefaultEntityFilters>({ children, }: PropsWithChildren<{}>) => JSX.Element;
declare function useEntityListProvider<EntityFilters extends DefaultEntityFilters>(): EntityListContextProps<EntityFilters>;

declare type EntityTypeReturn = {
    loading: boolean;
    error?: Error;
    types: string[];
    selectedType: string | undefined;
    setType: (type: string | undefined) => void;
};
/**
 * A hook built on top of `useEntityListProvider` for enabling selection of valid `spec.type` values
 * based on the selected EntityKindFilter.
 */
declare function useEntityTypeFilter(): EntityTypeReturn;

/**
 * Get the catalog User entity (if any) that matches the logged-in user.
 */
declare function useOwnUser(): AsyncState<UserEntity | undefined>;

declare function useRelatedEntities(entity: Entity, { type, kind }: {
    type?: string;
    kind?: string;
}): {
    entities: Entity[] | undefined;
    loading: boolean;
    error: Error | undefined;
};

declare const useStarredEntities: () => {
    starredEntities: Set<string>;
    toggleStarredEntity: (entity: Entity) => void;
    isStarredEntity: (entity: Entity) => boolean;
};

declare const rootRoute: RouteRef<undefined>;
declare const catalogRouteRef: RouteRef<undefined>;
declare const entityRoute: RouteRef<{
    name: string;
    kind: string;
    namespace: string;
}>;
declare const entityRouteRef: RouteRef<{
    name: string;
    kind: string;
    namespace: string;
}>;
declare function entityRouteParams(entity: Entity): {
    readonly kind: string;
    readonly namespace: string;
    readonly name: string;
};

declare const MockEntityListContextProvider: ({ children, value, }: React.PropsWithChildren<{
    value: Partial<EntityListContextProps>;
}>) => JSX.Element;

declare function reduceCatalogFilters(filters: EntityFilter[]): Record<string, string | string[]>;
declare function reduceEntityFilters(filters: EntityFilter[]): (entity: Entity) => boolean;

/**
 * Get the related entity references.
 */
declare function getEntityRelations(entity: Entity | undefined, relationType: string, filter?: {
    kind: string;
}): EntityName[];

/**
 * Get the related entity references.
 */
declare function isOwnerOf(owner: Entity, owned: Entity): boolean;

export { DefaultEntityFilters, EntityContext, EntityFilter, EntityKindFilter, EntityKindPicker, EntityListContext, EntityListProvider, EntityProvider, EntityRefLink, EntityRefLinks, EntityTable, EntityTagFilter, EntityTagPicker, EntityTypeFilter, EntityTypePicker, MockEntityListContextProvider, UserListFilter, UserListFilterKind, UserListPicker, catalogApiRef, catalogRouteRef, entityRoute, entityRouteParams, entityRouteRef, formatEntityRefTitle, getEntityRelations, isOwnerOf, reduceCatalogFilters, reduceEntityFilters, rootRoute, useEntity, useEntityCompoundName, useEntityFromUrl, useEntityListProvider, useEntityTypeFilter, useOwnUser, useRelatedEntities, useStarredEntities };
