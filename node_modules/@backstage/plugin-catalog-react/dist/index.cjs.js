'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var corePluginApi = require('@backstage/core-plugin-api');
var React = require('react');
var lab = require('@material-ui/lab');
var reactRouter = require('react-router');
var reactUse = require('react-use');
var core = require('@backstage/core');
var catalogModel = require('@backstage/catalog-model');
var lodash = require('lodash');
var core$1 = require('@material-ui/core');
var CheckBoxIcon = require('@material-ui/icons/CheckBox');
var CheckBoxOutlineBlankIcon = require('@material-ui/icons/CheckBoxOutlineBlank');
var ExpandMoreIcon = require('@material-ui/icons/ExpandMore');
var SettingsIcon = require('@material-ui/icons/Settings');
var StarIcon = require('@material-ui/icons/Star');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var CheckBoxIcon__default = /*#__PURE__*/_interopDefaultLegacy(CheckBoxIcon);
var CheckBoxOutlineBlankIcon__default = /*#__PURE__*/_interopDefaultLegacy(CheckBoxOutlineBlankIcon);
var ExpandMoreIcon__default = /*#__PURE__*/_interopDefaultLegacy(ExpandMoreIcon);
var SettingsIcon__default = /*#__PURE__*/_interopDefaultLegacy(SettingsIcon);
var StarIcon__default = /*#__PURE__*/_interopDefaultLegacy(StarIcon);

const catalogApiRef = corePluginApi.createApiRef({
  id: "plugin.catalog.service"
});

const NoIcon = () => null;
const rootRoute = core.createRouteRef({
  icon: NoIcon,
  path: "",
  title: "Catalog"
});
const catalogRouteRef = rootRoute;
const entityRoute = core.createRouteRef({
  icon: NoIcon,
  path: ":namespace/:kind/:name/*",
  title: "Entity",
  params: ["namespace", "kind", "name"]
});
const entityRouteRef = entityRoute;
function entityRouteParams(entity) {
  var _a, _b;
  return {
    kind: entity.kind.toLowerCase(),
    namespace: (_b = (_a = entity.metadata.namespace) == null ? void 0 : _a.toLowerCase()) != null ? _b : catalogModel.ENTITY_DEFAULT_NAMESPACE,
    name: entity.metadata.name
  };
}

const useEntityCompoundName = () => {
  const {kind, namespace, name} = core.useRouteRefParams(entityRouteRef);
  return {kind, namespace, name};
};

const EntityContext = React.createContext({
  entity: void 0,
  loading: true,
  error: void 0
});
const useEntityFromUrl = () => {
  const {kind, namespace, name} = useEntityCompoundName();
  const navigate = reactRouter.useNavigate();
  const errorApi = corePluginApi.useApi(corePluginApi.errorApiRef);
  const catalogApi = corePluginApi.useApi(catalogApiRef);
  const {value: entity, error, loading} = reactUse.useAsync(() => catalogApi.getEntityByName({kind, namespace, name}), [catalogApi, kind, namespace, name]);
  React.useEffect(() => {
    if (!name) {
      errorApi.post(new Error("No name provided!"));
      navigate("/");
    }
  }, [errorApi, navigate, error, loading, entity, name]);
  return {entity, loading, error};
};
function useEntity() {
  const {entity, loading, error} = React.useContext(EntityContext);
  return {entity, loading, error};
}

function reduceCatalogFilters(filters) {
  return filters.reduce((compoundFilter, filter) => {
    return {
      ...compoundFilter,
      ...filter.getCatalogFilters ? filter.getCatalogFilters() : {}
    };
  }, {});
}
function reduceEntityFilters(filters) {
  return (entity) => filters.every((filter) => !filter.filterEntity || filter.filterEntity(entity));
}

function getEntityRelations(entity, relationType, filter) {
  var _a, _b;
  let entityNames = ((_b = (_a = entity == null ? void 0 : entity.relations) == null ? void 0 : _a.filter((r) => r.type === relationType)) == null ? void 0 : _b.map((r) => r.target)) || [];
  if (filter == null ? void 0 : filter.kind) {
    entityNames = entityNames == null ? void 0 : entityNames.filter((e) => e.kind.toLowerCase() === filter.kind.toLowerCase());
  }
  return entityNames;
}

function isOwnerOf(owner, owned) {
  const possibleOwners = [
    ...getEntityRelations(owner, catalogModel.RELATION_MEMBER_OF, {kind: "group"}),
    ...owner ? [catalogModel.getEntityName(owner)] : []
  ];
  const owners = getEntityRelations(owned, catalogModel.RELATION_OWNED_BY);
  for (const ownerItem of owners) {
    if (possibleOwners.find((o) => ownerItem.kind.toLowerCase() === o.kind.toLowerCase() && ownerItem.namespace.toLowerCase() === o.namespace.toLowerCase() && ownerItem.name.toLowerCase() === o.name.toLowerCase()) !== void 0) {
      return true;
    }
  }
  return false;
}

const EntityListContext = React.createContext(void 0);
const EntityListProvider = ({
  children
}) => {
  const catalogApi = core.useApi(catalogApiRef);
  const [requestedFilters, setRequestedFilters] = React.useState({});
  const [outputState, setOutputState] = React.useState({
    appliedFilters: {},
    entities: [],
    backendEntities: []
  });
  const [{loading, error}, refresh] = reactUse.useAsyncFn(async () => {
    const compacted = lodash.compact(Object.values(requestedFilters));
    const entityFilter = reduceEntityFilters(compacted);
    const backendFilter = reduceCatalogFilters(compacted);
    const previousBackendFilter = reduceCatalogFilters(lodash.compact(Object.values(outputState.appliedFilters)));
    if (!lodash.isEqual(previousBackendFilter, backendFilter)) {
      const response = await catalogApi.getEntities({filter: backendFilter});
      setOutputState({
        appliedFilters: requestedFilters,
        backendEntities: response.items,
        entities: response.items.filter(entityFilter)
      });
    } else {
      setOutputState({
        appliedFilters: requestedFilters,
        backendEntities: outputState.backendEntities,
        entities: outputState.backendEntities.filter(entityFilter)
      });
    }
  }, [catalogApi, requestedFilters, outputState]);
  reactUse.useDebounce(refresh, 10, [requestedFilters]);
  const updateFilters = React.useCallback((update) => {
    setRequestedFilters((prevFilters) => {
      const newFilters = typeof update === "function" ? update(prevFilters) : update;
      return {...prevFilters, ...newFilters};
    });
  }, []);
  return /* @__PURE__ */ React__default['default'].createElement(EntityListContext.Provider, {
    value: {
      filters: outputState.appliedFilters,
      entities: outputState.entities,
      backendEntities: outputState.backendEntities,
      updateFilters,
      loading,
      error
    }
  }, children);
};
function useEntityListProvider() {
  const context = React.useContext(EntityListContext);
  if (!context)
    throw new Error("useEntityListProvider must be used within EntityListProvider");
  return context;
}

class EntityKindFilter {
  constructor(value) {
    this.value = value;
  }
  getCatalogFilters() {
    return {kind: this.value};
  }
}
class EntityTypeFilter {
  constructor(value) {
    this.value = value;
  }
  getCatalogFilters() {
    return {"spec.type": this.value};
  }
}
class EntityTagFilter {
  constructor(values) {
    this.values = values;
  }
  filterEntity(entity) {
    return this.values.every((v) => {
      var _a;
      return ((_a = entity.metadata.tags) != null ? _a : []).includes(v);
    });
  }
}
class UserListFilter {
  constructor(value, user, isStarredEntity) {
    this.value = value;
    this.user = user;
    this.isStarredEntity = isStarredEntity;
  }
  filterEntity(entity) {
    switch (this.value) {
      case "owned":
        return this.user !== void 0 && isOwnerOf(this.user, entity);
      case "starred":
        return this.isStarredEntity(entity);
      default:
        return true;
    }
  }
}

function useEntityTypeFilter() {
  const catalogApi = core.useApi(catalogApiRef);
  const {
    filters: {kind: kindFilter, type: typeFilter},
    updateFilters
  } = useEntityListProvider();
  const [types, setTypes] = React.useState([]);
  const kind = React.useMemo(() => kindFilter == null ? void 0 : kindFilter.value, [kindFilter]);
  const {error, loading, value: entities} = reactUse.useAsync(async () => {
    if (kind) {
      const items = await catalogApi.getEntities({
        filter: {kind},
        fields: ["spec.type"]
      }).then((response) => response.items);
      return items;
    }
    return [];
  }, [kind, catalogApi]);
  React.useEffect(() => {
    const newTypes = [
      ...new Set((entities != null ? entities : []).map((e) => {
        var _a;
        return (_a = e.spec) == null ? void 0 : _a.type;
      }).filter(Boolean))
    ].sort();
    setTypes(newTypes);
    updateFilters((oldFilters) => oldFilters.type && !newTypes.includes(oldFilters.type.value) ? {type: void 0} : {});
  }, [updateFilters, entities]);
  const setType = React.useCallback((type) => updateFilters({
    type: type === void 0 ? void 0 : new EntityTypeFilter(type)
  }), [updateFilters]);
  return {
    loading,
    error,
    types,
    selectedType: typeFilter == null ? void 0 : typeFilter.value,
    setType
  };
}

function useOwnUser() {
  const catalogApi = core.useApi(catalogApiRef);
  const identityApi = core.useApi(core.identityApiRef);
  return reactUse.useAsync(() => catalogApi.getEntityByName({
    kind: "User",
    namespace: "default",
    name: identityApi.getUserId()
  }), [catalogApi, identityApi]);
}

const BATCH_SIZE = 20;
function useRelatedEntities(entity, {type, kind}) {
  const catalogApi = corePluginApi.useApi(catalogApiRef);
  const {loading, value: entities, error} = reactUse.useAsync(async () => {
    const relations = entity.relations && entity.relations.filter((r) => (!type || r.type.toLowerCase() === type.toLowerCase()) && (!kind || r.target.kind.toLowerCase() === kind.toLowerCase()));
    if (!relations) {
      return [];
    }
    const relationsByKindAndNamespace = Object.values(lodash.groupBy(relations, ({target}) => {
      return `${target.kind}:${target.namespace}`.toLowerCase();
    }));
    const batchedRelationsByKindAndNamespace = [];
    for (const rs of relationsByKindAndNamespace) {
      batchedRelationsByKindAndNamespace.push({
        kind: rs[0].target.kind,
        namespace: rs[0].target.namespace,
        nameBatches: lodash.chunk(rs.map((r) => r.target.name), BATCH_SIZE)
      });
    }
    const results = await Promise.all(batchedRelationsByKindAndNamespace.flatMap((rs) => {
      return rs.nameBatches.map((names) => {
        return catalogApi.getEntities({
          filter: {
            kind: rs.kind,
            "metadata.namespace": rs.namespace,
            "metadata.name": names
          }
        });
      });
    }));
    return results.flatMap((r) => r.items);
  }, [entity, type]);
  return {
    entities,
    loading,
    error
  };
}

const buildEntityKey = (component) => {
  var _a;
  return `entity:${component.kind}:${(_a = component.metadata.namespace) != null ? _a : "default"}:${component.metadata.name}`;
};
const useStarredEntities = () => {
  var _a;
  const storageApi = corePluginApi.useApi(corePluginApi.storageApiRef);
  const settingsStore = storageApi.forBucket("settings");
  const rawStarredEntityKeys = (_a = settingsStore.get("starredEntities")) != null ? _a : [];
  const [starredEntities, setStarredEntities] = React.useState(new Set(rawStarredEntityKeys));
  const observedItems = reactUse.useObservable(settingsStore.observe$("starredEntities"));
  React.useEffect(() => {
    var _a2;
    if (observedItems == null ? void 0 : observedItems.newValue) {
      const currentValue = (_a2 = observedItems == null ? void 0 : observedItems.newValue) != null ? _a2 : [];
      setStarredEntities(new Set(currentValue));
    }
  }, [observedItems == null ? void 0 : observedItems.newValue]);
  const toggleStarredEntity = React.useCallback((entity) => {
    const entityKey = buildEntityKey(entity);
    if (starredEntities.has(entityKey)) {
      starredEntities.delete(entityKey);
    } else {
      starredEntities.add(entityKey);
    }
    settingsStore.set("starredEntities", Array.from(starredEntities));
  }, [starredEntities, settingsStore]);
  const isStarredEntity = React.useCallback((entity) => {
    const entityKey = buildEntityKey(entity);
    return starredEntities.has(entityKey);
  }, [starredEntities]);
  return {
    starredEntities,
    toggleStarredEntity,
    isStarredEntity
  };
};

const EntityKindPicker = ({
  initialFilter,
  hidden
}) => {
  const [selectedKind] = React.useState(initialFilter);
  const {updateFilters} = useEntityListProvider();
  React.useEffect(() => {
    updateFilters({
      kind: selectedKind ? new EntityKindFilter(selectedKind) : void 0
    });
  }, [selectedKind, updateFilters]);
  if (hidden)
    return null;
  return /* @__PURE__ */ React__default['default'].createElement(lab.Alert, {
    severity: "warning"
  }, "Kind filter not yet available");
};

const EntityProvider = ({entity, children}) => /* @__PURE__ */ React__default['default'].createElement(EntityContext.Provider, {
  value: {
    entity,
    loading: !Boolean(entity),
    error: void 0
  }
}, children);

function formatEntityRefTitle(entityRef, opts) {
  const defaultKind = opts == null ? void 0 : opts.defaultKind;
  let kind;
  let namespace;
  let name;
  if ("metadata" in entityRef) {
    kind = entityRef.kind;
    namespace = entityRef.metadata.namespace;
    name = entityRef.metadata.name;
  } else {
    kind = entityRef.kind;
    namespace = entityRef.namespace;
    name = entityRef.name;
  }
  if (namespace === catalogModel.ENTITY_DEFAULT_NAMESPACE) {
    namespace = void 0;
  }
  kind = kind.toLowerCase();
  return `${catalogModel.serializeEntityRef({
    kind: defaultKind && defaultKind.toLowerCase() === kind ? void 0 : kind,
    name,
    namespace
  })}`;
}

const EntityRefLink = React.forwardRef((props, ref) => {
  var _a;
  const {entityRef, defaultKind, children, ...linkProps} = props;
  let kind;
  let namespace;
  let name;
  if ("metadata" in entityRef) {
    kind = entityRef.kind;
    namespace = entityRef.metadata.namespace;
    name = entityRef.metadata.name;
  } else {
    kind = entityRef.kind;
    namespace = entityRef.namespace;
    name = entityRef.name;
  }
  kind = kind.toLocaleLowerCase("en-US");
  const routeParams = {
    kind,
    namespace: (_a = namespace == null ? void 0 : namespace.toLocaleLowerCase("en-US")) != null ? _a : catalogModel.ENTITY_DEFAULT_NAMESPACE,
    name
  };
  return /* @__PURE__ */ React__default['default'].createElement(core.Link, {
    ...linkProps,
    ref,
    to: reactRouter.generatePath(`/catalog/${entityRoute.path}`, routeParams)
  }, children, !children && formatEntityRefTitle(entityRef, {defaultKind}));
});

const EntityRefLinks = ({
  entityRefs,
  defaultKind,
  ...linkProps
}) => /* @__PURE__ */ React__default['default'].createElement(React__default['default'].Fragment, null, entityRefs.map((r, i) => /* @__PURE__ */ React__default['default'].createElement(React__default['default'].Fragment, {
  key: i
}, i > 0 && ", ", /* @__PURE__ */ React__default['default'].createElement(EntityRefLink, {
  ...linkProps,
  entityRef: r,
  defaultKind
}))));

function createEntityRefColumn({
  defaultKind
}) {
  function formatContent(entity) {
    return formatEntityRefTitle(entity, {
      defaultKind
    });
  }
  return {
    title: "Name",
    highlight: true,
    customFilterAndSearch(filter, entity) {
      return formatContent(entity).includes(filter);
    },
    customSort(entity1, entity2) {
      return formatContent(entity1).localeCompare(formatContent(entity2));
    },
    render: (entity) => /* @__PURE__ */ React__default['default'].createElement(EntityRefLink, {
      entityRef: entity,
      defaultKind
    })
  };
}
function createEntityRelationColumn({
  title,
  relation,
  defaultKind,
  filter: entityFilter
}) {
  function getRelations(entity) {
    return getEntityRelations(entity, relation, entityFilter);
  }
  function formatContent(entity) {
    return getRelations(entity).map((r) => formatEntityRefTitle(r, {defaultKind})).join(", ");
  }
  return {
    title,
    customFilterAndSearch(filter, entity) {
      return formatContent(entity).includes(filter);
    },
    customSort(entity1, entity2) {
      return formatContent(entity1).localeCompare(formatContent(entity2));
    },
    render: (entity) => {
      return /* @__PURE__ */ React__default['default'].createElement(EntityRefLinks, {
        entityRefs: getRelations(entity),
        defaultKind
      });
    }
  };
}
function createOwnerColumn() {
  return createEntityRelationColumn({
    title: "Owner",
    relation: catalogModel.RELATION_OWNED_BY,
    defaultKind: "group"
  });
}
function createDomainColumn() {
  return createEntityRelationColumn({
    title: "Domain",
    relation: catalogModel.RELATION_PART_OF,
    defaultKind: "domain",
    filter: {
      kind: "domain"
    }
  });
}
function createSystemColumn() {
  return createEntityRelationColumn({
    title: "System",
    relation: catalogModel.RELATION_PART_OF,
    defaultKind: "system",
    filter: {
      kind: "system"
    }
  });
}
function createMetadataDescriptionColumn() {
  return {
    title: "Description",
    field: "metadata.description",
    render: (entity) => /* @__PURE__ */ React__default['default'].createElement(core.OverflowTooltip, {
      text: entity.metadata.description,
      placement: "bottom-start"
    }),
    width: "auto"
  };
}
function createSpecLifecycleColumn() {
  return {
    title: "Lifecycle",
    field: "spec.lifecycle"
  };
}
function createSpecTypeColumn() {
  return {
    title: "Type",
    field: "spec.type"
  };
}

var columnFactories = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createEntityRefColumn: createEntityRefColumn,
  createEntityRelationColumn: createEntityRelationColumn,
  createOwnerColumn: createOwnerColumn,
  createDomainColumn: createDomainColumn,
  createSystemColumn: createSystemColumn,
  createMetadataDescriptionColumn: createMetadataDescriptionColumn,
  createSpecLifecycleColumn: createSpecLifecycleColumn,
  createSpecTypeColumn: createSpecTypeColumn
});

const systemEntityColumns = [
  createEntityRefColumn({defaultKind: "system"}),
  createDomainColumn(),
  createOwnerColumn(),
  createMetadataDescriptionColumn()
];
const componentEntityColumns = [
  createEntityRefColumn({defaultKind: "component"}),
  createSystemColumn(),
  createOwnerColumn(),
  createSpecTypeColumn(),
  createSpecLifecycleColumn(),
  createMetadataDescriptionColumn()
];

const useStyles = core$1.makeStyles((theme) => ({
  empty: {
    padding: theme.spacing(2),
    display: "flex",
    justifyContent: "center"
  }
}));
function EntityTable({
  entities,
  title,
  emptyContent,
  variant = "gridItem",
  columns
}) {
  const classes = useStyles();
  const tableStyle = {
    minWidth: "0",
    width: "100%"
  };
  if (variant === "gridItem") {
    tableStyle.height = "calc(100% - 10px)";
  }
  return /* @__PURE__ */ React__default['default'].createElement(core.Table, {
    columns,
    title,
    style: tableStyle,
    emptyContent: emptyContent && /* @__PURE__ */ React__default['default'].createElement("div", {
      className: classes.empty
    }, emptyContent),
    options: {
      search: false,
      paging: false,
      actionsColumnIndex: -1,
      padding: "dense"
    },
    data: entities
  });
}
EntityTable.columns = columnFactories;
EntityTable.systemEntityColumns = systemEntityColumns;
EntityTable.componentEntityColumns = componentEntityColumns;

const icon = /* @__PURE__ */ React__default['default'].createElement(CheckBoxOutlineBlankIcon__default['default'], {
  fontSize: "small"
});
const checkedIcon = /* @__PURE__ */ React__default['default'].createElement(CheckBoxIcon__default['default'], {
  fontSize: "small"
});
const EntityTagPicker = () => {
  var _a, _b;
  const {updateFilters, backendEntities, filters} = useEntityListProvider();
  const availableTags = React.useMemo(() => [
    ...new Set(backendEntities.flatMap((e) => e.metadata.tags).filter(Boolean))
  ].sort(), [backendEntities]);
  if (!availableTags.length)
    return null;
  const onChange = (tags) => {
    updateFilters({
      tags: tags.length ? new EntityTagFilter(tags) : void 0
    });
  };
  return /* @__PURE__ */ React__default['default'].createElement(React__default['default'].Fragment, null, /* @__PURE__ */ React__default['default'].createElement(core$1.Typography, {
    variant: "button"
  }, "Tags"), /* @__PURE__ */ React__default['default'].createElement(lab.Autocomplete, {
    multiple: true,
    options: availableTags,
    value: (_b = (_a = filters.tags) == null ? void 0 : _a.values) != null ? _b : [],
    onChange: (_, value) => onChange(value),
    renderOption: (option, {selected}) => /* @__PURE__ */ React__default['default'].createElement(core$1.FormControlLabel, {
      control: /* @__PURE__ */ React__default['default'].createElement(core$1.Checkbox, {
        icon,
        checkedIcon,
        checked: selected
      }),
      label: option
    }),
    size: "small",
    popupIcon: /* @__PURE__ */ React__default['default'].createElement(ExpandMoreIcon__default['default'], {
      "data-testid": "tag-picker-expand"
    }),
    renderInput: (params) => /* @__PURE__ */ React__default['default'].createElement(core$1.TextField, {
      ...params,
      variant: "outlined"
    })
  }));
};

const EntityTypePicker = () => {
  const alertApi = core.useApi(core.alertApiRef);
  const {error, types, selectedType, setType} = useEntityTypeFilter();
  if (!types)
    return null;
  if (error) {
    alertApi.post({
      message: `Failed to load entity types`,
      severity: "error"
    });
    return null;
  }
  const items = [
    {value: "all", label: "All"},
    ...types.map((type) => ({
      value: type,
      label: lodash.capitalize(type)
    }))
  ];
  return /* @__PURE__ */ React__default['default'].createElement(core$1.Box, {
    pb: 1,
    pt: 1
  }, /* @__PURE__ */ React__default['default'].createElement(core.Select, {
    label: "Type",
    items,
    selected: selectedType != null ? selectedType : "all",
    onChange: (value) => setType(value === "all" ? void 0 : String(value))
  }));
};

const useStyles$1 = core$1.makeStyles((theme) => ({
  root: {
    backgroundColor: "rgba(0, 0, 0, .11)",
    boxShadow: "none",
    margin: theme.spacing(1, 0, 1, 0)
  },
  title: {
    margin: theme.spacing(1, 0, 0, 1),
    textTransform: "uppercase",
    fontSize: 12,
    fontWeight: "bold"
  },
  listIcon: {
    minWidth: 30,
    color: theme.palette.text.primary
  },
  menuItem: {
    minHeight: theme.spacing(6)
  },
  groupWrapper: {
    margin: theme.spacing(1, 1, 2, 1)
  }
}));
function getFilterGroups(orgName) {
  return [
    {
      name: "Personal",
      items: [
        {
          id: "owned",
          label: "Owned",
          icon: SettingsIcon__default['default']
        },
        {
          id: "starred",
          label: "Starred",
          icon: StarIcon__default['default']
        }
      ]
    },
    {
      name: orgName != null ? orgName : "Company",
      items: [
        {
          id: "all",
          label: "All"
        }
      ]
    }
  ];
}
const UserListPicker = ({initialFilter}) => {
  var _a;
  const classes = useStyles$1();
  const configApi = core.useApi(core.configApiRef);
  const orgName = (_a = configApi.getOptionalString("organization.name")) != null ? _a : "Company";
  const filterGroups = getFilterGroups(orgName);
  const {value: user} = useOwnUser();
  const {isStarredEntity} = useStarredEntities();
  const [selectedUserFilter, setSelectedUserFilter] = React.useState(initialFilter);
  const ownedFilter = React.useMemo(() => new UserListFilter("owned", user, isStarredEntity), [user, isStarredEntity]);
  const starredFilter = React.useMemo(() => new UserListFilter("starred", user, isStarredEntity), [user, isStarredEntity]);
  const {filters, updateFilters, backendEntities} = useEntityListProvider();
  React.useEffect(() => {
    updateFilters({
      user: selectedUserFilter ? new UserListFilter(selectedUserFilter, user, isStarredEntity) : void 0
    });
  }, [selectedUserFilter, user, isStarredEntity, updateFilters]);
  const [entitiesWithoutUserFilter, setEntitiesWithoutUserFilter] = React.useState(backendEntities);
  React.useEffect(() => {
    const filterFn = reduceEntityFilters(lodash.compact(Object.values({...filters, user: void 0})));
    setEntitiesWithoutUserFilter(backendEntities.filter(filterFn));
  }, [filters, backendEntities]);
  function getFilterCount(id) {
    switch (id) {
      case "owned":
        return entitiesWithoutUserFilter.filter((entity) => ownedFilter.filterEntity(entity)).length;
      case "starred":
        return entitiesWithoutUserFilter.filter((entity) => starredFilter.filterEntity(entity)).length;
      default:
        return entitiesWithoutUserFilter.length;
    }
  }
  return /* @__PURE__ */ React__default['default'].createElement(core$1.Card, {
    className: classes.root
  }, filterGroups.map((group) => /* @__PURE__ */ React__default['default'].createElement(React.Fragment, {
    key: group.name
  }, /* @__PURE__ */ React__default['default'].createElement(core$1.Typography, {
    variant: "subtitle2",
    className: classes.title
  }, group.name), /* @__PURE__ */ React__default['default'].createElement(core$1.Card, {
    className: classes.groupWrapper
  }, /* @__PURE__ */ React__default['default'].createElement(core$1.List, {
    disablePadding: true,
    dense: true
  }, group.items.map((item) => {
    var _a2, _b;
    return /* @__PURE__ */ React__default['default'].createElement(core$1.MenuItem, {
      key: item.id,
      button: true,
      divider: true,
      onClick: () => setSelectedUserFilter(item.id),
      selected: item.id === ((_a2 = filters.user) == null ? void 0 : _a2.value),
      className: classes.menuItem
    }, item.icon && /* @__PURE__ */ React__default['default'].createElement(core$1.ListItemIcon, {
      className: classes.listIcon
    }, /* @__PURE__ */ React__default['default'].createElement(item.icon, {
      fontSize: "small"
    })), /* @__PURE__ */ React__default['default'].createElement(core$1.ListItemText, null, /* @__PURE__ */ React__default['default'].createElement(core$1.Typography, {
      variant: "body1",
      "data-testid": `user-picker-${item.id}`
    }, item.label)), /* @__PURE__ */ React__default['default'].createElement(core$1.ListItemSecondaryAction, null, (_b = getFilterCount(item.id)) != null ? _b : "-"));
  }))))));
};

const MockEntityListContextProvider = ({
  children,
  value
}) => {
  const defaultContext = {
    entities: [],
    backendEntities: [],
    updateFilters: jest.fn(),
    filters: {},
    loading: false
  };
  return /* @__PURE__ */ React__default['default'].createElement(EntityListContext.Provider, {
    value: {...defaultContext, ...value}
  }, children);
};

exports.EntityContext = EntityContext;
exports.EntityKindFilter = EntityKindFilter;
exports.EntityKindPicker = EntityKindPicker;
exports.EntityListContext = EntityListContext;
exports.EntityListProvider = EntityListProvider;
exports.EntityProvider = EntityProvider;
exports.EntityRefLink = EntityRefLink;
exports.EntityRefLinks = EntityRefLinks;
exports.EntityTable = EntityTable;
exports.EntityTagFilter = EntityTagFilter;
exports.EntityTagPicker = EntityTagPicker;
exports.EntityTypeFilter = EntityTypeFilter;
exports.EntityTypePicker = EntityTypePicker;
exports.MockEntityListContextProvider = MockEntityListContextProvider;
exports.UserListFilter = UserListFilter;
exports.UserListPicker = UserListPicker;
exports.catalogApiRef = catalogApiRef;
exports.catalogRouteRef = catalogRouteRef;
exports.entityRoute = entityRoute;
exports.entityRouteParams = entityRouteParams;
exports.entityRouteRef = entityRouteRef;
exports.formatEntityRefTitle = formatEntityRefTitle;
exports.getEntityRelations = getEntityRelations;
exports.isOwnerOf = isOwnerOf;
exports.reduceCatalogFilters = reduceCatalogFilters;
exports.reduceEntityFilters = reduceEntityFilters;
exports.rootRoute = rootRoute;
exports.useEntity = useEntity;
exports.useEntityCompoundName = useEntityCompoundName;
exports.useEntityFromUrl = useEntityFromUrl;
exports.useEntityListProvider = useEntityListProvider;
exports.useEntityTypeFilter = useEntityTypeFilter;
exports.useOwnUser = useOwnUser;
exports.useRelatedEntities = useRelatedEntities;
exports.useStarredEntities = useStarredEntities;
//# sourceMappingURL=index.cjs.js.map
