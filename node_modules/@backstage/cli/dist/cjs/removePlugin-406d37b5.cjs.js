'use strict';

require('commander');
var chalk = require('chalk');
var index = require('./index-5c3253a4.cjs.js');
var fs = require('fs-extra');
require('@backstage/cli-common');
require('@backstage/config/package.json');
var path = require('path');
var inquirer = require('inquirer');
var tasks = require('./tasks-62a62154.cjs.js');
require('handlebars');
require('ora');
require('recursive-readdir');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var chalk__default = /*#__PURE__*/_interopDefaultLegacy(chalk);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var inquirer__default = /*#__PURE__*/_interopDefaultLegacy(inquirer);

const BACKSTAGE = "@backstage";
const checkExists = async (rootDir, pluginName) => {
  await tasks.Task.forItem("checking", pluginName, async () => {
    try {
      const destination = path__default['default'].join(rootDir, "plugins", pluginName);
      const pathExist = await fs__default['default'].pathExists(destination);
      if (!pathExist) {
        throw new Error(chalk__default['default'].red(`   Plugin ${chalk__default['default'].cyan(pluginName)} does not exist!`));
      }
    } catch (e) {
      throw new Error(chalk__default['default'].red(`   There was an error removing plugin ${chalk__default['default'].cyan(pluginName)}: ${e.message}`));
    }
  });
};
const removePluginDirectory = async (destination) => {
  await tasks.Task.forItem("removing", "plugin files", async () => {
    try {
      await fs__default['default'].remove(destination);
    } catch (e) {
      throw Error(chalk__default['default'].red(`   There was a problem removing the plugin directory: ${e.message}`));
    }
  });
};
const removeSymLink = async (destination) => {
  await tasks.Task.forItem("removing", "symbolic link", async () => {
    const symLinkExists = await fs__default['default'].pathExists(destination);
    if (symLinkExists) {
      try {
        await fs__default['default'].remove(destination);
      } catch (e) {
        throw Error(chalk__default['default'].red(`   Could not remove symbolic link	${chalk__default['default'].cyan(destination)}: ${e.message}`));
      }
    }
  });
};
const removeAllStatementsContainingID = async (file, ID) => {
  const originalContent = await fs__default['default'].readFile(file, "utf8");
  const contentAfterRemoval = originalContent.split("\n").filter((statement) => !statement.includes(`${ID}`)).join("\n");
  if (originalContent !== contentAfterRemoval) {
    await fs__default['default'].writeFile(file, contentAfterRemoval, "utf8");
  }
};
const capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1);
const removeReferencesFromPluginsFile = async (pluginsFile, pluginName) => {
  const pluginNameCapitalized = pluginName.split("-").map((name) => capitalize(name)).join("");
  await tasks.Task.forItem("removing", "export references", async () => {
    try {
      await removeAllStatementsContainingID(pluginsFile, pluginNameCapitalized);
    } catch (e) {
      throw new Error(chalk__default['default'].red(`   There was an error removing export statement for plugin ${chalk__default['default'].cyan(pluginNameCapitalized)}: ${e.message}`));
    }
  });
};
const removePluginFromCodeOwners = async (codeOwnersFile, pluginName) => {
  await tasks.Task.forItem("removing", "codeowners references", async () => {
    try {
      await removeAllStatementsContainingID(codeOwnersFile, pluginName);
    } catch (e) {
      throw new Error(chalk__default['default'].red(`   There was an error removing code owners statement for plugin ${chalk__default['default'].cyan(pluginName)}: ${e.message}`));
    }
  });
};
const removeReferencesFromAppPackage = async (appPackageFile, pluginName) => {
  const pluginPackage = `${BACKSTAGE}/plugin-${pluginName}`;
  await tasks.Task.forItem("removing", "plugin app dependency", async () => {
    try {
      const appPackageFileContent = await fs__default['default'].readFile(appPackageFile, "utf-8");
      const appPackageFileContentJSON = JSON.parse(appPackageFileContent);
      const dependencies = appPackageFileContentJSON.dependencies;
      if (!dependencies[pluginPackage]) {
        throw new Error(chalk__default['default'].red(` Plugin ${chalk__default['default'].cyan(pluginPackage)} does not exist in ${chalk__default['default'].cyan(appPackageFile)}`));
      }
      delete dependencies[pluginPackage];
      await fs__default['default'].writeFile(appPackageFile, `${JSON.stringify(appPackageFileContentJSON, null, 2)}
`, "utf-8");
    } catch (e) {
      throw new Error(chalk__default['default'].red(`  Failed to remove plugin as dependency in app: ${chalk__default['default'].cyan(appPackageFile)}: ${e.message}`));
    }
  });
};
var removePlugin = async () => {
  const questions = [
    {
      type: "input",
      name: "pluginName",
      message: chalk__default['default'].blue("Enter the ID of the plugin to be removed [required]"),
      validate: (value) => {
        if (!value) {
          return chalk__default['default'].red("Please enter an ID for the plugin");
        } else if (!/^[a-z0-9]+(-[a-z0-9]+)*$/.test(value)) {
          return chalk__default['default'].red("Plugin IDs must be lowercase and contain only letters, digits and dashes.");
        }
        return true;
      }
    }
  ];
  const answers = await inquirer__default['default'].prompt(questions);
  const pluginName = answers.pluginName;
  const appPackage = index.paths.resolveTargetRoot("packages/app");
  const pluginDir = index.paths.resolveTargetRoot("plugins", answers.pluginName);
  const codeOwnersFile = await tasks.getCodeownersFilePath(index.paths.targetRoot);
  const appPackageFile = path__default['default'].join(appPackage, "package.json");
  const appPluginsFile = path__default['default'].join(appPackage, "src", "plugins.ts");
  const pluginScopedDirectory = index.paths.resolveTargetRoot("node_modules", BACKSTAGE, `plugin-${pluginName}`);
  tasks.Task.log();
  tasks.Task.log("Removing the plugin...");
  console.log(pluginScopedDirectory);
  try {
    tasks.Task.section("Checking the plugin exists.");
    await checkExists(index.paths.targetRoot, pluginName);
    tasks.Task.section("Removing plugin files.");
    await removePluginDirectory(pluginDir);
    tasks.Task.section("Removing symbolic link from @backstage.");
    await removeSymLink(pluginScopedDirectory);
    if (await fs__default['default'].pathExists(appPackage)) {
      tasks.Task.section("Removing references from plugins.ts.");
      await removeReferencesFromPluginsFile(appPluginsFile, pluginName);
      tasks.Task.section("Removing plugin dependency from app.");
      await removeReferencesFromAppPackage(appPackageFile, pluginName);
    }
    if (codeOwnersFile) {
      tasks.Task.section("Removing codeowners reference.");
      await removePluginFromCodeOwners(codeOwnersFile, pluginName);
    }
    tasks.Task.log();
    tasks.Task.log(`\u{1F947}  Successfully removed ${chalk__default['default'].cyan(`@backstage/plugin-${answers.id}`)}`);
    tasks.Task.log();
  } catch (error) {
    tasks.Task.error(error.message);
    tasks.Task.log("It seems that something went wrong when removing the plugin \u{1F914}");
  }
};

exports.checkExists = checkExists;
exports.default = removePlugin;
exports.removePluginDirectory = removePluginDirectory;
exports.removePluginFromCodeOwners = removePluginFromCodeOwners;
exports.removeReferencesFromAppPackage = removeReferencesFromAppPackage;
exports.removeReferencesFromPluginsFile = removeReferencesFromPluginsFile;
exports.removeSymLink = removeSymLink;
//# sourceMappingURL=removePlugin-406d37b5.cjs.js.map
