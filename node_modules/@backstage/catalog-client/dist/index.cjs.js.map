{"version":3,"file":"index.cjs.js","sources":["../src/CatalogClient.ts","../src/types/status.ts"],"sourcesContent":["/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Entity,\n  EntityName,\n  Location,\n  LOCATION_ANNOTATION,\n  ORIGIN_LOCATION_ANNOTATION,\n  stringifyLocationReference,\n} from '@backstage/catalog-model';\nimport { ResponseError } from '@backstage/errors';\nimport fetch from 'cross-fetch';\nimport {\n  AddLocationRequest,\n  AddLocationResponse,\n  CatalogApi,\n  CatalogEntitiesRequest,\n  CatalogListResponse,\n  CatalogRequestOptions,\n} from './types/api';\nimport { DiscoveryApi } from './types/discovery';\n\nexport class CatalogClient implements CatalogApi {\n  private readonly discoveryApi: DiscoveryApi;\n\n  constructor(options: { discoveryApi: DiscoveryApi }) {\n    this.discoveryApi = options.discoveryApi;\n  }\n\n  async getLocationById(\n    id: string,\n    options?: CatalogRequestOptions,\n  ): Promise<Location | undefined> {\n    return await this.requestOptional(\n      'GET',\n      `/locations/${encodeURIComponent(id)}`,\n      options,\n    );\n  }\n\n  async getEntities(\n    request?: CatalogEntitiesRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<CatalogListResponse<Entity>> {\n    const { filter = [], fields = [] } = request ?? {};\n    const filterItems = [filter].flat();\n    const params: string[] = [];\n\n    // filter param can occur multiple times, for example\n    // /api/catalog/entities?filter=metadata.name=wayback-search,kind=component&filter=metadata.name=www-artist,kind=component'\n    // the \"outer array\" defined by `filter` occurrences corresponds to \"anyOf\" filters\n    // the \"inner array\" defined within a `filter` param corresponds to \"allOf\" filters\n    for (const filterItem of filterItems) {\n      const filterParts: string[] = [];\n      for (const [key, value] of Object.entries(filterItem)) {\n        for (const v of [value].flat()) {\n          filterParts.push(\n            `${encodeURIComponent(key)}=${encodeURIComponent(v)}`,\n          );\n        }\n      }\n\n      if (filterParts.length) {\n        params.push(`filter=${filterParts.join(',')}`);\n      }\n    }\n\n    if (fields.length) {\n      params.push(`fields=${fields.map(encodeURIComponent).join(',')}`);\n    }\n\n    const query = params.length ? `?${params.join('&')}` : '';\n    const entities: Entity[] = await this.requestRequired(\n      'GET',\n      `/entities${query}`,\n      options,\n    );\n    return { items: entities };\n  }\n\n  async getEntityByName(\n    compoundName: EntityName,\n    options?: CatalogRequestOptions,\n  ): Promise<Entity | undefined> {\n    const { kind, namespace = 'default', name } = compoundName;\n    return this.requestOptional(\n      'GET',\n      `/entities/by-name/${encodeURIComponent(kind)}/${encodeURIComponent(\n        namespace,\n      )}/${encodeURIComponent(name)}`,\n      options,\n    );\n  }\n\n  async addLocation(\n    { type = 'url', target, dryRun, presence }: AddLocationRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<AddLocationResponse> {\n    const response = await fetch(\n      `${await this.discoveryApi.getBaseUrl('catalog')}/locations${\n        dryRun ? '?dryRun=true' : ''\n      }`,\n      {\n        headers: {\n          'Content-Type': 'application/json',\n          ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n        },\n        method: 'POST',\n        body: JSON.stringify({ type, target, presence }),\n      },\n    );\n\n    if (response.status !== 201) {\n      throw new Error(await response.text());\n    }\n\n    const { location, entities } = await response.json();\n\n    if (!location) {\n      throw new Error(`Location wasn't added: ${target}`);\n    }\n\n    // TODO(jhaals): This will throw using the experimental catalog since all discovered entities are deferred.\n    if (entities.length === 0) {\n      throw new Error(\n        `Location was added but has no entities specified yet: ${target}`,\n      );\n    }\n    return {\n      location,\n      entities,\n    };\n  }\n\n  async getOriginLocationByEntity(\n    entity: Entity,\n    options?: CatalogRequestOptions,\n  ): Promise<Location | undefined> {\n    const locationCompound =\n      entity.metadata.annotations?.[ORIGIN_LOCATION_ANNOTATION];\n    if (!locationCompound) {\n      return undefined;\n    }\n    const all: { data: Location }[] = await this.requestRequired(\n      'GET',\n      '/locations',\n      options,\n    );\n    return all\n      .map(r => r.data)\n      .find(l => locationCompound === stringifyLocationReference(l));\n  }\n\n  async getLocationByEntity(\n    entity: Entity,\n    options?: CatalogRequestOptions,\n  ): Promise<Location | undefined> {\n    const locationCompound = entity.metadata.annotations?.[LOCATION_ANNOTATION];\n    if (!locationCompound) {\n      return undefined;\n    }\n    const all: { data: Location }[] = await this.requestRequired(\n      'GET',\n      '/locations',\n      options,\n    );\n    return all\n      .map(r => r.data)\n      .find(l => locationCompound === stringifyLocationReference(l));\n  }\n\n  async removeLocationById(\n    id: string,\n    options?: CatalogRequestOptions,\n  ): Promise<void> {\n    await this.requestIgnored(\n      'DELETE',\n      `/locations/${encodeURIComponent(id)}`,\n      options,\n    );\n  }\n\n  async removeEntityByUid(\n    uid: string,\n    options?: CatalogRequestOptions,\n  ): Promise<void> {\n    await this.requestIgnored(\n      'DELETE',\n      `/entities/by-uid/${encodeURIComponent(uid)}`,\n      options,\n    );\n  }\n\n  //\n  // Private methods\n  //\n\n  private async requestIgnored(\n    method: string,\n    path: string,\n    options?: CatalogRequestOptions,\n  ): Promise<void> {\n    const url = `${await this.discoveryApi.getBaseUrl('catalog')}${path}`;\n    const headers: Record<string, string> = options?.token\n      ? { Authorization: `Bearer ${options.token}` }\n      : {};\n    const response = await fetch(url, { method, headers });\n\n    if (!response.ok) {\n      throw await ResponseError.fromResponse(response);\n    }\n  }\n\n  private async requestRequired(\n    method: string,\n    path: string,\n    options?: CatalogRequestOptions,\n  ): Promise<any> {\n    const url = `${await this.discoveryApi.getBaseUrl('catalog')}${path}`;\n    const headers: Record<string, string> = options?.token\n      ? { Authorization: `Bearer ${options.token}` }\n      : {};\n    const response = await fetch(url, { method, headers });\n\n    if (!response.ok) {\n      throw await ResponseError.fromResponse(response);\n    }\n\n    return await response.json();\n  }\n\n  private async requestOptional(\n    method: string,\n    path: string,\n    options?: CatalogRequestOptions,\n  ): Promise<any | undefined> {\n    const url = `${await this.discoveryApi.getBaseUrl('catalog')}${path}`;\n    const headers: Record<string, string> = options?.token\n      ? { Authorization: `Bearer ${options.token}` }\n      : {};\n    const response = await fetch(url, { method, headers });\n\n    if (!response.ok) {\n      if (response.status === 404) {\n        return undefined;\n      }\n      throw await ResponseError.fromResponse(response);\n    }\n\n    return await response.json();\n  }\n}\n","/*\n * Copyright 2021 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * The entity `status.items[].type` for the status of the processing engine in\n * regards to an entity.\n */\nexport const ENTITY_STATUS_CATALOG_PROCESSING_TYPE =\n  'backstage.io/catalog-processing';\n"],"names":["fetch","ORIGIN_LOCATION_ANNOTATION","stringifyLocationReference","LOCATION_ANNOTATION","ResponseError"],"mappings":"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"}