/// <reference types="node" />
import { Logger } from 'winston';
import { Entity, EntityRelationSpec, EntityName, Location, LocationSpec, EntityPolicy, ResourceEntityV1alpha1, Validators } from '@backstage/catalog-model';
import { Knex } from 'knex';
import { UrlReader, PluginEndpointDiscovery, PluginDatabaseManager } from '@backstage/backend-common';
import { Config, JsonValue } from '@backstage/config';
import { ScmIntegrationRegistry, BitbucketIntegration, ScmIntegrations } from '@backstage/integration';
import { Organizations } from 'aws-sdk';
import { Account } from 'aws-sdk/clients/organizations';
import { SearchOptions } from 'ldapjs';
import { IndexableDocument, DocumentCollator } from '@backstage/search-common';
import express from 'express';

declare type DbEntityRequest = {
    locationId?: string;
    entity: Entity;
    relations: EntityRelationSpec[];
};
declare type DbEntitiesRequest = {
    filter?: EntityFilter;
    pagination?: EntityPagination;
};
declare type DbEntitiesResponse = {
    entities: DbEntityResponse[];
    pageInfo: DbPageInfo;
};
declare type DbPageInfo = {
    hasNextPage: false;
} | {
    hasNextPage: true;
    endCursor: string;
};
declare type DbEntityResponse = {
    locationId?: string;
    entity: Entity;
};
declare type DbLocationsRow = {
    id: string;
    type: string;
    target: string;
};
declare type DbLocationsRowWithStatus = DbLocationsRow & {
    status: string | null;
    timestamp: string | null;
    message: string | null;
};
declare enum DatabaseLocationUpdateLogStatus {
    FAIL = "fail",
    SUCCESS = "success"
}
declare type DatabaseLocationUpdateLogEvent = {
    id: string;
    status: DatabaseLocationUpdateLogStatus;
    location_id: string;
    entity_name: string;
    created_at?: string;
    message?: string;
};
/**
 * Matches rows in the entities_search table.
 */
declare type EntitiesSearchFilter = {
    /**
     * The key to match on.
     *
     * Matches are always case insensitive.
     */
    key: string;
    /**
     * Match on plain equality of values.
     *
     * If undefined, this factor is not taken into account. Otherwise, match on
     * values that are equal to any of the given array items. Matches are always
     * case insensitive.
     */
    matchValueIn?: string[];
};
/**
 * A filter expression for entities.
 *
 * Any (at least one) of the outer sets must match, within which all of the
 * individual filters must match.
 */
declare type EntityFilter = {
    anyOf: {
        allOf: EntitiesSearchFilter[];
    }[];
};
/**
 * A pagination rule for entities.
 */
declare type EntityPagination = {
    limit?: number;
    offset?: number;
    after?: string;
};
/**
 * An abstraction for transactions of the underlying database technology.
 */
declare type Transaction = {
    rollback(): Promise<unknown>;
};
/**
 * An abstraction on top of the underlying database, wrapping the basic CRUD
 * needs.
 */
declare type Database = {
    /**
     * Runs a transaction.
     *
     * The callback is expected to make calls back into this class. When it
     * completes, the transaction is closed.
     *
     * @param fn The callback that implements the transaction
     */
    transaction<T>(fn: (tx: Transaction) => Promise<T>): Promise<T>;
    /**
     * Adds a set of new entities to the catalog.
     *
     * @param tx An ongoing transaction
     * @param request The entities being added
     */
    addEntities(tx: Transaction, request: DbEntityRequest[]): Promise<DbEntityResponse[]>;
    /**
     * Updates an existing entity in the catalog.
     *
     * The given entity must contain an uid to identify an already stored entity
     * in the catalog. If it is missing or if no matching entity is found, the
     * operation fails.
     *
     * If matchingEtag or matchingGeneration are given, they are taken into
     * account. Attempts to update a matching entity, but where the etag and/or
     * generation are not equal to the passed values, will fail.
     *
     * @param tx An ongoing transaction
     * @param request The entity being updated
     * @param matchingEtag If specified, reject with ConflictError if not
     *                     matching the entry in the database
     * @param matchingGeneration If specified, reject with ConflictError if not
     *                           matching the entry in the database
     * @returns The updated entity
     */
    updateEntity(tx: Transaction, request: DbEntityRequest, matchingEtag?: string, matchingGeneration?: number): Promise<DbEntityResponse>;
    entities(tx: Transaction, request?: DbEntitiesRequest): Promise<DbEntitiesResponse>;
    entityByName(tx: Transaction, name: EntityName): Promise<DbEntityResponse | undefined>;
    entityByUid(tx: Transaction, uid: string): Promise<DbEntityResponse | undefined>;
    removeEntityByUid(tx: Transaction, uid: string): Promise<void>;
    /**
     * Remove current relations for the entity and replace them with the new
     * relations array.
     *
     * @param tx An ongoing transaction
     * @param entityUid The entity uid
     * @param relations The relationships to be set
     */
    setRelations(tx: Transaction, entityUid: string, relations: EntityRelationSpec[]): Promise<void>;
    addLocation(tx: Transaction, location: Location): Promise<DbLocationsRow>;
    removeLocation(tx: Transaction, id: string): Promise<void>;
    location(id: string): Promise<DbLocationsRowWithStatus>;
    locations(): Promise<DbLocationsRowWithStatus[]>;
    locationHistory(id: string): Promise<DatabaseLocationUpdateLogEvent[]>;
    addLocationUpdateLogEvent(locationId: string, status: DatabaseLocationUpdateLogStatus, entityName?: string | string[], message?: string): Promise<void>;
};

/**
 * The core database implementation.
 */
declare class CommonDatabase implements Database {
    private readonly database;
    private readonly logger;
    constructor(database: Knex, logger: Logger);
    transaction<T>(fn: (tx: Transaction) => Promise<T>): Promise<T>;
    addEntities(txOpaque: Transaction, request: DbEntityRequest[]): Promise<DbEntityResponse[]>;
    updateEntity(txOpaque: Transaction, request: DbEntityRequest, matchingEtag?: string, matchingGeneration?: number): Promise<DbEntityResponse>;
    entities(txOpaque: Transaction, request?: DbEntitiesRequest): Promise<DbEntitiesResponse>;
    entityByName(txOpaque: Transaction, name: EntityName): Promise<DbEntityResponse | undefined>;
    entityByUid(txOpaque: Transaction, uid: string): Promise<DbEntityResponse | undefined>;
    removeEntityByUid(txOpaque: Transaction, uid: string): Promise<void>;
    setRelations(txOpaque: Transaction, originatingEntityId: string, relations: EntityRelationSpec[]): Promise<void>;
    addLocation(txOpaque: Transaction, location: Location): Promise<DbLocationsRow>;
    removeLocation(txOpaque: Transaction, id: string): Promise<void>;
    location(id: string): Promise<DbLocationsRowWithStatus>;
    locations(): Promise<DbLocationsRowWithStatus[]>;
    locationHistory(id: string): Promise<DatabaseLocationUpdateLogEvent[]>;
    addLocationUpdateLogEvent(locationId: string, status: DatabaseLocationUpdateLogStatus, entityName?: string | string[], message?: string): Promise<void>;
    private toEntityRow;
    private toRelationRows;
    private toEntityResponses;
    private getRelationsPerFullName;
}

declare type CreateDatabaseOptions = {
    logger: Logger;
};
declare class DatabaseManager {
    static createDatabase(knex: Knex, options?: Partial<CreateDatabaseOptions>): Promise<Database>;
    static createInMemoryDatabase(): Promise<Database>;
    static createInMemoryDatabaseConnection(): Promise<Knex>;
    static createTestDatabase(): Promise<Database>;
    static createTestDatabaseConnection(): Promise<Knex>;
}

declare type PageInfo = {
    hasNextPage: false;
} | {
    hasNextPage: true;
    endCursor: string;
};
declare type EntitiesRequest = {
    filter?: EntityFilter;
    fields?: (entity: Entity) => Entity;
    pagination?: EntityPagination;
};
declare type EntitiesResponse = {
    entities: Entity[];
    pageInfo: PageInfo;
};
declare type EntityUpsertRequest = {
    entity: Entity;
    relations: EntityRelationSpec[];
};
declare type EntityUpsertResponse = {
    entityId: string;
    entity?: Entity;
};
declare type EntitiesCatalog = {
    /**
     * Fetch entities.
     *
     * @param request Request options
     */
    entities(request?: EntitiesRequest): Promise<EntitiesResponse>;
    /**
     * Removes a single entity.
     *
     * @param uid The metadata.uid of the entity
     */
    removeEntityByUid(uid: string): Promise<void>;
    /**
     * Writes a number of entities efficiently to storage.
     *
     * @param requests The entities and their relations
     * @param options.locationId The location that they all belong to (default none)
     * @param options.dryRun Whether to throw away the results (default false)
     * @param options.outputEntities Whether to return the resulting entities (default false)
     */
    batchAddOrUpdateEntities(requests: EntityUpsertRequest[], options?: {
        locationId?: string;
        dryRun?: boolean;
        outputEntities?: boolean;
    }): Promise<EntityUpsertResponse[]>;
};
declare type LocationUpdateStatus = {
    timestamp: string | null;
    status: string | null;
    message: string | null;
};
declare type LocationUpdateLogEvent = {
    id: string;
    status: 'fail' | 'success';
    location_id: string;
    entity_name: string;
    created_at?: string;
    message?: string;
};
declare type LocationResponse = {
    data: Location;
    currentStatus: LocationUpdateStatus;
};
declare type LocationsCatalog = {
    addLocation(location: Location): Promise<Location>;
    removeLocation(id: string): Promise<void>;
    locations(): Promise<LocationResponse[]>;
    location(id: string): Promise<LocationResponse>;
    locationHistory(id: string): Promise<LocationUpdateLogEvent[]>;
    logUpdateSuccess(locationId: string, entityName?: string | string[]): Promise<void>;
    logUpdateFailure(locationId: string, error?: Error, entityName?: string): Promise<void>;
};

declare class DatabaseEntitiesCatalog implements EntitiesCatalog {
    private readonly database;
    private readonly logger;
    constructor(database: Database, logger: Logger);
    entities(request?: EntitiesRequest): Promise<EntitiesResponse>;
    removeEntityByUid(uid: string): Promise<void>;
    batchAddOrUpdateEntities(requests: EntityUpsertRequest[], options?: {
        locationId?: string;
        dryRun?: boolean;
        outputEntities?: boolean;
    }): Promise<EntityUpsertResponse[]>;
    private batchAddOrUpdateEntitiesSingleBatch;
    private analyzeBatch;
    private batchAdd;
    private batchUpdate;
    private addOrUpdateEntity;
}

declare class DatabaseLocationsCatalog implements LocationsCatalog {
    private readonly database;
    constructor(database: Database);
    addLocation(location: Location): Promise<Location>;
    removeLocation(id: string): Promise<void>;
    locations(): Promise<LocationResponse[]>;
    locationHistory(id: string): Promise<DatabaseLocationUpdateLogEvent[]>;
    location(id: string): Promise<LocationResponse>;
    logUpdateSuccess(locationId: string, entityName?: string | string[]): Promise<void>;
    logUpdateFailure(locationId: string, error?: Error, entityName?: string): Promise<void>;
}

/**
 * Makes all keys of an entire hierarchy optional.
 */
declare type RecursivePartial<T> = {
    [P in keyof T]?: T[P] extends (infer U)[] ? RecursivePartial<U>[] : T[P] extends object ? RecursivePartial<T[P]> : T[P];
};

declare type HigherOrderOperation = {
    addLocation(spec: LocationSpec, options?: {
        dryRun?: boolean;
    }): Promise<AddLocationResult>;
    refreshAllLocations(): Promise<void>;
};
declare type AddLocationResult = {
    location: Location;
    entities: Entity[];
};
declare type LocationReader = {
    /**
     * Reads the contents of a location.
     *
     * @param location The location to read
     * @throws An error if the location was handled by this reader, but could not
     *         be read
     */
    read(location: LocationSpec): Promise<ReadLocationResult>;
};
declare type ReadLocationResult = {
    entities: ReadLocationEntity[];
    errors: ReadLocationError[];
};
declare type ReadLocationEntity = {
    location: LocationSpec;
    entity: Entity;
    relations: EntityRelationSpec[];
};
declare type ReadLocationError = {
    location: LocationSpec;
    error: Error;
};
declare type LocationAnalyzer = {
    /**
     * Generates an entity configuration for given git repository. It's used for
     * importing new component to the backstage app.
     *
     * @param location Git repository to analyze and generate config for.
     */
    analyzeLocation(location: AnalyzeLocationRequest): Promise<AnalyzeLocationResponse>;
};
declare type AnalyzeLocationRequest = {
    location: LocationSpec;
};
declare type AnalyzeLocationResponse = {
    existingEntityFiles: AnalyzeLocationExistingEntity[];
    generateEntities: AnalyzeLocationGenerateEntity[];
};
declare type AnalyzeLocationExistingEntity = {
    location: LocationSpec;
    isRegistered: boolean;
    entity: Entity;
};
declare type AnalyzeLocationGenerateEntity = {
    entity: RecursivePartial<Entity>;
    fields: AnalyzeLocationEntityField[];
};
declare type AnalyzeLocationEntityField = {
    field: string;
    state: 'analysisSuggestedValue' | 'analysisSuggestedNoValue' | 'needsUserInput';
    value: string | null;
    description: string;
};

/**
 * Placeholder for operations that span several catalogs and/or stretches out
 * in time.
 *
 * TODO(freben): Find a better home for these, possibly refactoring to use the
 * database more directly.
 */
declare class HigherOrderOperations implements HigherOrderOperation {
    private readonly entitiesCatalog;
    private readonly locationsCatalog;
    private readonly locationReader;
    private readonly logger;
    constructor(entitiesCatalog: EntitiesCatalog, locationsCatalog: LocationsCatalog, locationReader: LocationReader, logger: Logger);
    /**
     * Adds a single location to the catalog.
     *
     * The location is inspected and fetched, and all of the resulting data is
     * validated. If everything goes well, the location and entities are stored
     * in the catalog.
     *
     * If the location already existed, the old location is returned instead and
     * the catalog is left unchanged.
     *
     * @param spec The location to add
     */
    addLocation(spec: LocationSpec, options?: {
        dryRun?: boolean;
    }): Promise<AddLocationResult>;
    /**
     * Goes through all registered locations, and performs a refresh of each one.
     *
     * Entities are read from their respective sources, are parsed and validated
     * according to the entity policy, and get inserted or updated in the catalog.
     * Entities that have disappeared from their location are left orphaned,
     * without changes.
     */
    refreshAllLocations(): Promise<void>;
    private refreshSingleLocation;
}

/**
 * A structure for matching entities to a given rule.
 */
declare type EntityMatcher = {
    kind: string;
};
/**
 * A structure for matching locations to a given rule.
 */
declare type LocationMatcher = {
    target?: string;
    type: string;
};
/**
 * Rules to apply to catalog entities
 *
 * An undefined list of matchers means match all, an empty list of matchers means match none
 */
declare type CatalogRule = {
    allow: EntityMatcher[];
    locations?: LocationMatcher[];
};
declare class CatalogRulesEnforcer {
    private readonly rules;
    /**
     * Default rules used by the catalog.
     *
     * Denies any location from specifying user or group entities.
     */
    static readonly defaultRules: CatalogRule[];
    /**
     * Loads catalog rules from config.
     *
     * This reads `catalog.rules` and defaults to the default rules if no value is present.
     * The value of the config should be a list of config objects, each with a single `allow`
     * field which in turn is a list of entity kinds to allow.
     *
     * If there is no matching rule to allow an ingested entity, it will be rejected by the catalog.
     *
     * It also reads in rules from `catalog.locations`, where each location can have a list
     * of rules for that specific location, specified in a `rules` field.
     *
     * For example:
     *
     * ```yaml
     * catalog:
     *   rules:
     *   - allow: [Component, API]
     *
     *   locations:
     *   - type: url
     *     target: https://github.com/org/repo/blob/master/users.yaml
     *     rules:
     *       - allow: [User, Group]
     *   - type: url
     *     target: https://github.com/org/repo/blob/master/systems.yaml
     *     rules:
     *       - allow: [System]
     * ```
     */
    static fromConfig(config: Config): CatalogRulesEnforcer;
    constructor(rules: CatalogRule[]);
    /**
     * Checks wether a specific entity/location combination is allowed
     * according to the configured rules.
     */
    isAllowed(entity: Entity, location: LocationSpec): boolean;
    private matchLocation;
    private matchEntity;
}

declare type CatalogProcessor = {
    /**
     * Reads the contents of a location.
     *
     * @param location The location to read
     * @param optional Whether a missing target should trigger an error
     * @param emit A sink for items resulting from the read
     * @param parser A parser, that is able to take the raw catalog descriptor
     *               data and turn it into the actual result pieces.
     * @returns True if handled by this processor, false otherwise
     */
    readLocation?(location: LocationSpec, optional: boolean, emit: CatalogProcessorEmit, parser: CatalogProcessorParser): Promise<boolean>;
    /**
     * Pre-processes an emitted entity, after it has been emitted but before it
     * has been validated.
     *
     * This type of processing usually involves enriching the entity with
     * additional data, and the input entity may actually still be incomplete
     * when the processor is invoked.
     *
     * @param entity The (possibly partial) entity to process
     * @param location The location that the entity came from
     * @param emit A sink for auxiliary items resulting from the processing
     * @param originLocation The location that the entity originally came from.
     *   While location resolves to the direct parent location, originLocation
     *   tells which location was used to start the ingestion loop.
     * @returns The same entity or a modified version of it
     */
    preProcessEntity?(entity: Entity, location: LocationSpec, emit: CatalogProcessorEmit, originLocation: LocationSpec): Promise<Entity>;
    /**
     * Validates the entity as a known entity kind, after it has been pre-
     * processed and has passed through basic overall validation.
     *
     * @param entity The entity to validate
     * @returns Resolves to true, if the entity was of a kind that was known and
     *   handled by this processor, and was found to be valid. Resolves to false,
     *   if the entity was not of a kind that was known by this processor.
     *   Rejects to an Error describing the problem, if the entity was of a kind
     *   that was known by this processor and was not valid.
     */
    validateEntityKind?(entity: Entity): Promise<boolean>;
    /**
     * Post-processes an emitted entity, after it has been validated.
     *
     * @param entity The entity to process
     * @param location The location that the entity came from
     * @param emit A sink for auxiliary items resulting from the processing
     * @returns The same entity or a modified version of it
     */
    postProcessEntity?(entity: Entity, location: LocationSpec, emit: CatalogProcessorEmit): Promise<Entity>;
    /**
     * Handles an emitted error.
     *
     * @param error The error
     * @param location The location where the error occurred
     * @param emit A sink for items resulting from this handling
     * @returns Nothing
     */
    handleError?(error: Error, location: LocationSpec, emit: CatalogProcessorEmit): Promise<void>;
};
/**
 * A parser, that is able to take the raw catalog descriptor data and turn it
 * into the actual result pieces. The default implementation performs a YAML
 * document parsing.
 */
declare type CatalogProcessorParser = (options: {
    data: Buffer;
    location: LocationSpec;
}) => AsyncIterable<CatalogProcessorResult>;
declare type CatalogProcessorEmit = (generated: CatalogProcessorResult) => void;
declare type CatalogProcessorLocationResult = {
    type: 'location';
    location: LocationSpec;
    optional: boolean;
};
declare type CatalogProcessorEntityResult = {
    type: 'entity';
    entity: Entity;
    location: LocationSpec;
};
declare type CatalogProcessorRelationResult = {
    type: 'relation';
    relation: EntityRelationSpec;
    entityRef?: string;
};
declare type CatalogProcessorErrorResult = {
    type: 'error';
    error: Error;
    location: LocationSpec;
};
declare type CatalogProcessorResult = CatalogProcessorLocationResult | CatalogProcessorEntityResult | CatalogProcessorRelationResult | CatalogProcessorErrorResult;

declare type Options = {
    reader: UrlReader;
    parser: CatalogProcessorParser;
    logger: Logger;
    config: Config;
    processors: CatalogProcessor[];
    rulesEnforcer: CatalogRulesEnforcer;
    policy: EntityPolicy;
};
/**
 * Implements the reading of a location through a series of processor tasks.
 */
declare class LocationReaders implements LocationReader {
    private readonly options;
    constructor(options: Options);
    read(location: LocationSpec): Promise<ReadLocationResult>;
    private handleLocation;
    private handleEntity;
    private handleError;
}

declare function notFoundError(atLocation: LocationSpec, message: string): CatalogProcessorResult;
declare function inputError(atLocation: LocationSpec, message: string): CatalogProcessorResult;
declare function generalError(atLocation: LocationSpec, message: string): CatalogProcessorResult;
declare function location(newLocation: LocationSpec, optional: boolean): CatalogProcessorResult;
declare function entity(atLocation: LocationSpec, newEntity: Entity): CatalogProcessorResult;
declare function relation(spec: EntityRelationSpec): CatalogProcessorResult;

declare const results_d_notFoundError: typeof notFoundError;
declare const results_d_inputError: typeof inputError;
declare const results_d_generalError: typeof generalError;
declare const results_d_location: typeof location;
declare const results_d_entity: typeof entity;
declare const results_d_relation: typeof relation;
declare namespace results_d {
  export {
    results_d_notFoundError as notFoundError,
    results_d_inputError as inputError,
    results_d_generalError as generalError,
    results_d_location as location,
    results_d_entity as entity,
    results_d_relation as relation,
  };
}

declare type Options$1 = {
    integrations: ScmIntegrationRegistry;
};
declare class AnnotateLocationEntityProcessor implements CatalogProcessor {
    private readonly options;
    constructor(options: Options$1);
    preProcessEntity(entity: Entity, location: LocationSpec, _: CatalogProcessorEmit, originLocation: LocationSpec): Promise<Entity>;
}

declare class AnnotateScmSlugEntityProcessor implements CatalogProcessor {
    private readonly opts;
    constructor(opts: {
        scmIntegrationRegistry: ScmIntegrationRegistry;
    });
    static fromConfig(config: Config): AnnotateScmSlugEntityProcessor;
    preProcessEntity(entity: Entity, location: LocationSpec): Promise<Entity>;
}

/**
 * The configuration parameters for a single AWS Organization Processor
 */
declare type AwsOrganizationProviderConfig = {
    /**
     * The role to assume for the processor.
     */
    roleArn?: string;
};

/**
 * A processor for ingesting AWS Accounts from AWS Organizations.
 *
 * If custom authentication is needed, it can be achieved by configuring the global AWS.credentials object.
 */
declare class AwsOrganizationCloudAccountProcessor implements CatalogProcessor {
    logger: Logger;
    organizations: Organizations;
    provider: AwsOrganizationProviderConfig;
    static fromConfig(config: Config, options: {
        logger: Logger;
    }): AwsOrganizationCloudAccountProcessor;
    private static buildCredentials;
    constructor(options: {
        provider: AwsOrganizationProviderConfig;
        logger: Logger;
    });
    normalizeName(name: string): string;
    extractInformationFromArn(arn: string): {
        accountId: string;
        organizationId: string;
    };
    getAwsAccounts(): Promise<Account[]>;
    mapAccountToComponent(account: Account): ResourceEntityV1alpha1;
    readLocation(location: LocationSpec, _optional: boolean, emit: CatalogProcessorEmit): Promise<boolean>;
}

declare type BitbucketRepositoryParser = (options: {
    integration: BitbucketIntegration;
    target: string;
    logger: Logger;
}) => AsyncIterable<CatalogProcessorResult>;

declare class BitbucketDiscoveryProcessor implements CatalogProcessor {
    private readonly integrations;
    private readonly parser;
    private readonly logger;
    static fromConfig(config: Config, options: {
        parser?: BitbucketRepositoryParser;
        logger: Logger;
    }): BitbucketDiscoveryProcessor;
    constructor(options: {
        integrations: ScmIntegrationRegistry;
        parser?: BitbucketRepositoryParser;
        logger: Logger;
    });
    readLocation(location: LocationSpec, _optional: boolean, emit: CatalogProcessorEmit): Promise<boolean>;
}

declare class BuiltinKindsEntityProcessor implements CatalogProcessor {
    private readonly validators;
    validateEntityKind(entity: Entity): Promise<boolean>;
    postProcessEntity(entity: Entity, _location: LocationSpec, emit: CatalogProcessorEmit): Promise<Entity>;
}

declare class CodeOwnersProcessor implements CatalogProcessor {
    private readonly integrations;
    private readonly logger;
    private readonly reader;
    static fromConfig(config: Config, options: {
        logger: Logger;
        reader: UrlReader;
    }): CodeOwnersProcessor;
    constructor(options: {
        integrations: ScmIntegrations;
        logger: Logger;
        reader: UrlReader;
    });
    preProcessEntity(entity: Entity, location: LocationSpec): Promise<Entity>;
}

declare class FileReaderProcessor implements CatalogProcessor {
    readLocation(location: LocationSpec, optional: boolean, emit: CatalogProcessorEmit): Promise<boolean>;
}

/**
 * Extracts repositories out of a GitHub org.
 */
declare class GithubDiscoveryProcessor implements CatalogProcessor {
    private readonly integrations;
    private readonly logger;
    static fromConfig(config: Config, options: {
        logger: Logger;
    }): GithubDiscoveryProcessor;
    constructor(options: {
        integrations: ScmIntegrations;
        logger: Logger;
    });
    readLocation(location: LocationSpec, _optional: boolean, emit: CatalogProcessorEmit): Promise<boolean>;
}

/**
 * Extracts teams and users out of a GitHub org.
 */
declare class GithubOrgReaderProcessor implements CatalogProcessor {
    private readonly integrations;
    private readonly logger;
    static fromConfig(config: Config, options: {
        logger: Logger;
    }): GithubOrgReaderProcessor;
    constructor(options: {
        integrations: ScmIntegrations;
        logger: Logger;
    });
    readLocation(location: LocationSpec, _optional: boolean, emit: CatalogProcessorEmit): Promise<boolean>;
    private createClient;
}

/**
 * The configuration parameters for a single LDAP provider.
 */
declare type LdapProviderConfig = {
    target: string;
    bind?: BindConfig;
    users: UserConfig;
    groups: GroupConfig;
};
/**
 * The settings to use for the a command.
 */
declare type BindConfig = {
    dn: string;
    secret: string;
};
/**
 * The settings that govern the reading and interpretation of users.
 */
declare type UserConfig = {
    dn: string;
    options: SearchOptions;
    set?: {
        [path: string]: JsonValue;
    };
    map: {
        rdn: string;
        name: string;
        description?: string;
        displayName: string;
        email: string;
        picture?: string;
        memberOf: string;
    };
};
/**
 * The settings that govern the reading and interpretation of groups.
 */
declare type GroupConfig = {
    dn: string;
    options: SearchOptions;
    set?: {
        [path: string]: JsonValue;
    };
    map: {
        rdn: string;
        name: string;
        description: string;
        type: string;
        displayName: string;
        email?: string;
        picture?: string;
        memberOf: string;
        members: string;
    };
};

/**
 * Extracts teams and users out of an LDAP server.
 */
declare class LdapOrgReaderProcessor implements CatalogProcessor {
    private readonly providers;
    private readonly logger;
    static fromConfig(config: Config, options: {
        logger: Logger;
    }): LdapOrgReaderProcessor;
    constructor(options: {
        providers: LdapProviderConfig[];
        logger: Logger;
    });
    readLocation(location: LocationSpec, _optional: boolean, emit: CatalogProcessorEmit): Promise<boolean>;
}

declare type Options$2 = {
    integrations: ScmIntegrationRegistry;
};
declare class LocationEntityProcessor implements CatalogProcessor {
    private readonly options;
    constructor(options: Options$2);
    postProcessEntity(entity: Entity, location: LocationSpec, emit: CatalogProcessorEmit): Promise<Entity>;
}

/**
 * The configuration parameters for a single Microsoft Graph provider.
 */
declare type MicrosoftGraphProviderConfig = {
    /**
     * The prefix of the target that this matches on, e.g.
     * "https://graph.microsoft.com/v1.0", with no trailing slash.
     */
    target: string;
    /**
     * The auth authority used.
     *
     * E.g. "https://login.microsoftonline.com"
     */
    authority?: string;
    /**
     * The tenant whose org data we are interested in.
     */
    tenantId: string;
    /**
     * The OAuth client ID to use for authenticating requests.
     */
    clientId: string;
    /**
     * The OAuth client secret to use for authenticating requests.
     *
     * @visibility secret
     */
    clientSecret: string;
    /**
     * The filter to apply to extract users.
     *
     * E.g. "accountEnabled eq true and userType eq 'member'"
     */
    userFilter?: string;
    /**
     * The filter to apply to extract groups.
     *
     * E.g. "securityEnabled eq false and mailEnabled eq true"
     */
    groupFilter?: string;
};

/**
 * Extracts teams and users out of an LDAP server.
 */
declare class MicrosoftGraphOrgReaderProcessor implements CatalogProcessor {
    private readonly providers;
    private readonly logger;
    static fromConfig(config: Config, options: {
        logger: Logger;
    }): MicrosoftGraphOrgReaderProcessor;
    constructor(options: {
        providers: MicrosoftGraphProviderConfig[];
        logger: Logger;
    });
    readLocation(location: LocationSpec, _optional: boolean, emit: CatalogProcessorEmit): Promise<boolean>;
}

declare type ResolverRead = (url: string) => Promise<Buffer>;
declare type ResolverParams = {
    key: string;
    value: JsonValue;
    baseUrl: string;
    read: ResolverRead;
};
declare type PlaceholderResolver = (params: ResolverParams) => Promise<JsonValue>;
declare type Options$3 = {
    resolvers: Record<string, PlaceholderResolver>;
    reader: UrlReader;
};
/**
 * Traverses raw entity JSON looking for occurrences of $-prefixed placeholders
 * that it then fills in with actual data.
 */
declare class PlaceholderProcessor implements CatalogProcessor {
    private readonly options;
    constructor(options: Options$3);
    preProcessEntity(entity: Entity, location: LocationSpec): Promise<Entity>;
}

declare class StaticLocationProcessor implements StaticLocationProcessor {
    private readonly staticLocations;
    static fromConfig(config: Config): StaticLocationProcessor;
    constructor(staticLocations: LocationSpec[]);
    readLocation(location: LocationSpec, _optional: boolean, emit: CatalogProcessorEmit): Promise<boolean>;
}

declare type Options$4 = {
    reader: UrlReader;
    logger: Logger;
};
declare class UrlReaderProcessor implements CatalogProcessor {
    private readonly options;
    constructor(options: Options$4);
    readLocation(location: LocationSpec, optional: boolean, emit: CatalogProcessorEmit, parser: CatalogProcessorParser): Promise<boolean>;
    private doRead;
}

declare function parseEntityYaml(data: Buffer, location: LocationSpec): Iterable<CatalogProcessorResult>;

interface CatalogEntityDocument extends IndexableDocument {
    componentType: string;
    namespace: string;
    kind: string;
    lifecycle: string;
    owner: string;
}
declare class DefaultCatalogCollator implements DocumentCollator {
    protected discovery: PluginEndpointDiscovery;
    protected locationTemplate: string;
    constructor({ discovery, locationTemplate, }: {
        discovery: PluginEndpointDiscovery;
        locationTemplate?: string;
    });
    protected applyArgsToFormat(format: string, args: Record<string, string>): string;
    execute(): Promise<CatalogEntityDocument[]>;
}

declare type CatalogEnvironment = {
    logger: Logger;
    database: PluginDatabaseManager;
    config: Config;
    reader: UrlReader;
};
/**
 * A builder that helps wire up all of the component parts of the catalog.
 *
 * The touch points where you can replace or extend behavior are as follows:
 *
 * - Entity policies can be added or replaced. These are automatically run
 *   after the processors' pre-processing steps. All policies are given the
 *   chance to inspect the entity, and all of them have to pass in order for
 *   the entity to be considered valid from an overall point of view.
 * - Placeholder resolvers can be replaced or added. These run on the raw
 *   structured data between the parsing and pre-processing steps, to replace
 *   dollar-prefixed entries with their actual values (like $file).
 * - Field format validators can be replaced. These check the format of
 *   individual core fields such as metadata.name, to ensure that they adhere
 *   to certain rules.
 * - Processors can be added or replaced. These implement the functionality of
 *   reading, parsing, validating, and processing the entity data before it is
 *   persisted in the catalog.
 */
declare class CatalogBuilder {
    private readonly env;
    private entityPolicies;
    private entityPoliciesReplace;
    private placeholderResolvers;
    private fieldFormatValidators;
    private processors;
    private processorsReplace;
    private parser;
    constructor(env: CatalogEnvironment);
    /**
     * Adds policies that are used to validate entities between the pre-
     * processing and post-processing stages. All such policies must pass for the
     * entity to be considered valid.
     *
     * If what you want to do is to replace the rules for what format is allowed
     * in various core entity fields (such as metadata.name), you may want to use
     * {@link CatalogBuilder#setFieldFormatValidators} instead.
     *
     * @param policies One or more policies
     */
    addEntityPolicy(...policies: EntityPolicy[]): CatalogBuilder;
    /**
     * Sets what policies to use for validation of entities between the pre-
     * processing and post-processing stages. All such policies must pass for the
     * entity to be considered valid.
     *
     * If what you want to do is to replace the rules for what format is allowed
     * in various core entity fields (such as metadata.name), you may want to use
     * {@link CatalogBuilder#setFieldFormatValidators} instead.
     *
     * This function replaces the default set of policies; use with care.
     *
     * @param policies One or more policies
     */
    replaceEntityPolicies(policies: EntityPolicy[]): CatalogBuilder;
    /**
     * Adds, or overwrites, a handler for placeholders (e.g. $file) in entity
     * definition files.
     *
     * @param key The key that identifies the placeholder, e.g. "file"
     * @param resolver The resolver that gets values for this placeholder
     */
    setPlaceholderResolver(key: string, resolver: PlaceholderResolver): CatalogBuilder;
    /**
     * Sets the validator function to use for one or more special fields of an
     * entity. This is useful if the default rules for formatting of fields are
     * not sufficient.
     *
     * This function has no effect if used together with
     * {@link CatalogBuilder#replaceEntityPolicies}.
     *
     * @param validators The (subset of) validators to set
     */
    setFieldFormatValidators(validators: Partial<Validators>): CatalogBuilder;
    /**
     * Adds entity processors. These are responsible for reading, parsing, and
     * processing entities before they are persisted in the catalog.
     *
     * @param processors One or more processors
     */
    addProcessor(...processors: CatalogProcessor[]): CatalogBuilder;
    /**
     * Sets what entity processors to use. These are responsible for reading,
     * parsing, and processing entities before they are persisted in the catalog.
     *
     * This function replaces the default set of processors; use with care.
     *
     * @param processors One or more processors
     */
    replaceProcessors(processors: CatalogProcessor[]): CatalogBuilder;
    /**
     * Sets up the catalog to use a custom parser for entity data.
     *
     * This is the function that gets called immediately after some raw entity
     * specification data has been read from a remote source, and needs to be
     * parsed and emitted as structured data.
     *
     * @param parser The custom parser
     */
    setEntityDataParser(parser: CatalogProcessorParser): CatalogBuilder;
    /**
     * Wires up and returns all of the component parts of the catalog
     */
    build(): Promise<{
        entitiesCatalog: EntitiesCatalog;
        locationsCatalog: LocationsCatalog;
        higherOrderOperation: HigherOrderOperation;
        locationAnalyzer: LocationAnalyzer;
    }>;
    private buildEntityPolicy;
    private buildProcessors;
    private checkDeprecatedReaderProcessors;
}

interface RouterOptions {
    entitiesCatalog?: EntitiesCatalog;
    locationsCatalog?: LocationsCatalog;
    higherOrderOperation?: HigherOrderOperation;
    locationAnalyzer?: LocationAnalyzer;
    logger: Logger;
    config: Config;
}
declare function createRouter(options: RouterOptions): Promise<express.Router>;

/**
 * Runs a function repeatedly, with a fixed wait between invocations.
 *
 * Supports async functions, and silently ignores exceptions and rejections.
 *
 * @param fn The function to run. May return a Promise.
 * @param delayMs The delay between a completed function invocation and the
 *                next.
 * @returns A function that, when called, stops the invocation loop.
 */
declare function runPeriodically(fn: () => any, delayMs: number): () => void;

/**
 * Returns a string with the elapsed time since the start of an operation,
 * with some human friendly precision, e.g. "133ms" or "14.5s".
 *
 * @param startTimestamp The timestamp (from process.hrtime()) at the start ot
 *                       the operation
 */
declare function durationText(startTimestamp: [number, number]): string;

interface LocationService {
    createLocation(spec: LocationSpec, dryRun: boolean): Promise<{
        location: Location;
        entities: Entity[];
    }>;
    listLocations(): Promise<Location[]>;
    getLocation(id: string): Promise<Location>;
    deleteLocation(id: string): Promise<void>;
}
interface CatalogProcessingEngine {
    start(): Promise<void>;
    stop(): Promise<void>;
}

declare type CatalogEnvironment$1 = {
    logger: Logger;
    database: PluginDatabaseManager;
    config: Config;
    reader: UrlReader;
};
/**
 * A builder that helps wire up all of the component parts of the catalog.
 *
 * The touch points where you can replace or extend behavior are as follows:
 *
 * - Entity policies can be added or replaced. These are automatically run
 *   after the processors' pre-processing steps. All policies are given the
 *   chance to inspect the entity, and all of them have to pass in order for
 *   the entity to be considered valid from an overall point of view.
 * - Placeholder resolvers can be replaced or added. These run on the raw
 *   structured data between the parsing and pre-processing steps, to replace
 *   dollar-prefixed entries with their actual values (like $file).
 * - Field format validators can be replaced. These check the format of
 *   individual core fields such as metadata.name, to ensure that they adhere
 *   to certain rules.
 * - Processors can be added or replaced. These implement the functionality of
 *   reading, parsing, validating, and processing the entity data before it is
 *   persisted in the catalog.
 */
declare class NextCatalogBuilder {
    private readonly env;
    private entityPolicies;
    private entityPoliciesReplace;
    private placeholderResolvers;
    private fieldFormatValidators;
    private processors;
    private processorsReplace;
    private parser;
    constructor(env: CatalogEnvironment$1);
    /**
     * Adds policies that are used to validate entities between the pre-
     * processing and post-processing stages. All such policies must pass for the
     * entity to be considered valid.
     *
     * If what you want to do is to replace the rules for what format is allowed
     * in various core entity fields (such as metadata.name), you may want to use
     * {@link NextCatalogBuilder#setFieldFormatValidators} instead.
     *
     * @param policies One or more policies
     */
    addEntityPolicy(...policies: EntityPolicy[]): NextCatalogBuilder;
    /**
     * Sets what policies to use for validation of entities between the pre-
     * processing and post-processing stages. All such policies must pass for the
     * entity to be considered valid.
     *
     * If what you want to do is to replace the rules for what format is allowed
     * in various core entity fields (such as metadata.name), you may want to use
     * {@link NextCatalogBuilder#setFieldFormatValidators} instead.
     *
     * This function replaces the default set of policies; use with care.
     *
     * @param policies One or more policies
     */
    replaceEntityPolicies(policies: EntityPolicy[]): NextCatalogBuilder;
    /**
     * Adds, or overwrites, a handler for placeholders (e.g. $file) in entity
     * definition files.
     *
     * @param key The key that identifies the placeholder, e.g. "file"
     * @param resolver The resolver that gets values for this placeholder
     */
    setPlaceholderResolver(key: string, resolver: PlaceholderResolver): NextCatalogBuilder;
    /**
     * Sets the validator function to use for one or more special fields of an
     * entity. This is useful if the default rules for formatting of fields are
     * not sufficient.
     *
     * This function has no effect if used together with
     * {@link NextCatalogBuilder#replaceEntityPolicies}.
     *
     * @param validators The (subset of) validators to set
     */
    setFieldFormatValidators(validators: Partial<Validators>): NextCatalogBuilder;
    /**
     * Adds entity processors. These are responsible for reading, parsing, and
     * processing entities before they are persisted in the catalog.
     *
     * @param processors One or more processors
     */
    addProcessor(...processors: CatalogProcessor[]): NextCatalogBuilder;
    /**
     * Sets what entity processors to use. These are responsible for reading,
     * parsing, and processing entities before they are persisted in the catalog.
     *
     * This function replaces the default set of processors; use with care.
     *
     * @param processors One or more processors
     */
    replaceProcessors(processors: CatalogProcessor[]): NextCatalogBuilder;
    /**
     * Sets up the catalog to use a custom parser for entity data.
     *
     * This is the function that gets called immediately after some raw entity
     * specification data has been read from a remote source, and needs to be
     * parsed and emitted as structured data.
     *
     * @param parser The custom parser
     */
    setEntityDataParser(parser: CatalogProcessorParser): NextCatalogBuilder;
    /**
     * Wires up and returns all of the component parts of the catalog
     */
    build(): Promise<{
        entitiesCatalog: EntitiesCatalog;
        locationsCatalog: LocationsCatalog;
        locationAnalyzer: LocationAnalyzer;
        processingEngine: CatalogProcessingEngine;
        locationService: LocationService;
    }>;
    private buildEntityPolicy;
    private buildProcessors;
    private checkDeprecatedReaderProcessors;
}

interface RouterOptions$1 {
    entitiesCatalog?: EntitiesCatalog;
    locationAnalyzer?: LocationAnalyzer;
    locationService: LocationService;
    logger: Logger;
    config: Config;
}
declare function createNextRouter(options: RouterOptions$1): Promise<express.Router>;

export { AddLocationResult, AnalyzeLocationRequest, AnalyzeLocationResponse, AnnotateLocationEntityProcessor, AnnotateScmSlugEntityProcessor, AwsOrganizationCloudAccountProcessor, BitbucketDiscoveryProcessor, BitbucketRepositoryParser, BuiltinKindsEntityProcessor, CatalogBuilder, CatalogEntityDocument, CatalogProcessor, CatalogProcessorEmit, CatalogProcessorEntityResult, CatalogProcessorErrorResult, CatalogProcessorLocationResult, CatalogProcessorParser, CatalogProcessorRelationResult, CatalogProcessorResult, CodeOwnersProcessor, CommonDatabase, Database, DatabaseEntitiesCatalog, DatabaseLocationsCatalog, DatabaseManager, DbEntityRequest, DbEntityResponse, DefaultCatalogCollator, EntitiesCatalog, EntitiesSearchFilter, EntityFilter, EntityPagination, FileReaderProcessor, GithubDiscoveryProcessor, GithubOrgReaderProcessor, HigherOrderOperation, HigherOrderOperations, LdapOrgReaderProcessor, LocationAnalyzer, LocationEntityProcessor, LocationReader, LocationReaders, LocationsCatalog, MicrosoftGraphOrgReaderProcessor, NextCatalogBuilder, PlaceholderProcessor, PlaceholderResolver, ReadLocationEntity, ReadLocationError, ReadLocationResult, RecursivePartial, RouterOptions, StaticLocationProcessor, Transaction, UrlReaderProcessor, createNextRouter, createRouter, durationText, parseEntityYaml, results_d as results, runPeriodically };
