import { createApiRef, createRouteRef, createPlugin, createApiFactory, configApiRef, discoveryApiRef, identityApiRef, createRoutableExtension, createComponentExtension, useApi, ErrorPage, Progress, Table, EmptyState, Button, SubvalueCell, Link, ItemCardGrid, ItemCardHeader, Page, Header, Content, WarningPanel, CodeSnippet, HeaderTabs, ContentHeader, SupportButton, useRouteRef, HeaderLabel, MissingAnnotationEmptyState } from '@backstage/core';
import { NotFoundError } from '@backstage/errors';
import { scmIntegrationsApiRef } from '@backstage/integration-react';
import { Typography, useTheme, Tooltip, IconButton, Card, CardMedia, CardContent, CardActions, makeStyles } from '@material-ui/core';
import { Alert } from '@material-ui/lab';
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { useParams, useNavigate, generatePath, Routes, Route } from 'react-router-dom';
import { useMountedState, useAsyncRetry, useAsync, useCopyToClipboard } from 'react-use';
import FeedbackOutlinedIcon from '@material-ui/icons/FeedbackOutlined';
import ReactDOM from 'react-dom';
import sanitizeHtml from 'sanitize-html';
import { catalogApiRef, isOwnerOf, getEntityRelations, EntityRefLink, EntityRefLinks, useEntity } from '@backstage/plugin-catalog-react';
import ShareIcon from '@material-ui/icons/Share';
import { RELATION_OWNED_BY } from '@backstage/catalog-model';
import CodeIcon from '@material-ui/icons/Code';

const techdocsStorageApiRef = createApiRef({
  id: "plugin.techdocs.storageservice",
  description: "Used to make requests towards the techdocs storage"
});
const techdocsApiRef = createApiRef({
  id: "plugin.techdocs.service",
  description: "Used to make requests towards techdocs API"
});

class TechDocsClient {
  constructor({
    configApi,
    discoveryApi,
    identityApi
  }) {
    this.configApi = configApi;
    this.discoveryApi = discoveryApi;
    this.identityApi = identityApi;
  }
  async getApiOrigin() {
    var _a;
    return (_a = this.configApi.getOptionalString("techdocs.requestUrl")) != null ? _a : await this.discoveryApi.getBaseUrl("techdocs");
  }
  async getTechDocsMetadata(entityId) {
    const {kind, namespace, name} = entityId;
    const apiOrigin = await this.getApiOrigin();
    const requestUrl = `${apiOrigin}/metadata/techdocs/${namespace}/${kind}/${name}`;
    const token = await this.identityApi.getIdToken();
    const request = await fetch(`${requestUrl}`, {
      headers: token ? {Authorization: `Bearer ${token}`} : {}
    });
    const res = await request.json();
    return res;
  }
  async getEntityMetadata(entityId) {
    const {kind, namespace, name} = entityId;
    const apiOrigin = await this.getApiOrigin();
    const requestUrl = `${apiOrigin}/metadata/entity/${namespace}/${kind}/${name}`;
    const token = await this.identityApi.getIdToken();
    const request = await fetch(`${requestUrl}`, {
      headers: token ? {Authorization: `Bearer ${token}`} : {}
    });
    const res = await request.json();
    return res;
  }
}
class TechDocsStorageClient {
  constructor({
    configApi,
    discoveryApi,
    identityApi
  }) {
    this.configApi = configApi;
    this.discoveryApi = discoveryApi;
    this.identityApi = identityApi;
  }
  async getApiOrigin() {
    var _a;
    return (_a = this.configApi.getOptionalString("techdocs.requestUrl")) != null ? _a : await this.discoveryApi.getBaseUrl("techdocs");
  }
  async getStorageUrl() {
    var _a;
    return (_a = this.configApi.getOptionalString("techdocs.storageUrl")) != null ? _a : `${await this.discoveryApi.getBaseUrl("techdocs")}/static/docs`;
  }
  async getBuilder() {
    return this.configApi.getString("techdocs.builder");
  }
  async getEntityDocs(entityId, path) {
    const {kind, namespace, name} = entityId;
    const storageUrl = await this.getStorageUrl();
    const url = `${storageUrl}/${namespace}/${kind}/${name}/${path}`;
    const token = await this.identityApi.getIdToken();
    const request = await fetch(`${url.endsWith("/") ? url : `${url}/`}index.html`, {
      headers: token ? {Authorization: `Bearer ${token}`} : {}
    });
    let errorMessage = "";
    switch (request.status) {
      case 404:
        errorMessage = "Page not found. ";
        if (!path) {
          errorMessage += "This could be because there is no index.md file in the root of the docs directory of this repository.";
        }
        throw new NotFoundError(errorMessage);
      case 500:
        errorMessage = "Could not generate documentation or an error in the TechDocs backend. ";
        throw new Error(errorMessage);
    }
    return request.text();
  }
  async syncEntityDocs(entityId) {
    const {kind, namespace, name} = entityId;
    const apiOrigin = await this.getApiOrigin();
    const url = `${apiOrigin}/sync/${namespace}/${kind}/${name}`;
    const token = await this.identityApi.getIdToken();
    let request;
    let attempts = 0;
    while (!request || request.status === 408 && attempts < 5) {
      attempts++;
      request = await fetch(url, {
        headers: token ? {Authorization: `Bearer ${token}`} : {}
      });
    }
    switch (request.status) {
      case 404:
        throw new NotFoundError((await request.json()).error);
      case 200:
      case 201:
      case 304:
        return true;
      case 408:
      default:
        return false;
    }
  }
  async getBaseUrl(oldBaseUrl, entityId, path) {
    const {kind, namespace, name} = entityId;
    const apiOrigin = await this.getApiOrigin();
    return new URL(oldBaseUrl, `${apiOrigin}/static/docs/${namespace}/${kind}/${name}/${path}`).toString();
  }
}

const rootRouteRef = createRouteRef({
  path: "",
  title: "TechDocs Landing Page"
});
const rootDocsRouteRef = createRouteRef({
  path: ":namespace/:kind/:name/*",
  title: "Docs"
});
const rootCatalogDocsRouteRef = createRouteRef({
  path: "*",
  title: "Docs"
});

const techdocsPlugin = createPlugin({
  id: "techdocs",
  apis: [
    createApiFactory({
      api: techdocsStorageApiRef,
      deps: {
        configApi: configApiRef,
        discoveryApi: discoveryApiRef,
        identityApi: identityApiRef
      },
      factory: ({configApi, discoveryApi, identityApi}) => new TechDocsStorageClient({
        configApi,
        discoveryApi,
        identityApi
      })
    }),
    createApiFactory({
      api: techdocsApiRef,
      deps: {
        configApi: configApiRef,
        discoveryApi: discoveryApiRef,
        identityApi: identityApiRef
      },
      factory: ({configApi, discoveryApi, identityApi}) => new TechDocsClient({
        configApi,
        discoveryApi,
        identityApi
      })
    })
  ],
  routes: {
    root: rootRouteRef,
    entityContent: rootCatalogDocsRouteRef
  }
});
const TechdocsPage = techdocsPlugin.provide(createRoutableExtension({
  component: () => Promise.resolve().then(function () { return Router$1; }).then((m) => m.Router),
  mountPoint: rootRouteRef
}));
const EntityTechdocsContent = techdocsPlugin.provide(createRoutableExtension({
  component: () => Promise.resolve().then(function () { return Router$1; }).then((m) => m.EmbeddedDocsRouter),
  mountPoint: rootCatalogDocsRouteRef
}));
const DocsCardGrid = techdocsPlugin.provide(createComponentExtension({
  component: {
    lazy: () => Promise.resolve().then(function () { return DocsCardGrid$2; }).then((m) => m.DocsCardGrid)
  }
}));
const DocsTable = techdocsPlugin.provide(createComponentExtension({
  component: {
    lazy: () => Promise.resolve().then(function () { return DocsTable$2; }).then((m) => m.DocsTable)
  }
}));
const TechDocsCustomHome = techdocsPlugin.provide(createRoutableExtension({
  component: () => Promise.resolve().then(function () { return TechDocsCustomHome$2; }).then((m) => m.TechDocsCustomHome),
  mountPoint: rootRouteRef
}));
const TechDocsReaderPage = techdocsPlugin.provide(createRoutableExtension({
  component: () => Promise.resolve().then(function () { return TechDocsPage$1; }).then((m) => m.TechDocsPage),
  mountPoint: rootDocsRouteRef
}));

const addBaseUrl = ({
  techdocsStorageApi,
  entityId,
  path
}) => {
  return (dom) => {
    const updateDom = (list, attributeName) => {
      Array.from(list).filter((elem) => !!elem.getAttribute(attributeName)).forEach(async (elem) => {
        const elemAttribute = elem.getAttribute(attributeName);
        if (!elemAttribute)
          return;
        const newValue = await techdocsStorageApi.getBaseUrl(elemAttribute, entityId, path);
        if (attributeName === "src" && elemAttribute.endsWith(".svg")) {
          try {
            const svg = await fetch(newValue);
            const svgContent = await svg.text();
            elem.setAttribute(attributeName, `data:image/svg+xml;base64,${btoa(svgContent)}`);
          } catch (e) {
            elem.setAttribute("alt", `Error: ${elemAttribute}`);
          }
        } else {
          elem.setAttribute(attributeName, newValue);
        }
      });
    };
    updateDom(dom.querySelectorAll("img"), "src");
    updateDom(dom.querySelectorAll("script"), "src");
    updateDom(dom.querySelectorAll("link"), "href");
    updateDom(dom.querySelectorAll("a[download]"), "href");
    return dom;
  };
};

const addGitFeedbackLink = (scmIntegrationsApi) => {
  return (dom) => {
    const sourceAnchor = dom.querySelector('[title="Edit this page"]');
    if (!sourceAnchor || !sourceAnchor.href) {
      return dom;
    }
    const sourceURL = new URL(sourceAnchor.href);
    const integration = scmIntegrationsApi.byUrl(sourceURL);
    if ((integration == null ? void 0 : integration.type) !== "github" && (integration == null ? void 0 : integration.type) !== "gitlab") {
      return dom;
    }
    const title = dom.querySelector("article>h1").childNodes[0].textContent;
    const issueTitle = encodeURIComponent(`Documentation Feedback: ${title}`);
    const issueDesc = encodeURIComponent(`Page source:
${sourceAnchor.href}

Feedback:`);
    const repoPath = sourceURL.pathname.split("/").slice(0, 3).join("/");
    const feedbackLink = sourceAnchor.cloneNode();
    switch (integration == null ? void 0 : integration.type) {
      case "gitlab":
        feedbackLink.href = `${sourceURL.origin}${repoPath}/issues/new?issue[title]=${issueTitle}&issue[description]=${issueDesc}`;
        break;
      case "github":
        feedbackLink.href = `${sourceURL.origin}${repoPath}/issues/new?title=${issueTitle}&body=${issueDesc}`;
        break;
      default:
        return dom;
    }
    ReactDOM.render(React.createElement(FeedbackOutlinedIcon), feedbackLink);
    feedbackLink.style.paddingLeft = "5px";
    feedbackLink.title = "Leave feedback for this page";
    feedbackLink.id = "git-feedback-link";
    sourceAnchor == null ? void 0 : sourceAnchor.insertAdjacentElement("beforebegin", feedbackLink);
    return dom;
  };
};

const rewriteDocLinks = () => {
  return (dom) => {
    const updateDom = (list, attributeName) => {
      Array.from(list).filter((elem) => elem.hasAttribute(attributeName)).forEach((elem) => {
        const elemAttribute = elem.getAttribute(attributeName);
        if (elemAttribute) {
          if (elemAttribute.match(/^https?:\/\//i)) {
            elem.setAttribute("target", "_blank");
          }
          try {
            const normalizedWindowLocation = normalizeUrl(window.location.href);
            elem.setAttribute(attributeName, new URL(elemAttribute, normalizedWindowLocation).toString());
          } catch (_e) {
            elem.replaceWith(elem.textContent || elemAttribute);
          }
        }
      });
    };
    updateDom(Array.from(dom.getElementsByTagName("a")), "href");
    return dom;
  };
};
function normalizeUrl(input) {
  const url = new URL(input);
  if (!url.pathname.endsWith("/")) {
    url.pathname += "/";
  }
  return url.toString();
}

const addLinkClickListener = ({
  baseUrl,
  onClick
}) => {
  return (dom) => {
    Array.from(dom.getElementsByTagName("a")).forEach((elem) => {
      elem.addEventListener("click", (e) => {
        const target = elem;
        const href = target.getAttribute("href");
        if (!href)
          return;
        if (href.startsWith(baseUrl)) {
          e.preventDefault();
          onClick(e, href);
        }
      });
    });
    return dom;
  };
};

const removeMkdocsHeader = () => {
  return (dom) => {
    var _a;
    (_a = dom.querySelector(".md-header")) == null ? void 0 : _a.remove();
    return dom;
  };
};

const simplifyMkdocsFooter = () => {
  return (dom) => {
    var _a;
    (_a = dom.querySelector(".md-footer-copyright")) == null ? void 0 : _a.remove();
    return dom;
  };
};

const onCssReady = ({
  docStorageUrl,
  onLoading,
  onLoaded
}) => {
  return (dom) => {
    const cssPages = Array.from(dom.querySelectorAll('head > link[rel="stylesheet"]')).filter(async (elem) => {
      var _a;
      return (_a = elem.getAttribute("href")) == null ? void 0 : _a.startsWith(await docStorageUrl);
    });
    let count = cssPages.length;
    if (count > 0) {
      onLoading(dom);
    }
    cssPages.forEach((cssPage) => cssPage.addEventListener("load", () => {
      count -= 1;
      if (count === 0) {
        onLoaded(dom);
      }
    }));
    return dom;
  };
};

const html = [
  "a",
  "abbr",
  "acronym",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "bdi",
  "bdo",
  "big",
  "blink",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "center",
  "cite",
  "code",
  "col",
  "colgroup",
  "content",
  "data",
  "datalist",
  "dd",
  "decorator",
  "del",
  "details",
  "dfn",
  "dir",
  "div",
  "dl",
  "dt",
  "element",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "font",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meter",
  "nav",
  "nobr",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "section",
  "select",
  "shadow",
  "small",
  "source",
  "spacer",
  "span",
  "strike",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "track",
  "tt",
  "u",
  "ul",
  "var",
  "video",
  "wbr"
];
const svg = [
  "svg",
  "a",
  "altglyph",
  "altglyphdef",
  "altglyphitem",
  "animatecolor",
  "animatemotion",
  "animatetransform",
  "audio",
  "canvas",
  "circle",
  "clippath",
  "defs",
  "desc",
  "ellipse",
  "filter",
  "font",
  "g",
  "glyph",
  "glyphref",
  "hkern",
  "image",
  "line",
  "lineargradient",
  "marker",
  "mask",
  "metadata",
  "mpath",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialgradient",
  "rect",
  "stop",
  "switch",
  "symbol",
  "text",
  "textpath",
  "title",
  "tref",
  "tspan",
  "video",
  "view",
  "vkern"
];
const svgFilters = [
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence"
];
const mathMl = [
  "math",
  "menclose",
  "merror",
  "mfenced",
  "mfrac",
  "mglyph",
  "mi",
  "mlabeledtr",
  "mmultiscripts",
  "mn",
  "mo",
  "mover",
  "mpadded",
  "mphantom",
  "mroot",
  "mrow",
  "ms",
  "mspace",
  "msqrt",
  "mstyle",
  "msub",
  "msup",
  "msubsup",
  "mtable",
  "mtd",
  "mtext",
  "mtr",
  "munder",
  "munderover"
];
const text = ["#text"];
const TECHDOCS_ALLOWED_TAGS = [
  ...html,
  ...svg,
  ...svgFilters,
  ...mathMl,
  ...text,
  "iframe"
];

const html$1 = [
  "accept",
  "action",
  "align",
  "alt",
  "autocapitalize",
  "autocomplete",
  "autopictureinpicture",
  "autoplay",
  "background",
  "bgcolor",
  "border",
  "capture",
  "cellpadding",
  "cellspacing",
  "checked",
  "cite",
  "class",
  "clear",
  "color",
  "cols",
  "colspan",
  "controls",
  "controlslist",
  "coords",
  "crossorigin",
  "datetime",
  "decoding",
  "default",
  "dir",
  "disabled",
  "disablepictureinpicture",
  "disableremoteplayback",
  "download",
  "draggable",
  "enctype",
  "enterkeyhint",
  "face",
  "for",
  "headers",
  "height",
  "hidden",
  "high",
  "href",
  "hreflang",
  "id",
  "inputmode",
  "integrity",
  "ismap",
  "kind",
  "label",
  "lang",
  "list",
  "loading",
  "loop",
  "low",
  "max",
  "maxlength",
  "media",
  "method",
  "min",
  "minlength",
  "multiple",
  "muted",
  "name",
  "noshade",
  "novalidate",
  "nowrap",
  "open",
  "optimum",
  "pattern",
  "placeholder",
  "playsinline",
  "poster",
  "preload",
  "pubdate",
  "radiogroup",
  "readonly",
  "rel",
  "required",
  "rev",
  "reversed",
  "role",
  "rows",
  "rowspan",
  "spellcheck",
  "scope",
  "selected",
  "shape",
  "size",
  "sizes",
  "span",
  "srclang",
  "start",
  "src",
  "srcset",
  "step",
  "style",
  "summary",
  "tabindex",
  "title",
  "translate",
  "type",
  "usemap",
  "valign",
  "value",
  "width",
  "xmlns"
];
const svg$1 = [
  "accent-height",
  "accumulate",
  "additive",
  "alignment-baseline",
  "ascent",
  "attributename",
  "attributetype",
  "azimuth",
  "basefrequency",
  "baseline-shift",
  "begin",
  "bias",
  "by",
  "class",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "cx",
  "cy",
  "d",
  "dx",
  "dy",
  "data",
  "diffuseconstant",
  "direction",
  "display",
  "divisor",
  "dur",
  "edgemode",
  "elevation",
  "end",
  "fill",
  "fill-opacity",
  "fill-rule",
  "filter",
  "filterunits",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "fx",
  "fy",
  "g1",
  "g2",
  "glyph-name",
  "glyphref",
  "gradientunits",
  "gradienttransform",
  "height",
  "href",
  "id",
  "image-rendering",
  "in",
  "in2",
  "k",
  "k1",
  "k2",
  "k3",
  "k4",
  "kerning",
  "keypoints",
  "keysplines",
  "keytimes",
  "lang",
  "lengthadjust",
  "letter-spacing",
  "kernelmatrix",
  "kernelunitlength",
  "lighting-color",
  "local",
  "marker-end",
  "marker-mid",
  "marker-start",
  "markerheight",
  "markerunits",
  "markerwidth",
  "maskcontentunits",
  "maskunits",
  "max",
  "mask",
  "media",
  "method",
  "mode",
  "min",
  "name",
  "numoctaves",
  "offset",
  "operator",
  "opacity",
  "order",
  "orient",
  "orientation",
  "origin",
  "overflow",
  "paint-order",
  "path",
  "pathlength",
  "patterncontentunits",
  "patterntransform",
  "patternunits",
  "points",
  "preservealpha",
  "preserveaspectratio",
  "primitiveunits",
  "r",
  "rx",
  "ry",
  "radius",
  "refx",
  "refy",
  "repeatcount",
  "repeatdur",
  "restart",
  "result",
  "rotate",
  "scale",
  "seed",
  "shape-rendering",
  "specularconstant",
  "specularexponent",
  "spreadmethod",
  "startoffset",
  "stddeviation",
  "stitchtiles",
  "stop-color",
  "stop-opacity",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke",
  "stroke-width",
  "style",
  "surfacescale",
  "tabindex",
  "targetx",
  "targety",
  "transform",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "textlength",
  "type",
  "u1",
  "u2",
  "unicode",
  "values",
  "viewbox",
  "visibility",
  "version",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "width",
  "word-spacing",
  "wrap",
  "writing-mode",
  "xchannelselector",
  "ychannelselector",
  "x",
  "x1",
  "x2",
  "xmlns",
  "y",
  "y1",
  "y2",
  "z",
  "zoomandpan"
];
const mathMl$1 = [
  "accent",
  "accentunder",
  "align",
  "bevelled",
  "close",
  "columnsalign",
  "columnlines",
  "columnspan",
  "denomalign",
  "depth",
  "dir",
  "display",
  "displaystyle",
  "encoding",
  "fence",
  "frame",
  "height",
  "href",
  "id",
  "largeop",
  "length",
  "linethickness",
  "lspace",
  "lquote",
  "mathbackground",
  "mathcolor",
  "mathsize",
  "mathvariant",
  "maxsize",
  "minsize",
  "movablelimits",
  "notation",
  "numalign",
  "open",
  "rowalign",
  "rowlines",
  "rowspacing",
  "rowspan",
  "rspace",
  "rquote",
  "scriptlevel",
  "scriptminsize",
  "scriptsizemultiplier",
  "selection",
  "separator",
  "separators",
  "stretchy",
  "subscriptshift",
  "supscriptshift",
  "symmetric",
  "voffset",
  "width",
  "xmlns"
];
const xml = [
  "xlink:href",
  "xml:id",
  "xlink:title",
  "xml:space",
  "xmlns:xlink"
];
const TECHDOCS_ALLOWED_ATTRIBUTES = {
  "*": [...html$1, ...svg$1, ...mathMl$1, ...xml, "data-*"]
};

const sanitizeDOM = () => {
  return (dom) => {
    const sanitizedHtml = sanitizeHtml(dom.innerHTML, {
      allowedTags: TECHDOCS_ALLOWED_TAGS,
      allowedAttributes: TECHDOCS_ALLOWED_ATTRIBUTES,
      allowedSchemes: ["http", "https", "ftp", "mailto", "data", "blob"]
    });
    return new DOMParser().parseFromString(sanitizedHtml, "text/html").documentElement;
  };
};

const injectCss = ({css}) => {
  return (dom) => {
    dom.getElementsByTagName("head")[0].insertAdjacentHTML("beforeend", `<style>${css}</style>`);
    return dom;
  };
};

const transform = (html, transformers) => {
  let dom;
  if (typeof html === "string") {
    dom = new DOMParser().parseFromString(html, "text/html").documentElement;
  } else if (html instanceof Element) {
    dom = html;
  } else {
    throw new Error("dom is not a recognized type");
  }
  transformers.forEach((transformer) => {
    dom = transformer(dom);
  });
  return dom;
};

const TechDocsNotFound = ({errorMessage}) => {
  const techdocsBuilder = useApi(configApiRef).getOptionalString("techdocs.builder");
  let additionalInfo = "";
  if (techdocsBuilder !== "local") {
    additionalInfo = "Note that techdocs.builder is not set to 'local' in your config, which means this Backstage app will not generate docs if they are not found. Make sure the project's docs are generated and published by some external process (e.g. CI/CD pipeline). Or change techdocs.builder to 'local' to generate docs from this Backstage instance.";
  }
  return /* @__PURE__ */ React.createElement(ErrorPage, {
    status: "404",
    statusMessage: errorMessage || "Documentation not found",
    additionalInfo
  });
};

const TechDocsProgressBar = () => {
  const isMounted = useMountedState();
  const [hasBeenDelayed, setHasBeenDelayed] = useState(false);
  const delayReason = `Docs are still loading...Backstage takes some extra time to load docs
  for the first time. The subsequent loads are much faster.`;
  const allowedDelayTime = 5e3;
  useEffect(() => {
    setTimeout(() => {
      if (isMounted()) {
        setHasBeenDelayed(true);
      }
    }, allowedDelayTime);
  });
  return /* @__PURE__ */ React.createElement(React.Fragment, null, hasBeenDelayed ? /* @__PURE__ */ React.createElement(Typography, {
    "data-testid": "delay-reason"
  }, delayReason) : null, /* @__PURE__ */ React.createElement(Progress, null));
};

function useRawPage(path, kind, namespace, name) {
  const techdocsStorageApi = useApi(techdocsStorageApiRef);
  return useAsyncRetry(async () => {
    const content = await techdocsStorageApi.getEntityDocs({kind, namespace, name}, path);
    return {
      content,
      path,
      entityId: {
        kind,
        name,
        namespace
      }
    };
  }, [techdocsStorageApi, kind, namespace, name, path]);
}

const Reader = ({entityId, onReady}) => {
  const {kind, namespace, name} = entityId;
  const {"*": path} = useParams();
  const theme = useTheme();
  const techdocsStorageApi = useApi(techdocsStorageApiRef);
  const [sidebars, setSidebars] = useState();
  const navigate = useNavigate();
  const shadowDomRef = useRef(null);
  const [loadedPath, setLoadedPath] = useState("");
  const [atInitialLoad, setAtInitialLoad] = useState(true);
  const [newerDocsExist, setNewerDocsExist] = useState(false);
  const scmIntegrationsApi = useApi(scmIntegrationsApiRef);
  const {
    value: isSynced,
    loading: syncInProgress,
    error: syncError
  } = useAsync(async () => {
    if (await techdocsStorageApi.getBuilder() !== "local") {
      return Promise.resolve({
        value: true,
        loading: null,
        error: null
      });
    }
    return techdocsStorageApi.syncEntityDocs({kind, namespace, name});
  }, [techdocsStorageApi, kind, namespace, name]);
  const {
    value: rawPage,
    loading: docLoading,
    error: docLoadError,
    retry
  } = useRawPage(path, kind, namespace, name);
  useEffect(() => {
    if (isSynced && newerDocsExist && path !== loadedPath) {
      retry();
    }
  });
  useEffect(() => {
    const updateSidebarPosition = () => {
      if (!!shadowDomRef.current && !!sidebars) {
        const mdTabs = shadowDomRef.current.querySelector(".md-container > .md-tabs");
        sidebars.forEach((sidebar) => {
          const newTop = Math.max(shadowDomRef.current.getBoundingClientRect().top, 0);
          sidebar.style.top = mdTabs ? `${newTop + mdTabs.getBoundingClientRect().height}px` : `${newTop}px`;
        });
      }
    };
    updateSidebarPosition();
    window.addEventListener("scroll", updateSidebarPosition);
    window.addEventListener("resize", updateSidebarPosition);
    return () => {
      window.removeEventListener("scroll", updateSidebarPosition);
      window.removeEventListener("resize", updateSidebarPosition);
    };
  }, [shadowDomRef, sidebars]);
  useEffect(() => {
    if (rawPage) {
      setLoadedPath(path);
    }
  }, [rawPage, path]);
  useEffect(() => {
    if (atInitialLoad === false) {
      return;
    }
    setTimeout(() => {
      setAtInitialLoad(false);
    }, 5e3);
  });
  useEffect(() => {
    if (!atInitialLoad && !!rawPage && syncInProgress) {
      setNewerDocsExist(true);
    }
  }, [atInitialLoad, rawPage, syncInProgress]);
  useEffect(() => {
    if (!rawPage || !shadowDomRef.current) {
      return;
    }
    if (onReady) {
      onReady();
    }
    const transformedElement = transform(rawPage.content, [
      sanitizeDOM(),
      addBaseUrl({
        techdocsStorageApi,
        entityId: rawPage.entityId,
        path: rawPage.path
      }),
      rewriteDocLinks(),
      removeMkdocsHeader(),
      simplifyMkdocsFooter(),
      addGitFeedbackLink(scmIntegrationsApi),
      injectCss({
        css: `
        body {
          font-family: ${theme.typography.fontFamily};
          --md-text-color: ${theme.palette.text.primary};
          --md-text-link-color: ${theme.palette.primary.main};

          --md-code-fg-color: ${theme.palette.text.primary};
          --md-code-bg-color: ${theme.palette.background.paper};
        }
        .md-main__inner { margin-top: 0; }
        .md-sidebar {  position: fixed; bottom: 100px; width: 20rem; }
        .md-sidebar--secondary { right: 2rem; }
        .md-content { margin-bottom: 50px }
        .md-footer { position: fixed; bottom: 0px; width: 100vw; }
        .md-footer-nav__link { width: 20rem;}
        .md-content { margin-left: 20rem; max-width: calc(100% - 20rem * 2 - 3rem); }
        .md-typeset { font-size: 1rem; }
        .md-nav { font-size: 1rem; }
        .md-grid { max-width: 90vw; margin: 0 }
        .md-typeset table:not([class]) {
          font-size: 1rem;
          border: 1px solid ${theme.palette.text.primary};
          border-bottom: none;
          border-collapse: collapse;
        }
        .md-typeset table:not([class]) td, .md-typeset table:not([class]) th {
          border-bottom: 1px solid ${theme.palette.text.primary};
        }
        .md-typeset table:not([class]) th { font-weight: bold; }
        .md-typeset .admonition, .md-typeset details {
          font-size: 1rem;
        }
        @media screen and (max-width: 76.1875em) {
          .md-nav {
            background-color: ${theme.palette.background.default};
            transition: none !important
          }
          .md-sidebar--secondary { display: none; }
          .md-sidebar--primary { left: 72px; width: 10rem }
          .md-content { margin-left: 10rem; max-width: calc(100% - 10rem); }
          .md-content__inner { font-size: 0.9rem }
          .md-footer {
            position: static;
            margin-left: 10rem;
            width: calc(100% - 10rem);
          }
          .md-nav--primary .md-nav__title {
            white-space: normal;
            height: auto;
            line-height: 1rem;
            cursor: auto;
          }
          .md-nav--primary > .md-nav__title [for="none"] {
            padding-top: 0;
          }
        }
      `
      }),
      injectCss({
        css: `
        .md-nav__link, .md-typeset a, .md-typeset a::before, .md-typeset .headerlink {
          transition: none;
        }
        `
      }),
      injectCss({
        css: `
        :host {
          --md-admonition-icon--note: url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>');
          --md-admonition-icon--abstract: url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 5h16v2H4V5m0 4h16v2H4V9m0 4h16v2H4v-2m0 4h10v2H4v-2z"/></svg>');
          --md-admonition-icon--info: url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 9h-2V7h2m0 10h-2v-6h2m-1-9A10 10 0 002 12a10 10 0 0010 10 10 10 0 0010-10A10 10 0 0012 2z"/></svg>');
          --md-admonition-icon--tip: url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17.55 11.2c-.23-.3-.5-.56-.76-.82-.65-.6-1.4-1.03-2.03-1.66C13.3 7.26 13 4.85 13.91 3c-.91.23-1.75.75-2.45 1.32-2.54 2.08-3.54 5.75-2.34 8.9.04.1.08.2.08.33 0 .22-.15.42-.35.5-.22.1-.46.04-.64-.12a.83.83 0 01-.15-.17c-1.1-1.43-1.28-3.48-.53-5.12C5.89 10 5 12.3 5.14 14.47c.04.5.1 1 .27 1.5.14.6.4 1.2.72 1.73 1.04 1.73 2.87 2.97 4.84 3.22 2.1.27 4.35-.12 5.96-1.6 1.8-1.66 2.45-4.32 1.5-6.6l-.13-.26c-.2-.46-.47-.87-.8-1.25l.05-.01m-3.1 6.3c-.28.24-.73.5-1.08.6-1.1.4-2.2-.16-2.87-.82 1.19-.28 1.89-1.16 2.09-2.05.17-.8-.14-1.46-.27-2.23-.12-.74-.1-1.37.18-2.06.17.38.37.76.6 1.06.76 1 1.95 1.44 2.2 2.8.04.14.06.28.06.43.03.82-.32 1.72-.92 2.27h.01z"/></svg>');
          --md-admonition-icon--success: url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2m-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>');
          --md-admonition-icon--question: url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M15.07 11.25l-.9.92C13.45 12.89 13 13.5 13 15h-2v-.5c0-1.11.45-2.11 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41a2 2 0 00-2-2 2 2 0 00-2 2H8a4 4 0 014-4 4 4 0 014 4 3.2 3.2 0 01-.93 2.25M13 19h-2v-2h2M12 2A10 10 0 002 12a10 10 0 0010 10 10 10 0 0010-10c0-5.53-4.5-10-10-10z"/></svg>');
          --md-admonition-icon--warning: url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 14h-2v-4h2m0 8h-2v-2h2M1 21h22L12 2 1 21z"/></svg>');
          --md-admonition-icon--failure: url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2c5.53 0 10 4.47 10 10s-4.47 10-10 10S2 17.53 2 12 6.47 2 12 2m3.59 5L12 10.59 8.41 7 7 8.41 10.59 12 7 15.59 8.41 17 12 13.41 15.59 17 17 15.59 13.41 12 17 8.41 15.59 7z"/></svg>');
          --md-admonition-icon--danger: url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11.5 20l4.86-9.73H13V4l-5 9.73h3.5V20M12 2c2.75 0 5.1 1 7.05 2.95C21 6.9 22 9.25 22 12s-1 5.1-2.95 7.05C17.1 21 14.75 22 12 22s-5.1-1-7.05-2.95C3 17.1 2 14.75 2 12s1-5.1 2.95-7.05C6.9 3 9.25 2 12 2z"/></svg>');
          --md-admonition-icon--bug: url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14 12h-4v-2h4m0 6h-4v-2h4m6-6h-2.81a5.985 5.985 0 00-1.82-1.96L17 4.41 15.59 3l-2.17 2.17a6.002 6.002 0 00-2.83 0L8.41 3 7 4.41l1.62 1.63C7.88 6.55 7.26 7.22 6.81 8H4v2h2.09c-.05.33-.09.66-.09 1v1H4v2h2v1c0 .34.04.67.09 1H4v2h2.81c1.04 1.79 2.97 3 5.19 3s4.15-1.21 5.19-3H20v-2h-2.09c.05-.33.09-.66.09-1v-1h2v-2h-2v-1c0-.34-.04-.67-.09-1H20V8z"/></svg>');
          --md-admonition-icon--example: url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M7 13v-2h14v2H7m0 6v-2h14v2H7M7 7V5h14v2H7M3 8V5H2V4h2v4H3m-1 9v-1h3v4H2v-1h2v-.5H3v-1h1V17H2m2.25-7a.75.75 0 01.75.75c0 .2-.08.39-.21.52L3.12 13H5v1H2v-.92L4 11H2v-1h2.25z"/></svg>');
          --md-admonition-icon--quote: url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14 17h3l2-4V7h-6v6h3M6 17h3l2-4V7H5v6h3l-2 4z"/></svg>');
        }
        :host {
          --md-footnotes-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 7v4H5.83l3.58-3.59L8 6l-6 6 6 6 1.41-1.42L5.83 13H21V7h-2z"/></svg>');
        }
        :host {
          --md-details-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>');
        }
        :host {
          --md-tasklist-icon: url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2A10 10 0 002 12a10 10 0 0010 10 10 10 0 0010-10A10 10 0 0012 2z"/></svg>');
          --md-tasklist-icon--checked: url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2m-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>');
        }
        `
      })
    ]);
    if (!transformedElement) {
      return;
    }
    const shadowDiv = shadowDomRef.current;
    const shadowRoot = shadowDiv.shadowRoot || shadowDiv.attachShadow({mode: "open"});
    Array.from(shadowRoot.children).forEach((child) => shadowRoot.removeChild(child));
    shadowRoot.appendChild(transformedElement);
    window.scroll({top: 0});
    transform(shadowRoot.children[0], [
      (dom) => {
        setTimeout(() => {
          var _a;
          if (window.location.hash) {
            const hash = window.location.hash.slice(1);
            (_a = shadowRoot == null ? void 0 : shadowRoot.getElementById(hash)) == null ? void 0 : _a.scrollIntoView();
          }
        }, 200);
        return dom;
      },
      addLinkClickListener({
        baseUrl: window.location.origin,
        onClick: (_, url) => {
          var _a;
          const parsedUrl = new URL(url);
          if (newerDocsExist && isSynced) {
            setNewerDocsExist(false);
          }
          if (parsedUrl.hash) {
            navigate(`${parsedUrl.pathname}${parsedUrl.hash}`);
            (_a = shadowRoot == null ? void 0 : shadowRoot.getElementById(parsedUrl.hash.slice(1))) == null ? void 0 : _a.scrollIntoView();
          } else {
            navigate(parsedUrl.pathname);
          }
        }
      }),
      onCssReady({
        docStorageUrl: techdocsStorageApi.getApiOrigin(),
        onLoading: (dom) => {
          dom.style.setProperty("opacity", "0");
        },
        onLoaded: (dom) => {
          var _a;
          dom.style.removeProperty("opacity");
          (_a = dom.querySelector(".md-nav__title")) == null ? void 0 : _a.removeAttribute("for");
          const sideDivs = Array.from(shadowRoot.querySelectorAll(".md-sidebar"));
          setSidebars(sideDivs);
          const docTopPosition = dom.getBoundingClientRect().top;
          const mdTabs = dom.querySelector(".md-container > .md-tabs");
          sideDivs.forEach((sidebar) => {
            sidebar.style.top = mdTabs ? `${docTopPosition + mdTabs.getBoundingClientRect().height}px` : `${docTopPosition}px`;
          });
        }
      })
    ]);
  }, [
    rawPage,
    navigate,
    onReady,
    shadowDomRef,
    techdocsStorageApi,
    theme.typography.fontFamily,
    theme.palette.text.primary,
    theme.palette.primary.main,
    theme.palette.background.paper,
    theme.palette.background.default,
    newerDocsExist,
    isSynced,
    scmIntegrationsApi
  ]);
  if (docLoadError && !syncInProgress && !docLoading || syncError) {
    let errMessage = "";
    if (docLoadError) {
      errMessage += ` Load error: ${docLoadError}`;
    }
    if (syncError)
      errMessage += ` Build error: ${syncError}`;
    return /* @__PURE__ */ React.createElement(TechDocsNotFound, {
      errorMessage: errMessage
    });
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, newerDocsExist && !isSynced ? /* @__PURE__ */ React.createElement(Alert, {
    variant: "outlined",
    severity: "info"
  }, "A newer version of this documentation is being prepared and will be available shortly.") : null, newerDocsExist && isSynced ? /* @__PURE__ */ React.createElement(Alert, {
    variant: "outlined",
    severity: "success"
  }, "A newer version of this documentation is now available, please refresh to view.") : null, docLoading || docLoadError && syncInProgress ? /* @__PURE__ */ React.createElement(TechDocsProgressBar, null) : null, /* @__PURE__ */ React.createElement("div", {
    "data-testid": "techdocs-content-shadowroot",
    ref: shadowDomRef
  }));
};

function useOwnUser() {
  const catalogApi = useApi(catalogApiRef);
  const identityApi = useApi(identityApiRef);
  return useAsync(() => catalogApi.getEntityByName({
    kind: "User",
    namespace: "default",
    name: identityApi.getUserId()
  }), [catalogApi, identityApi]);
}

const DocsTable$1 = ({
  entities,
  title
}) => {
  const [, copyToClipboard] = useCopyToClipboard();
  if (!entities)
    return null;
  const documents = entities.map((entity) => {
    var _a, _b, _c;
    return {
      name: entity.metadata.name,
      description: entity.metadata.description,
      owner: (_a = entity == null ? void 0 : entity.spec) == null ? void 0 : _a.owner,
      type: (_b = entity == null ? void 0 : entity.spec) == null ? void 0 : _b.type,
      docsUrl: generatePath(rootDocsRouteRef.path, {
        namespace: (_c = entity.metadata.namespace) != null ? _c : "default",
        kind: entity.kind,
        name: entity.metadata.name
      })
    };
  });
  const columns = [
    {
      title: "Document",
      field: "name",
      highlight: true,
      render: (row) => /* @__PURE__ */ React.createElement(SubvalueCell, {
        value: /* @__PURE__ */ React.createElement(Link, {
          to: row.docsUrl
        }, row.name),
        subvalue: row.description
      })
    },
    {
      title: "Owner",
      field: "owner"
    },
    {
      title: "Type",
      field: "type"
    },
    {
      title: "Actions",
      width: "10%",
      render: (row) => /* @__PURE__ */ React.createElement(Tooltip, {
        title: "Click to copy documentation link to clipboard"
      }, /* @__PURE__ */ React.createElement(IconButton, {
        onClick: () => copyToClipboard(`${window.location.href}/${row.docsUrl}`)
      }, /* @__PURE__ */ React.createElement(ShareIcon, null)))
    }
  ];
  return /* @__PURE__ */ React.createElement(React.Fragment, null, documents && documents.length > 0 ? /* @__PURE__ */ React.createElement(Table, {
    options: {
      paging: true,
      pageSize: 20,
      search: true
    },
    data: documents,
    columns,
    title: title ? `${title} (${documents.length})` : `All (${documents.length})`
  }) : /* @__PURE__ */ React.createElement(EmptyState, {
    missing: "data",
    title: "No documents to show",
    description: "Create your own document. Check out our Getting Started Information",
    action: /* @__PURE__ */ React.createElement(Button, {
      color: "primary",
      href: "#",
      to: "https://backstage.io/docs/features/techdocs/getting-started",
      variant: "contained"
    }, "DOCS")
  }));
};

var DocsTable$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  DocsTable: DocsTable$1
});

const DocsCardGrid$1 = ({
  entities
}) => {
  if (!entities)
    return null;
  return /* @__PURE__ */ React.createElement(ItemCardGrid, {
    "data-testid": "docs-explore"
  }, !(entities == null ? void 0 : entities.length) ? null : entities.map((entity, index) => {
    var _a;
    return /* @__PURE__ */ React.createElement(Card, {
      key: index
    }, /* @__PURE__ */ React.createElement(CardMedia, null, /* @__PURE__ */ React.createElement(ItemCardHeader, {
      title: entity.metadata.name
    })), /* @__PURE__ */ React.createElement(CardContent, null, entity.metadata.description), /* @__PURE__ */ React.createElement(CardActions, null, /* @__PURE__ */ React.createElement(Button, {
      to: generatePath(rootDocsRouteRef.path, {
        namespace: (_a = entity.metadata.namespace) != null ? _a : "default",
        kind: entity.kind,
        name: entity.metadata.name
      }),
      color: "primary"
    }, "Read Docs")));
  }));
};

var DocsCardGrid$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  DocsCardGrid: DocsCardGrid$1
});

const panels = {
  DocsTable: DocsTable$1,
  DocsCardGrid: DocsCardGrid$1
};
const CustomPanel = ({
  config,
  entities,
  index
}) => {
  const useStyles = makeStyles({
    panelContainer: {
      marginBottom: "2rem",
      ...config.panelCSS ? config.panelCSS : {}
    }
  });
  const classes = useStyles();
  const Panel = panels[config.panelType];
  const shownEntities = entities.filter(config.filterPredicate);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(ContentHeader, {
    title: config.title,
    description: config.description
  }, index === 0 ? /* @__PURE__ */ React.createElement(SupportButton, null, "Discover documentation in your ecosystem.") : null), /* @__PURE__ */ React.createElement("div", {
    className: classes.panelContainer
  }, /* @__PURE__ */ React.createElement(Panel, {
    entities: shownEntities
  })));
};
const TechDocsCustomHome$1 = ({
  tabsConfig
}) => {
  var _a;
  const [selectedTab, setSelectedTab] = useState(0);
  const catalogApi = useApi(catalogApiRef);
  const configApi = useApi(configApiRef);
  const {value: entities, loading, error} = useAsync(async () => {
    const response = await catalogApi.getEntities();
    return response.items.filter((entity) => {
      var _a2;
      return !!((_a2 = entity.metadata.annotations) == null ? void 0 : _a2["backstage.io/techdocs-ref"]);
    });
  });
  const generatedSubtitle = `Documentation available in ${(_a = configApi.getOptionalString("organization.name")) != null ? _a : "Backstage"}`;
  const currentTabConfig = tabsConfig[selectedTab];
  if (loading) {
    return /* @__PURE__ */ React.createElement(Page, {
      themeId: "documentation"
    }, /* @__PURE__ */ React.createElement(Header, {
      title: "Documentation",
      subtitle: generatedSubtitle
    }), /* @__PURE__ */ React.createElement(Content, null, /* @__PURE__ */ React.createElement(Progress, null)));
  }
  if (error) {
    return /* @__PURE__ */ React.createElement(Page, {
      themeId: "documentation"
    }, /* @__PURE__ */ React.createElement(Header, {
      title: "Documentation",
      subtitle: generatedSubtitle
    }), /* @__PURE__ */ React.createElement(Content, null, /* @__PURE__ */ React.createElement(WarningPanel, {
      severity: "error",
      title: "Could not load available documentation."
    }, /* @__PURE__ */ React.createElement(CodeSnippet, {
      language: "text",
      text: error.toString()
    }))));
  }
  return /* @__PURE__ */ React.createElement(Page, {
    themeId: "documentation"
  }, /* @__PURE__ */ React.createElement(Header, {
    title: "Documentation",
    subtitle: generatedSubtitle
  }), /* @__PURE__ */ React.createElement(HeaderTabs, {
    selectedIndex: selectedTab,
    onChange: (index) => setSelectedTab(index),
    tabs: tabsConfig.map(({label}, index) => ({
      id: index.toString(),
      label
    }))
  }), /* @__PURE__ */ React.createElement(Content, null, currentTabConfig.panels.map((config, index) => /* @__PURE__ */ React.createElement(CustomPanel, {
    key: index,
    config,
    entities: !!entities ? entities : [],
    index
  }))));
};

var TechDocsCustomHome$2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  TechDocsCustomHome: TechDocsCustomHome$1
});

const TechDocsHome = () => {
  const {value: user} = useOwnUser();
  const tabsConfig = [
    {
      label: "Overview",
      panels: [
        {
          title: "Overview",
          description: "Explore your internal technical ecosystem through documentation.",
          panelType: "DocsCardGrid",
          filterPredicate: () => true
        }
      ]
    },
    {
      label: "Owned Documents",
      panels: [
        {
          title: "Owned documents",
          description: "Access your documentation.",
          panelType: "DocsTable",
          filterPredicate: (entity) => {
            if (!user) {
              return false;
            }
            return isOwnerOf(user, entity);
          }
        }
      ]
    }
  ];
  return /* @__PURE__ */ React.createElement(TechDocsCustomHome$1, {
    tabsConfig
  });
};

const TechDocsPageHeader = ({
  entityId,
  metadataRequest
}) => {
  const {
    techdocs: techdocsMetadata,
    entity: entityMetadata
  } = metadataRequest;
  const {value: techdocsMetadataValues} = techdocsMetadata;
  const {value: entityMetadataValues} = entityMetadata;
  const {name} = entityId;
  const {site_name: siteName, site_description: siteDescription} = techdocsMetadataValues || {};
  const {
    locationMetadata,
    spec: {lifecycle}
  } = entityMetadataValues || {spec: {}};
  const ownedByRelations = entityMetadataValues ? getEntityRelations(entityMetadataValues, RELATION_OWNED_BY) : [];
  const docsRootLink = useRouteRef(rootRouteRef)();
  const labels = /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(HeaderLabel, {
    label: "Component",
    value: /* @__PURE__ */ React.createElement(EntityRefLink, {
      color: "inherit",
      entityRef: entityId,
      defaultKind: "Component"
    })
  }), ownedByRelations.length > 0 && /* @__PURE__ */ React.createElement(HeaderLabel, {
    label: "Owner",
    value: /* @__PURE__ */ React.createElement(EntityRefLinks, {
      color: "inherit",
      entityRefs: ownedByRelations,
      defaultKind: "group"
    })
  }), lifecycle ? /* @__PURE__ */ React.createElement(HeaderLabel, {
    label: "Lifecycle",
    value: lifecycle
  }) : null, locationMetadata && locationMetadata.type !== "dir" && locationMetadata.type !== "file" ? /* @__PURE__ */ React.createElement(HeaderLabel, {
    label: "",
    value: /* @__PURE__ */ React.createElement("a", {
      href: locationMetadata.target,
      target: "_blank",
      rel: "noopener noreferrer"
    }, /* @__PURE__ */ React.createElement(CodeIcon, {
      style: {marginTop: "-25px", fill: "#fff"}
    }))
  }) : null);
  return /* @__PURE__ */ React.createElement(Header, {
    title: siteName ? siteName : ".",
    pageTitleOverride: siteName || name,
    subtitle: siteDescription && siteDescription !== "None" ? siteDescription : "",
    type: "Docs",
    typeLink: docsRootLink
  }, labels);
};

const TechDocsPage = () => {
  const [documentReady, setDocumentReady] = useState(false);
  const {namespace, kind, name} = useParams();
  const techdocsApi = useApi(techdocsApiRef);
  const techdocsMetadataRequest = useAsync(() => {
    if (documentReady) {
      return techdocsApi.getTechDocsMetadata({kind, namespace, name});
    }
    return Promise.resolve(void 0);
  }, [kind, namespace, name, techdocsApi, documentReady]);
  const entityMetadataRequest = useAsync(() => {
    return techdocsApi.getEntityMetadata({kind, namespace, name});
  }, [kind, namespace, name, techdocsApi]);
  const onReady = useCallback(() => {
    setDocumentReady(true);
  }, [setDocumentReady]);
  return /* @__PURE__ */ React.createElement(Page, {
    themeId: "documentation"
  }, /* @__PURE__ */ React.createElement(TechDocsPageHeader, {
    metadataRequest: {
      techdocs: techdocsMetadataRequest,
      entity: entityMetadataRequest
    },
    entityId: {
      kind,
      namespace,
      name
    }
  }), /* @__PURE__ */ React.createElement(Content, {
    "data-testid": "techdocs-content"
  }, /* @__PURE__ */ React.createElement(Reader, {
    onReady,
    entityId: {
      kind,
      namespace,
      name
    }
  })));
};

var TechDocsPage$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  TechDocsPage: TechDocsPage
});

const EntityPageDocs = ({entity}) => {
  var _a;
  return /* @__PURE__ */ React.createElement(Reader, {
    entityId: {
      kind: entity.kind,
      namespace: (_a = entity.metadata.namespace) != null ? _a : "default",
      name: entity.metadata.name
    }
  });
};

const TECHDOCS_ANNOTATION = "backstage.io/techdocs-ref";
const Router = () => {
  return /* @__PURE__ */ React.createElement(Routes, null, /* @__PURE__ */ React.createElement(Route, {
    path: `/${rootRouteRef.path}`,
    element: /* @__PURE__ */ React.createElement(TechDocsHome, null)
  }), /* @__PURE__ */ React.createElement(Route, {
    path: `/${rootDocsRouteRef.path}`,
    element: /* @__PURE__ */ React.createElement(TechDocsPage, null)
  }));
};
const EmbeddedDocsRouter = (_props) => {
  var _a;
  const {entity} = useEntity();
  const projectId = (_a = entity.metadata.annotations) == null ? void 0 : _a[TECHDOCS_ANNOTATION];
  if (!projectId) {
    return /* @__PURE__ */ React.createElement(MissingAnnotationEmptyState, {
      annotation: TECHDOCS_ANNOTATION
    });
  }
  return /* @__PURE__ */ React.createElement(Routes, null, /* @__PURE__ */ React.createElement(Route, {
    path: `/${rootCatalogDocsRouteRef.path}`,
    element: /* @__PURE__ */ React.createElement(EntityPageDocs, {
      entity
    })
  }));
};

var Router$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Router: Router,
  EmbeddedDocsRouter: EmbeddedDocsRouter
});

export { DocsCardGrid, DocsTable, EmbeddedDocsRouter, EntityTechdocsContent, Reader, Router, TechDocsClient, TechDocsCustomHome, TechDocsReaderPage, TechDocsStorageClient, TechdocsPage, techdocsPlugin as plugin, techdocsApiRef, techdocsPlugin, techdocsStorageApiRef };
//# sourceMappingURL=index.esm.js.map
