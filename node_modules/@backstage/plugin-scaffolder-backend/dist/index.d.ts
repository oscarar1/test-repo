/// <reference types="node" />
import { ScmIntegrations, ScmIntegrationRegistry, AzureIntegrationConfig, BitbucketIntegrationConfig, GitHubIntegrationConfig, GithubCredentialsProvider, GitLabIntegrationConfig } from '@backstage/integration';
import { CatalogApi } from '@backstage/catalog-client';
import { UrlReader, ContainerRunner, PluginDatabaseManager } from '@backstage/backend-common';
import gitUrlParse from 'git-url-parse';
import { Writable } from 'stream';
import { TemplateEntityV1alpha1, TemplateEntityV1beta2 } from '@backstage/catalog-model';
import { createPullRequest } from 'octokit-plugin-create-pull-request';
import { Logger } from 'winston';
import { Config, JsonValue, JsonObject } from '@backstage/config';
import { Gitlab } from '@gitbeaker/core';
import { Schema } from 'jsonschema';
import express from 'express';

declare function createCatalogRegisterAction(options: {
    catalogClient: CatalogApi;
    integrations: ScmIntegrations;
}): TemplateAction<any>;

declare function createFetchPlainAction(options: {
    reader: UrlReader;
    integrations: ScmIntegrations;
}): TemplateAction<any>;

/**
 * Currently the required template values. The owner
 * and where to store the result from templating
 */
declare type RequiredTemplateValues = {
    owner: string;
    storePath: string;
    destination?: {
        git?: gitUrlParse.GitUrl;
    };
};
declare type TemplaterValues = RequiredTemplateValues & Record<string, any>;
/**
 * The returned directory from the templater which is ready
 * to pass to the next stage of the scaffolder which is publishing
 */
declare type TemplaterRunResult = {
    resultDir: string;
};
/**
 * The values that the templater will receive. The directory of the
 * skeleton, with the values from the frontend. A dedicated log stream and a docker
 * client to run any templater on top of your directory.
 */
declare type TemplaterRunOptions = {
    workspacePath: string;
    values: TemplaterValues;
    logStream?: Writable;
};
declare type TemplaterBase = {
    run(opts: TemplaterRunOptions): Promise<void>;
};
declare type TemplaterConfig = {
    templater?: TemplaterBase;
};
/**
 * List of supported templating options
 */
declare type SupportedTemplatingKey = 'cookiecutter' | string;
/**
 * The templater builder holds the templaters ready for run time
 */
declare type TemplaterBuilder = {
    register(protocol: SupportedTemplatingKey, templater: TemplaterBase): void;
    get(templater: string): TemplaterBase;
};

declare class CookieCutter implements TemplaterBase {
    private readonly containerRunner;
    constructor({ containerRunner }: {
        containerRunner: ContainerRunner;
    });
    private fetchTemplateCookieCutter;
    run({ workspacePath, values, logStream, }: TemplaterRunOptions): Promise<void>;
}

declare type RunCommandOptions = {
    command: string;
    args: string[];
    logStream?: Writable;
};
/**
 * Gets the templater key to use for templating from the entity
 * @param entity Template entity
 */
declare const getTemplaterKey: (entity: TemplateEntityV1alpha1) => string;
/**
 *
 * @param options the options object
 * @param options.command the command to run
 * @param options.args the arguments to pass the command
 * @param options.logStream the log streamer to capture log messages
 */
declare const runCommand: ({ command, args, logStream, }: RunCommandOptions) => Promise<void>;

declare class Templaters implements TemplaterBuilder {
    private templaterMap;
    register(templaterKey: SupportedTemplatingKey, templater: TemplaterBase): void;
    get(templaterId: string): TemplaterBase;
}

declare class CreateReactAppTemplater implements TemplaterBase {
    private readonly containerRunner;
    constructor({ containerRunner }: {
        containerRunner: ContainerRunner;
    });
    run({ workspacePath, values, logStream, }: TemplaterRunOptions): Promise<void>;
}

declare function createFetchCookiecutterAction(options: {
    reader: UrlReader;
    integrations: ScmIntegrations;
    templaters: TemplaterBuilder;
}): TemplateAction<any>;

declare function createPublishGithubAction(options: {
    integrations: ScmIntegrationRegistry;
}): TemplateAction<any>;

declare type CreatePullRequestResponse = {
    data: {
        html_url: string;
    };
};
interface PullRequestCreator {
    createPullRequest(options: createPullRequest.Options): Promise<CreatePullRequestResponse | null>;
}
declare type ClientFactoryInput = {
    integrations: ScmIntegrationRegistry;
    host: string;
    owner: string;
    repo: string;
};
interface CreateGithubPullRequestActionOptions {
    integrations: ScmIntegrationRegistry;
    clientFactory?: (input: ClientFactoryInput) => Promise<PullRequestCreator>;
}
declare const createPublishGithubPullRequestAction: ({ integrations, clientFactory, }: CreateGithubPullRequestActionOptions) => TemplateAction<any>;

declare function createPublishAzureAction(options: {
    integrations: ScmIntegrationRegistry;
}): TemplateAction<any>;

declare function createPublishGitlabAction(options: {
    integrations: ScmIntegrationRegistry;
}): TemplateAction<any>;

declare function createPublishBitbucketAction(options: {
    integrations: ScmIntegrationRegistry;
}): TemplateAction<any>;

/**
 * This task is useful for local development and testing of both the scaffolder
 * and scaffolder templates.
 *
 * This action is not installed by default and should not be installed in
 * production, as it writes the files to the local filesystem of the scaffolder.
 */
declare function createPublishFileAction(): TemplateAction<any>;

declare type PreparerOptions = {
    /**
     * Full URL to the directory containg template data
     */
    url: string;
    /**
     * The workspace path that will eventually be the the root of the new repo
     */
    workspacePath: string;
    logger: Logger;
};
interface PreparerBase {
    /**
     * Prepare a directory with contents from the remote location
     */
    prepare(opts: PreparerOptions): Promise<void>;
}
declare type PreparerBuilder = {
    register(host: string, preparer: PreparerBase): void;
    get(url: string): PreparerBase;
};

declare class AzurePreparer implements PreparerBase {
    private readonly config;
    static fromConfig(config: AzureIntegrationConfig): AzurePreparer;
    constructor(config: {
        token?: string;
    });
    prepare({ url, workspacePath, logger }: PreparerOptions): Promise<void>;
}

declare class BitbucketPreparer implements PreparerBase {
    private readonly config;
    static fromConfig(config: BitbucketIntegrationConfig): BitbucketPreparer;
    constructor(config: {
        username?: string;
        token?: string;
        appPassword?: string;
    });
    prepare({ url, workspacePath, logger }: PreparerOptions): Promise<void>;
    private getAuth;
}

declare class FilePreparer implements PreparerBase {
    prepare({ url, workspacePath }: PreparerOptions): Promise<void>;
}

declare class GithubPreparer implements PreparerBase {
    private readonly config;
    static fromConfig(config: GitHubIntegrationConfig): GithubPreparer;
    constructor(config: {
        credentialsProvider: GithubCredentialsProvider;
    });
    prepare({ url, workspacePath, logger }: PreparerOptions): Promise<void>;
}

declare class GitlabPreparer implements PreparerBase {
    private readonly config;
    static fromConfig(config: GitLabIntegrationConfig): GitlabPreparer;
    constructor(config: {
        token?: string;
    });
    prepare({ url, workspacePath, logger }: PreparerOptions): Promise<void>;
}

declare class Preparers implements PreparerBuilder {
    private preparerMap;
    register(host: string, preparer: PreparerBase): void;
    get(url: string): PreparerBase;
    static fromConfig(config: Config, _: {
        logger: Logger;
    }): Promise<PreparerBuilder>;
}

/**
 * Publisher is in charge of taking a folder created by
 * the templater, and pushing it to a remote storage
 */
declare type PublisherBase = {
    /**
     *
     * @param opts object containing the template entity from the service
     *             catalog, plus the values from the form and the directory that has
     *             been templated
     */
    publish(opts: PublisherOptions): Promise<PublisherResult>;
};
declare type PublisherOptions = {
    values: TemplaterValues;
    workspacePath: string;
    logger: Logger;
};
declare type PublisherResult = {
    remoteUrl: string;
    catalogInfoUrl?: string;
};
declare type PublisherBuilder = {
    register(host: string, publisher: PublisherBase): void;
    get(storePath: string): PublisherBase;
};

declare class AzurePublisher implements PublisherBase {
    private readonly config;
    static fromConfig(config: AzureIntegrationConfig): Promise<AzurePublisher | undefined>;
    constructor(config: {
        token: string;
    });
    publish({ values, workspacePath, logger, }: PublisherOptions): Promise<PublisherResult>;
    private createRemote;
}

declare type RepoVisibilityOptions = 'private' | 'public';
declare class BitbucketPublisher implements PublisherBase {
    private readonly config;
    static fromConfig(config: BitbucketIntegrationConfig, { repoVisibility }: {
        repoVisibility: RepoVisibilityOptions;
    }): Promise<BitbucketPublisher>;
    constructor(config: {
        host: string;
        token?: string;
        appPassword?: string;
        username?: string;
        apiBaseUrl?: string;
        repoVisibility: RepoVisibilityOptions;
    });
    publish({ values, workspacePath, logger, }: PublisherOptions): Promise<PublisherResult>;
    private createRemote;
    private createBitbucketCloudRepository;
    private getAuthorizationHeader;
    private createBitbucketServerRepository;
}

declare type RepoVisibilityOptions$1 = 'private' | 'internal' | 'public';
/** @deprecated use createPublishGithubAction instead */
declare class GithubPublisher implements PublisherBase {
    private readonly config;
    static fromConfig(config: GitHubIntegrationConfig, { repoVisibility }: {
        repoVisibility: RepoVisibilityOptions$1;
    }): Promise<GithubPublisher | undefined>;
    constructor(config: {
        credentialsProvider: GithubCredentialsProvider;
        repoVisibility: RepoVisibilityOptions$1;
        apiBaseUrl: string | undefined;
    });
    publish({ values, workspacePath, logger, }: PublisherOptions): Promise<PublisherResult>;
    private createRemote;
}

declare type RepoVisibilityOptions$2 = 'private' | 'internal' | 'public';
declare class GitlabPublisher implements PublisherBase {
    private readonly config;
    static fromConfig(config: GitLabIntegrationConfig, { repoVisibility }: {
        repoVisibility: RepoVisibilityOptions$2;
    }): Promise<GitlabPublisher | undefined>;
    constructor(config: {
        token: string;
        client: Gitlab;
        repoVisibility: RepoVisibilityOptions$2;
    });
    publish({ values, workspacePath, logger, }: PublisherOptions): Promise<PublisherResult>;
    private createRemote;
}

declare class Publishers implements PublisherBuilder {
    private publisherMap;
    register(host: string, preparer: PublisherBase | undefined): void;
    get(url: string): PublisherBase;
    static fromConfig(config: Config, _options: {
        logger: Logger;
    }): Promise<PublisherBuilder>;
}

declare type ParsedLocationAnnotation = {
    protocol: 'file' | 'url';
    location: string;
};
declare const parseLocationAnnotation: (entity: TemplateEntityV1alpha1) => ParsedLocationAnnotation;
declare function joinGitUrlPath(repoUrl: string, path?: string): string;

declare const createBuiltinActions: (options: {
    reader: UrlReader;
    integrations: ScmIntegrations;
    catalogClient: CatalogApi;
    templaters: TemplaterBuilder;
}) => TemplateAction<any>[];

declare type PartialJsonObject = Partial<JsonObject>;
declare type PartialJsonValue = PartialJsonObject | JsonValue | undefined;
declare type InputBase = Partial<{
    [name: string]: PartialJsonValue;
}>;
declare type ActionContext<Input extends InputBase> = {
    /**
     * Base URL for the location of the task spec, typically the url of the source entity file.
     */
    baseUrl?: string;
    logger: Logger;
    logStream: Writable;
    /**
     * User token forwarded from initial request, for use in subsequent api requests
     */
    token?: string | undefined;
    workspacePath: string;
    input: Input;
    output(name: string, value: JsonValue): void;
    /**
     * Creates a temporary directory for use by the action, which is then cleaned up automatically.
     */
    createTemporaryDirectory(): Promise<string>;
};
declare type TemplateAction<Input extends InputBase> = {
    id: string;
    description?: string;
    schema?: {
        input?: Schema;
        output?: Schema;
    };
    handler: (ctx: ActionContext<Input>) => Promise<void>;
};

declare class TemplateActionRegistry {
    private readonly actions;
    register<Parameters extends InputBase>(action: TemplateAction<Parameters>): void;
    get(actionId: string): TemplateAction<any>;
    list(): TemplateAction<any>[];
}

declare const createTemplateAction: <Input extends Partial<{
    [name: string]: JsonValue | Partial<JsonObject> | undefined;
}>>(templateAction: TemplateAction<Input>) => TemplateAction<any>;

declare type Options = {
    preparers: PreparerBuilder;
    templaters: TemplaterBuilder;
    publishers: PublisherBuilder;
};
declare function createLegacyActions(options: Options): TemplateAction<any>[];

declare type StageContext<T = {}> = {
    values: TemplaterValues;
    entity: TemplateEntityV1alpha1;
    logger: Logger;
    logStream: Writable;
    workspacePath: string;
} & T;
declare type ProcessorStatus = 'PENDING' | 'STARTED' | 'COMPLETED' | 'FAILED';
interface StageResult extends StageInput {
    log: string[];
    status: ProcessorStatus;
    startedAt?: number;
    endedAt?: number;
}
interface StageInput<T = {}> {
    name: string;
    handler(ctx: StageContext<T>): Promise<void | object>;
}
declare type Job = {
    id: string;
    context: StageContext;
    status: ProcessorStatus;
    stages: StageResult[];
    error?: Error;
};
declare type Processor = {
    create({ entity, values, stages, }: {
        entity: TemplateEntityV1alpha1;
        values: TemplaterValues;
        stages: StageInput[];
    }): Job;
    get(id: string): Job | undefined;
    run(job: Job): Promise<void>;
};

declare type JobAndDirectoryTuple = {
    job: Job;
    directory: string;
};
declare class JobProcessor implements Processor {
    private readonly workingDirectory;
    private readonly jobs;
    static fromConfig({ config, logger, }: {
        config: Config;
        logger: Logger;
    }): Promise<JobProcessor>;
    constructor(workingDirectory: string);
    create({ entity, values, stages, }: {
        entity: TemplateEntityV1alpha1;
        values: TemplaterValues;
        stages: StageInput[];
    }): Job;
    get(id: string): Job | undefined;
    run(job: Job): Promise<void>;
}

interface RouterOptions {
    preparers: PreparerBuilder;
    templaters: TemplaterBuilder;
    publishers: PublisherBuilder;
    logger: Logger;
    config: Config;
    reader: UrlReader;
    database: PluginDatabaseManager;
    catalogClient: CatalogApi;
    actions?: TemplateAction<any>[];
    taskWorkers?: number;
}
declare function createRouter(options: RouterOptions): Promise<express.Router>;

/**
 * A catalog client tailored for reading out entity data from the catalog.
 */
declare class CatalogEntityClient {
    private readonly catalogClient;
    constructor(catalogClient: CatalogApi);
    /**
     * Looks up a single template using a template name.
     *
     * Throws a NotFoundError or ConflictError if 0 or multiple templates are found.
     */
    findTemplate(templateName: string, options?: {
        token?: string;
    }): Promise<TemplateEntityV1alpha1 | TemplateEntityV1beta2>;
}

export { ActionContext, AzurePreparer, AzurePublisher, BitbucketPreparer, BitbucketPublisher, CatalogEntityClient, CookieCutter, CreateReactAppTemplater, FilePreparer, GithubPreparer, GithubPublisher, GitlabPreparer, GitlabPublisher, Job, JobAndDirectoryTuple, JobProcessor, ParsedLocationAnnotation, PreparerBase, PreparerBuilder, PreparerOptions, Preparers, Processor, ProcessorStatus, PublisherBase, PublisherBuilder, PublisherOptions, PublisherResult, Publishers, RepoVisibilityOptions$1 as RepoVisibilityOptions, RequiredTemplateValues, RouterOptions, RunCommandOptions, StageContext, StageInput, StageResult, SupportedTemplatingKey, TemplateAction, TemplateActionRegistry, TemplaterBase, TemplaterBuilder, TemplaterConfig, TemplaterRunOptions, TemplaterRunResult, TemplaterValues, Templaters, createBuiltinActions, createCatalogRegisterAction, createFetchCookiecutterAction, createFetchPlainAction, createLegacyActions, createPublishAzureAction, createPublishBitbucketAction, createPublishFileAction, createPublishGithubAction, createPublishGithubPullRequestAction, createPublishGitlabAction, createRouter, createTemplateAction, getTemplaterKey, joinGitUrlPath, parseLocationAnnotation, runCommand };
