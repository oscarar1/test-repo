{"version":3,"file":"index.cjs.js","sources":["../src/scaffolder/actions/createTemplateAction.ts","../src/scaffolder/actions/builtin/catalog/register.ts","../src/scaffolder/actions/builtin/fetch/helpers.ts","../src/scaffolder/actions/builtin/fetch/plain.ts","../src/scaffolder/actions/builtin/fetch/cookiecutter.ts","../src/scaffolder/stages/publish/helpers.ts","../src/scaffolder/actions/builtin/publish/util.ts","../src/scaffolder/actions/builtin/publish/github.ts","../src/scaffolder/actions/builtin/publish/githubPullRequest.ts","../src/scaffolder/actions/builtin/publish/azure.ts","../src/scaffolder/actions/builtin/publish/gitlab.ts","../src/scaffolder/actions/builtin/publish/bitbucket.ts","../src/scaffolder/actions/builtin/publish/file.ts","../src/scaffolder/actions/builtin/createBuiltinActions.ts","../src/scaffolder/actions/TemplateActionRegistry.ts","../src/scaffolder/stages/prepare/azure.ts","../src/scaffolder/stages/prepare/bitbucket.ts","../src/scaffolder/stages/prepare/file.ts","../src/scaffolder/stages/prepare/github.ts","../src/scaffolder/stages/prepare/gitlab.ts","../src/scaffolder/stages/prepare/preparers.ts","../src/scaffolder/stages/legacy.ts","../src/scaffolder/stages/publish/azure.ts","../src/scaffolder/stages/publish/bitbucket.ts","../src/scaffolder/stages/publish/github.ts","../src/scaffolder/stages/publish/gitlab.ts","../src/scaffolder/stages/publish/publishers.ts","../src/scaffolder/stages/templater/helpers.ts","../src/scaffolder/stages/templater/cookiecutter.ts","../src/scaffolder/stages/templater/templaters.ts","../src/scaffolder/stages/templater/cra/index.ts","../src/scaffolder/stages/helpers.ts","../src/scaffolder/jobs/logger.ts","../src/scaffolder/jobs/processor.ts","../src/lib/catalog/CatalogEntityClient.ts","../src/scaffolder/tasks/DatabaseTaskStore.ts","../src/scaffolder/tasks/StorageTaskBroker.ts","../src/scaffolder/tasks/TaskWorker.ts","../src/scaffolder/tasks/TemplateConverter.ts","../src/service/helpers.ts","../src/service/router.ts"],"sourcesContent":["/*\n * Copyright 2021 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { InputBase, TemplateAction } from './types';\n\nexport const createTemplateAction = <Input extends InputBase>(\n  templateAction: TemplateAction<Input>,\n): TemplateAction<any> => {\n  // TODO(blam): Can add some more validation here to validate the action later on\n  return templateAction;\n};\n","/*\n * Copyright 2021 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { InputError } from '@backstage/errors';\nimport { ScmIntegrations } from '@backstage/integration';\nimport { CatalogApi } from '@backstage/catalog-client';\nimport { getEntityName } from '@backstage/catalog-model';\nimport { createTemplateAction } from '../../createTemplateAction';\n\nexport function createCatalogRegisterAction(options: {\n  catalogClient: CatalogApi;\n  integrations: ScmIntegrations;\n}) {\n  const { catalogClient, integrations } = options;\n\n  return createTemplateAction<\n    | { catalogInfoUrl: string }\n    | { repoContentsUrl: string; catalogInfoPath?: string }\n  >({\n    id: 'catalog:register',\n    description:\n      'Registers entities from a catalog descriptor file in the workspace into the software catalog.',\n    schema: {\n      input: {\n        oneOf: [\n          {\n            type: 'object',\n            required: ['catalogInfoUrl'],\n            properties: {\n              catalogInfoUrl: {\n                title: 'Catalog Info URL',\n                description:\n                  'An absolute URL pointing to the catalog info file location',\n                type: 'string',\n              },\n            },\n          },\n          {\n            type: 'object',\n            required: ['repoContentsUrl'],\n            properties: {\n              repoContentsUrl: {\n                title: 'Repository Contents URL',\n                description:\n                  'An absolute URL pointing to the root of a repository directory tree',\n                type: 'string',\n              },\n              catalogInfoPath: {\n                title: 'Fetch URL',\n                description:\n                  'A relative path from the repo root pointing to the catalog info file, defaults to /catalog-info.yaml',\n                type: 'string',\n              },\n            },\n          },\n        ],\n      },\n    },\n    async handler(ctx) {\n      const { input } = ctx;\n\n      let catalogInfoUrl;\n      if ('catalogInfoUrl' in input) {\n        catalogInfoUrl = input.catalogInfoUrl;\n      } else {\n        const {\n          repoContentsUrl,\n          catalogInfoPath = '/catalog-info.yaml',\n        } = input;\n        const integration = integrations.byUrl(repoContentsUrl);\n        if (!integration) {\n          throw new InputError(\n            `No integration found for host ${repoContentsUrl}`,\n          );\n        }\n\n        catalogInfoUrl = integration.resolveUrl({\n          base: repoContentsUrl,\n          url: catalogInfoPath,\n        });\n      }\n\n      ctx.logger.info(`Registering ${catalogInfoUrl} in the catalog`);\n\n      const result = await catalogClient.addLocation(\n        {\n          type: 'url',\n          target: catalogInfoUrl,\n        },\n        ctx.token ? { token: ctx.token } : {},\n      );\n      if (result.entities.length >= 1) {\n        const { kind, name, namespace } = getEntityName(result.entities[0]);\n        ctx.output('entityRef', `${kind}:${namespace}/${name}`);\n        ctx.output('catalogInfoUrl', catalogInfoUrl);\n      }\n    },\n  });\n}\n","/*\n * Copyright 2021 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from 'fs-extra';\nimport { resolve as resolvePath, isAbsolute } from 'path';\nimport { UrlReader } from '@backstage/backend-common';\nimport { InputError } from '@backstage/errors';\nimport { ScmIntegrations } from '@backstage/integration';\nimport { JsonValue } from '@backstage/config';\n\nexport async function fetchContents({\n  reader,\n  integrations,\n  baseUrl,\n  fetchUrl = '.',\n  outputPath,\n}: {\n  reader: UrlReader;\n  integrations: ScmIntegrations;\n  baseUrl?: string;\n  fetchUrl?: JsonValue;\n  outputPath: string;\n}) {\n  if (typeof fetchUrl !== 'string') {\n    throw new InputError(\n      `Invalid url parameter, expected string, got ${typeof fetchUrl}`,\n    );\n  }\n\n  let fetchUrlIsAbsolute = false;\n  try {\n    // eslint-disable-next-line no-new\n    new URL(fetchUrl);\n    fetchUrlIsAbsolute = true;\n  } catch {\n    /* ignored */\n  }\n\n  // We handle both file locations and url ones\n  if (!fetchUrlIsAbsolute && baseUrl?.startsWith('file://')) {\n    const basePath = baseUrl.slice('file://'.length);\n    if (isAbsolute(fetchUrl)) {\n      throw new InputError(\n        `Fetch URL may not be absolute for file locations, ${fetchUrl}`,\n      );\n    }\n    const srcDir = resolvePath(basePath, '..', fetchUrl);\n    await fs.copy(srcDir, outputPath);\n  } else {\n    let readUrl;\n\n    if (fetchUrlIsAbsolute) {\n      readUrl = fetchUrl;\n    } else if (baseUrl) {\n      const integration = integrations.byUrl(baseUrl);\n      if (!integration) {\n        throw new InputError(`No integration found for location ${baseUrl}`);\n      }\n\n      readUrl = integration.resolveUrl({\n        url: fetchUrl,\n        base: baseUrl,\n      });\n    } else {\n      throw new InputError(\n        `Failed to fetch, template location could not be determined and the fetch URL is relative, ${fetchUrl}`,\n      );\n    }\n\n    const res = await reader.readTree(readUrl);\n    await fs.ensureDir(outputPath);\n    await res.dir({ targetDir: outputPath });\n  }\n}\n","/*\n * Copyright 2021 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport path from 'path';\nimport { UrlReader } from '@backstage/backend-common';\nimport { InputError } from '@backstage/errors';\nimport { ScmIntegrations } from '@backstage/integration';\nimport { fetchContents } from './helpers';\nimport { createTemplateAction } from '../../createTemplateAction';\n\nexport function createFetchPlainAction(options: {\n  reader: UrlReader;\n  integrations: ScmIntegrations;\n}) {\n  const { reader, integrations } = options;\n\n  return createTemplateAction<{ url: string; targetPath?: string }>({\n    id: 'fetch:plain',\n    description:\n      \"Downloads content and places it in the workspace, or optionally in a subdirectory specified by the 'targetPath' input option.\",\n    schema: {\n      input: {\n        type: 'object',\n        required: ['url'],\n        properties: {\n          url: {\n            title: 'Fetch URL',\n            description:\n              'Relative path or absolute URL pointing to the directory tree to fetch',\n            type: 'string',\n          },\n          targetPath: {\n            title: 'Target Path',\n            description:\n              'Target path within the working directory to download the contents to.',\n            type: 'string',\n          },\n        },\n      },\n    },\n    async handler(ctx) {\n      ctx.logger.info('Fetching plain content from remote URL');\n\n      // Finally move the template result into the task workspace\n      const targetPath = ctx.input.targetPath ?? './';\n      const outputPath = path.resolve(ctx.workspacePath, targetPath);\n      if (!outputPath.startsWith(ctx.workspacePath)) {\n        throw new InputError(\n          `Fetch action targetPath may not specify a path outside the working directory`,\n        );\n      }\n\n      await fetchContents({\n        reader,\n        integrations,\n        baseUrl: ctx.baseUrl,\n        fetchUrl: ctx.input.url,\n        outputPath,\n      });\n    },\n  });\n}\n","/*\n * Copyright 2021 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { UrlReader } from '@backstage/backend-common';\nimport { JsonObject } from '@backstage/config';\nimport { InputError } from '@backstage/errors';\nimport { ScmIntegrations } from '@backstage/integration';\nimport fs from 'fs-extra';\nimport { resolve as resolvePath } from 'path';\nimport { TemplaterBuilder, TemplaterValues } from '../../../stages/templater';\nimport { createTemplateAction } from '../../createTemplateAction';\nimport { fetchContents } from './helpers';\n\nexport function createFetchCookiecutterAction(options: {\n  reader: UrlReader;\n  integrations: ScmIntegrations;\n  templaters: TemplaterBuilder;\n}) {\n  const { reader, templaters, integrations } = options;\n\n  return createTemplateAction<{\n    url: string;\n    targetPath?: string;\n    values: JsonObject;\n    copyWithoutRender?: string[];\n    extensions?: string[];\n    imageName?: string;\n  }>({\n    id: 'fetch:cookiecutter',\n    description:\n      'Downloads a template from the given URL into the workspace, and runs cookiecutter on it.',\n    schema: {\n      input: {\n        type: 'object',\n        required: ['url'],\n        properties: {\n          url: {\n            title: 'Fetch URL',\n            description:\n              'Relative path or absolute URL pointing to the directory tree to fetch',\n            type: 'string',\n          },\n          targetPath: {\n            title: 'Target Path',\n            description:\n              'Target path within the working directory to download the contents to.',\n            type: 'string',\n          },\n          values: {\n            title: 'Template Values',\n            description: 'Values to pass on to cookiecutter for templating',\n            type: 'object',\n          },\n          copyWithoutRender: {\n            title: 'Copy Without Render',\n            description:\n              'Avoid rendering directories and files in the template',\n            type: 'array',\n            items: {\n              type: 'string',\n            },\n          },\n          extensions: {\n            title: 'Template Extensions',\n            description:\n              \"Jinja2 extensions to add filters, tests, globals or extend the parser. Extensions must be installed in the container or on the host where Cookiecutter executes. See the contrib directory in Backstage's repo for more information\",\n            type: 'array',\n            items: {\n              type: 'string',\n            },\n          },\n          imageName: {\n            title: 'Cookiecutter Docker image',\n            description:\n              \"Specify a custom Docker image to run cookiecutter, to override the default: 'spotify/backstage-cookiecutter'. This can be used to execute cookiecutter with Template Extensions. Used only when a local cookiecutter is not found.\",\n            type: 'string',\n          },\n        },\n      },\n    },\n    async handler(ctx) {\n      ctx.logger.info('Fetching and then templating using cookiecutter');\n      const workDir = await ctx.createTemporaryDirectory();\n      const templateDir = resolvePath(workDir, 'template');\n      const templateContentsDir = resolvePath(\n        templateDir,\n        \"{{cookiecutter and 'contents'}}\",\n      );\n      const resultDir = resolvePath(workDir, 'result');\n\n      if (\n        ctx.input.copyWithoutRender &&\n        !Array.isArray(ctx.input.copyWithoutRender)\n      ) {\n        throw new InputError(\n          'Fetch action input copyWithoutRender must be an Array',\n        );\n      }\n      if (ctx.input.extensions && !Array.isArray(ctx.input.extensions)) {\n        throw new InputError('Fetch action input extensions must be an Array');\n      }\n\n      await fetchContents({\n        reader,\n        integrations,\n        baseUrl: ctx.baseUrl,\n        fetchUrl: ctx.input.url,\n        outputPath: templateContentsDir,\n      });\n\n      const cookiecutter = templaters.get('cookiecutter');\n      const values = {\n        ...(ctx.input.values as TemplaterValues),\n        _copy_without_render: ctx.input.copyWithoutRender,\n        _extensions: ctx.input.extensions,\n        imageName: ctx.input.imageName,\n      };\n\n      // Will execute the template in ./template and put the result in ./result\n      await cookiecutter.run({\n        workspacePath: workDir,\n        logStream: ctx.logStream,\n        values,\n      });\n\n      // Finally move the template result into the task workspace\n      const targetPath = ctx.input.targetPath ?? './';\n      const outputPath = resolvePath(ctx.workspacePath, targetPath);\n      if (!outputPath.startsWith(ctx.workspacePath)) {\n        throw new InputError(\n          `Fetch action targetPath may not specify a path outside the working directory`,\n        );\n      }\n      await fs.copy(resultDir, outputPath);\n    },\n  });\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport globby from 'globby';\nimport { Logger } from 'winston';\nimport { Git } from '@backstage/backend-common';\nimport { Octokit } from '@octokit/rest';\n\nexport async function initRepoAndPush({\n  dir,\n  remoteUrl,\n  auth,\n  logger,\n}: {\n  dir: string;\n  remoteUrl: string;\n  auth: { username: string; password: string };\n  logger: Logger;\n}): Promise<void> {\n  const git = Git.fromAuth({\n    username: auth.username,\n    password: auth.password,\n    logger,\n  });\n\n  await git.init({\n    dir,\n  });\n\n  const paths = await globby(['./**', './**/.*', '!.git'], {\n    cwd: dir,\n    gitignore: true,\n    dot: true,\n  });\n\n  for (const filepath of paths) {\n    await git.add({ dir, filepath });\n  }\n\n  await git.commit({\n    dir,\n    message: 'Initial commit',\n    author: { name: 'Scaffolder', email: 'scaffolder@backstage.io' },\n    committer: { name: 'Scaffolder', email: 'scaffolder@backstage.io' },\n  });\n\n  await git.addRemote({\n    dir,\n    url: remoteUrl,\n    remote: 'origin',\n  });\n\n  await git.push({\n    dir,\n    remote: 'origin',\n  });\n}\n\ntype BranchProtectionOptions = {\n  client: Octokit;\n  owner: string;\n  repoName: string;\n  logger: Logger;\n};\n\nexport const enableBranchProtectionOnDefaultRepoBranch = async ({\n  repoName,\n  client,\n  owner,\n  logger,\n}: BranchProtectionOptions): Promise<void> => {\n  const tryOnce = async () => {\n    try {\n      await client.repos.updateBranchProtection({\n        mediaType: {\n          /**\n           * ðŸ‘‡ we need this preview because allowing a custom\n           * reviewer count on branch protection is a preview\n           * feature\n           *\n           * More here: https://docs.github.com/en/rest/overview/api-previews#require-multiple-approving-reviews\n           */\n          previews: ['luke-cage-preview'],\n        },\n        owner,\n        repo: repoName,\n        branch: 'master',\n        required_status_checks: { strict: true, contexts: [] },\n        restrictions: null,\n        enforce_admins: true,\n        required_pull_request_reviews: { required_approving_review_count: 1 },\n      });\n    } catch (e) {\n      if (\n        e.message.includes(\n          'Upgrade to GitHub Pro or make this repository public to enable this feature',\n        )\n      ) {\n        logger.warn(\n          'Branch protection was not enabled as it requires GitHub Pro for private repositories',\n        );\n      } else {\n        throw e;\n      }\n    }\n  };\n\n  try {\n    await tryOnce();\n  } catch (e) {\n    if (!e.message.includes('Branch not found')) {\n      throw e;\n    }\n\n    // GitHub has eventual consistency. Fail silently, wait, and try again.\n    await new Promise(resolve => setTimeout(resolve, 600));\n    await tryOnce();\n  }\n};\n","/*\n * Copyright 2021 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { InputError } from '@backstage/errors';\nimport { join as joinPath, normalize as normalizePath } from 'path';\n\nexport const getRepoSourceDirectory = (\n  workspacePath: string,\n  sourcePath: string | undefined,\n) => {\n  if (sourcePath) {\n    const safeSuffix = normalizePath(sourcePath).replace(\n      /^(\\.\\.(\\/|\\\\|$))+/,\n      '',\n    );\n    return joinPath(workspacePath, safeSuffix);\n  }\n  return workspacePath;\n};\nexport type RepoSpec = {\n  repo: string;\n  host: string;\n  owner: string;\n  organization?: string;\n};\n\nexport const parseRepoUrl = (repoUrl: string): RepoSpec => {\n  let parsed;\n  try {\n    parsed = new URL(`https://${repoUrl}`);\n  } catch (error) {\n    throw new InputError(\n      `Invalid repo URL passed to publisher, got ${repoUrl}, ${error}`,\n    );\n  }\n  const host = parsed.host;\n  const owner = parsed.searchParams.get('owner');\n\n  if (!owner) {\n    throw new InputError(\n      `Invalid repo URL passed to publisher: ${repoUrl}, missing owner`,\n    );\n  }\n  const repo = parsed.searchParams.get('repo');\n  if (!repo) {\n    throw new InputError(\n      `Invalid repo URL passed to publisher: ${repoUrl}, missing repo`,\n    );\n  }\n\n  const organization = parsed.searchParams.get('organization') ?? undefined;\n\n  return { host, owner, repo, organization };\n};\n","/*\n * Copyright 2021 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { InputError } from '@backstage/errors';\nimport {\n  GithubCredentialsProvider,\n  ScmIntegrationRegistry,\n} from '@backstage/integration';\nimport { Octokit } from '@octokit/rest';\nimport {\n  enableBranchProtectionOnDefaultRepoBranch,\n  initRepoAndPush,\n} from '../../../stages/publish/helpers';\nimport { getRepoSourceDirectory, parseRepoUrl } from './util';\nimport { createTemplateAction } from '../../createTemplateAction';\n\ntype Permission = 'pull' | 'push' | 'admin' | 'maintain' | 'triage';\ntype Collaborator = { access: Permission; username: string };\n\nexport function createPublishGithubAction(options: {\n  integrations: ScmIntegrationRegistry;\n}) {\n  const { integrations } = options;\n\n  const credentialsProviders = new Map(\n    integrations.github.list().map(integration => {\n      const provider = GithubCredentialsProvider.create(integration.config);\n      return [integration.config.host, provider];\n    }),\n  );\n\n  return createTemplateAction<{\n    repoUrl: string;\n    description?: string;\n    access?: string;\n    sourcePath?: string;\n    repoVisibility: 'private' | 'internal' | 'public';\n    collaborators: Collaborator[];\n  }>({\n    id: 'publish:github',\n    description:\n      'Initializes a git repository of contents in workspace and publishes it to GitHub.',\n    schema: {\n      input: {\n        type: 'object',\n        required: ['repoUrl'],\n        properties: {\n          repoUrl: {\n            title: 'Repository Location',\n            type: 'string',\n          },\n          description: {\n            title: 'Repository Description',\n            type: 'string',\n          },\n          access: {\n            title: 'Repository Access',\n            type: 'string',\n          },\n          repoVisibility: {\n            title: 'Repository Visibility',\n            type: 'string',\n            enum: ['private', 'public', 'internal'],\n          },\n          sourcePath: {\n            title:\n              'Path within the workspace that will be used as the repository root. If omitted, the entire workspace will be published as the repository.',\n            type: 'string',\n          },\n          collaborators: {\n            title: 'Collaborators',\n            description: 'Provide users with permissions',\n            type: 'array',\n            items: {\n              type: 'object',\n              required: ['username', 'access'],\n              properties: {\n                access: {\n                  type: 'string',\n                  description: 'The type of access for the user',\n                  enum: ['push', 'pull', 'admin', 'maintain', 'triage'],\n                },\n                username: {\n                  type: 'string',\n                  description: 'The username or group',\n                },\n              },\n            },\n          },\n        },\n      },\n      output: {\n        type: 'object',\n        properties: {\n          remoteUrl: {\n            title: 'A URL to the repository with the provider',\n            type: 'string',\n          },\n          repoContentsUrl: {\n            title: 'A URL to the root of the repository',\n            type: 'string',\n          },\n        },\n      },\n    },\n    async handler(ctx) {\n      const {\n        repoUrl,\n        description,\n        access,\n        repoVisibility = 'private',\n        collaborators,\n      } = ctx.input;\n\n      const { owner, repo, host } = parseRepoUrl(repoUrl);\n\n      const credentialsProvider = credentialsProviders.get(host);\n      const integrationConfig = integrations.github.byHost(host);\n\n      if (!credentialsProvider || !integrationConfig) {\n        throw new InputError(\n          `No matching integration configuration for host ${host}, please check your integrations config`,\n        );\n      }\n\n      // TODO(blam): Consider changing this API to have owner, repo interface instead of URL as the it's\n      // needless to create URL and then parse again the other side.\n      const { token } = await credentialsProvider.getCredentials({\n        url: `https://${host}/${encodeURIComponent(owner)}/${encodeURIComponent(\n          repo,\n        )}`,\n      });\n\n      if (!token) {\n        throw new InputError(\n          `No token available for host: ${host}, with owner ${owner}, and repo ${repo}`,\n        );\n      }\n\n      const client = new Octokit({\n        auth: token,\n        baseUrl: integrationConfig.config.apiBaseUrl,\n        previews: ['nebula-preview'],\n      });\n\n      const user = await client.users.getByUsername({\n        username: owner,\n      });\n\n      const repoCreationPromise =\n        user.data.type === 'Organization'\n          ? client.repos.createInOrg({\n              name: repo,\n              org: owner,\n              private: repoVisibility === 'private',\n              visibility: repoVisibility,\n              description: description,\n            })\n          : client.repos.createForAuthenticatedUser({\n              name: repo,\n              private: repoVisibility === 'private',\n              description: description,\n            });\n\n      const { data: newRepo } = await repoCreationPromise;\n      if (access?.startsWith(`${owner}/`)) {\n        const [, team] = access.split('/');\n        await client.teams.addOrUpdateRepoPermissionsInOrg({\n          org: owner,\n          team_slug: team,\n          owner,\n          repo,\n          permission: 'admin',\n        });\n        // No need to add access if it's the person who owns the personal account\n      } else if (access && access !== owner) {\n        await client.repos.addCollaborator({\n          owner,\n          repo,\n          username: access,\n          permission: 'admin',\n        });\n      }\n\n      if (collaborators) {\n        for (const {\n          access: permission,\n          username: team_slug,\n        } of collaborators) {\n          try {\n            await client.teams.addOrUpdateRepoPermissionsInOrg({\n              org: owner,\n              team_slug,\n              owner,\n              repo,\n              permission,\n            });\n          } catch (e) {\n            ctx.logger.warn(\n              `Skipping ${permission} access for ${team_slug}, ${e.message}`,\n            );\n          }\n        }\n      }\n\n      const remoteUrl = newRepo.clone_url;\n      const repoContentsUrl = `${newRepo.html_url}/blob/master`;\n\n      await initRepoAndPush({\n        dir: getRepoSourceDirectory(ctx.workspacePath, ctx.input.sourcePath),\n        remoteUrl,\n        auth: {\n          username: 'x-access-token',\n          password: token,\n        },\n        logger: ctx.logger,\n      });\n\n      try {\n        await enableBranchProtectionOnDefaultRepoBranch({\n          owner,\n          client,\n          repoName: newRepo.name,\n          logger: ctx.logger,\n        });\n      } catch (e) {\n        throw new Error(\n          `Failed to add branch protection to '${newRepo.name}', ${e}`,\n        );\n      }\n\n      ctx.output('remoteUrl', remoteUrl);\n      ctx.output('repoContentsUrl', repoContentsUrl);\n    },\n  });\n}\n","/*\n * Copyright 2021 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { readFile } from 'fs-extra';\nimport path from 'path';\nimport { parseRepoUrl } from './util';\n\nimport {\n  GithubCredentialsProvider,\n  ScmIntegrationRegistry,\n} from '@backstage/integration';\nimport { zipObject } from 'lodash';\nimport { createTemplateAction } from '../../createTemplateAction';\nimport { Octokit } from '@octokit/rest';\nimport { InputError, CustomErrorBase } from '@backstage/errors';\nimport { createPullRequest } from 'octokit-plugin-create-pull-request';\nimport globby from 'globby';\n\nclass GithubResponseError extends CustomErrorBase {}\n\ntype CreatePullRequestResponse = {\n  data: { html_url: string };\n};\n\nexport interface PullRequestCreator {\n  createPullRequest(\n    options: createPullRequest.Options,\n  ): Promise<CreatePullRequestResponse | null>;\n}\n\nexport type PullRequestCreatorConstructor = (\n  octokit: Octokit,\n) => PullRequestCreator;\n\nexport type GithubPullRequestActionInput = {\n  title: string;\n  branchName: string;\n  description: string;\n  owner?: string;\n  repo?: string;\n  repoUrl?: string;\n  host?: string;\n  targetPath?: string;\n  sourcePath?: string;\n};\n\nexport type ClientFactoryInput = {\n  integrations: ScmIntegrationRegistry;\n  host: string;\n  owner: string;\n  repo: string;\n};\n\nexport const defaultClientFactory = async ({\n  integrations,\n  owner,\n  repo,\n  host = 'github.com',\n}: ClientFactoryInput): Promise<PullRequestCreator> => {\n  const integrationConfig = integrations.github.byHost(host)?.config;\n\n  if (!integrationConfig) {\n    throw new InputError(`No integration for host ${host}`);\n  }\n\n  const credentialsProvider = GithubCredentialsProvider.create(\n    integrationConfig,\n  );\n\n  if (!credentialsProvider) {\n    throw new InputError(\n      `No matching credentials for host ${host}, please check your integrations config`,\n    );\n  }\n\n  const { token } = await credentialsProvider.getCredentials({\n    url: `https://${host}/${encodeURIComponent(owner)}/${encodeURIComponent(\n      repo,\n    )}`,\n  });\n\n  if (!token) {\n    throw new InputError(\n      `No token available for host: ${host}, with owner ${owner}, and repo ${repo}`,\n    );\n  }\n\n  const OctokitPR = Octokit.plugin(createPullRequest);\n\n  return new OctokitPR({\n    auth: token,\n    baseUrl: integrationConfig.apiBaseUrl,\n  });\n};\n\ninterface CreateGithubPullRequestActionOptions {\n  integrations: ScmIntegrationRegistry;\n  clientFactory?: (input: ClientFactoryInput) => Promise<PullRequestCreator>;\n}\n\nexport const createPublishGithubPullRequestAction = ({\n  integrations,\n  clientFactory = defaultClientFactory,\n}: CreateGithubPullRequestActionOptions) => {\n  return createTemplateAction<GithubPullRequestActionInput>({\n    id: 'publish:github:pull-request',\n    schema: {\n      input: {\n        required: ['owner', 'repo', 'title', 'description', 'branchName'],\n        type: 'object',\n        properties: {\n          owner: {\n            type: 'string',\n            title: 'Repository owner',\n            description: 'The owner of the target repository',\n          },\n          repo: {\n            type: 'string',\n            title: 'Repository',\n            description: 'The github repository to create the file in',\n          },\n          branchName: {\n            type: 'string',\n            title: 'Branch Name',\n            description: 'The name for the branch',\n          },\n          title: {\n            type: 'string',\n            title: 'Pull Request Name',\n            description: 'The name for the pull request',\n          },\n          description: {\n            type: 'string',\n            title: 'Pull Request Description',\n            description: 'The description of the pull request',\n          },\n          sourcePath: {\n            type: 'string',\n            title: 'Working Subdirectory',\n            description:\n              'Subdirectory of working directory to copy changes from',\n          },\n          targetPath: {\n            type: 'string',\n            title: 'Repository Subdirectory',\n            description: 'Subdirectory of repository to apply changes to',\n          },\n        },\n      },\n      output: {\n        required: ['remoteUrl'],\n        type: 'object',\n        properties: {\n          remoteUrl: {\n            type: 'string',\n            title: 'Pull Request URL',\n            description: 'Link to the pull request in Github',\n          },\n        },\n      },\n    },\n    async handler(ctx) {\n      let { owner, repo } = ctx.input;\n      let host = 'github.com';\n      const {\n        repoUrl,\n        branchName,\n        title,\n        description,\n        targetPath,\n        sourcePath,\n      } = ctx.input;\n\n      if (repoUrl) {\n        const parsed = parseRepoUrl(repoUrl);\n        host = parsed.host;\n        owner = parsed.owner;\n        repo = parsed.repo;\n      }\n\n      if (!host || !owner || !repo) {\n        throw new InputError(\n          'must provide either valid repo URL or owner and repo as parameters',\n        );\n      }\n\n      const client = await clientFactory({ integrations, host, owner, repo });\n      const fileRoot = sourcePath\n        ? path.resolve(ctx.workspacePath, sourcePath)\n        : ctx.workspacePath;\n\n      const localFilePaths = await globby(['./**', './**/.*', '!.git'], {\n        cwd: fileRoot,\n        gitignore: true,\n        dot: true,\n      });\n\n      const fileContents = await Promise.all(\n        localFilePaths.map(p => readFile(path.resolve(fileRoot, p))),\n      );\n\n      const repoFilePaths = localFilePaths.map(repoFilePath => {\n        return targetPath ? `${targetPath}/${repoFilePath}` : repoFilePath;\n      });\n\n      const changes = [\n        {\n          files: zipObject(\n            repoFilePaths,\n            fileContents.map(buf => buf.toString()),\n          ),\n          commit: title,\n        },\n      ];\n\n      try {\n        const response = await client.createPullRequest({\n          owner,\n          repo,\n          title,\n          changes,\n          body: description,\n          head: branchName,\n        });\n\n        if (!response) {\n          throw new GithubResponseError('null response from Github');\n        }\n\n        ctx.output('remoteUrl', response.data.html_url);\n      } catch (e) {\n        throw new GithubResponseError('Pull request creation failed', e);\n      }\n    },\n  });\n};\n","/*\n * Copyright 2021 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { InputError } from '@backstage/errors';\nimport { ScmIntegrationRegistry } from '@backstage/integration';\nimport { initRepoAndPush } from '../../../stages/publish/helpers';\nimport { GitRepositoryCreateOptions } from 'azure-devops-node-api/interfaces/GitInterfaces';\nimport { getPersonalAccessTokenHandler, WebApi } from 'azure-devops-node-api';\nimport { getRepoSourceDirectory, parseRepoUrl } from './util';\nimport { createTemplateAction } from '../../createTemplateAction';\n\nexport function createPublishAzureAction(options: {\n  integrations: ScmIntegrationRegistry;\n}) {\n  const { integrations } = options;\n\n  return createTemplateAction<{\n    repoUrl: string;\n    description?: string;\n    sourcePath?: string;\n  }>({\n    id: 'publish:azure',\n    description:\n      'Initializes a git repository of the content in the workspace, and publishes it to Azure.',\n    schema: {\n      input: {\n        type: 'object',\n        required: ['repoUrl'],\n        properties: {\n          repoUrl: {\n            title: 'Repository Location',\n            type: 'string',\n          },\n          description: {\n            title: 'Repository Description',\n            type: 'string',\n          },\n          sourcePath: {\n            title:\n              'Path within the workspace that will be used as the repository root. If omitted, the entire workspace will be published as the repository.',\n            type: 'string',\n          },\n        },\n      },\n      output: {\n        type: 'object',\n        properties: {\n          remoteUrl: {\n            title: 'A URL to the repository with the provider',\n            type: 'string',\n          },\n          repoContentsUrl: {\n            title: 'A URL to the root of the repository',\n            type: 'string',\n          },\n        },\n      },\n    },\n    async handler(ctx) {\n      const { owner, repo, host, organization } = parseRepoUrl(\n        ctx.input.repoUrl,\n      );\n\n      if (!organization) {\n        throw new InputError(\n          `Invalid URL provider was included in the repo URL to create ${ctx.input.repoUrl}, missing organization`,\n        );\n      }\n\n      const integrationConfig = integrations.azure.byHost(host);\n\n      if (!integrationConfig) {\n        throw new InputError(\n          `No matching integration configuration for host ${host}, please check your integrations config`,\n        );\n      }\n      if (!integrationConfig.config.token) {\n        throw new InputError(`No token provided for Azure Integration ${host}`);\n      }\n      const authHandler = getPersonalAccessTokenHandler(\n        integrationConfig.config.token,\n      );\n\n      const webApi = new WebApi(`https://${host}/${organization}`, authHandler);\n      const client = await webApi.getGitApi();\n      const createOptions: GitRepositoryCreateOptions = { name: repo };\n      const returnedRepo = await client.createRepository(createOptions, owner);\n\n      if (!returnedRepo) {\n        throw new InputError(\n          `Unable to create the repository with Organization ${organization}, Project ${owner} and Repo ${repo}.\n          Please make sure that both the Org and Project are typed corrected and exist.`,\n        );\n      }\n      const remoteUrl = returnedRepo.remoteUrl;\n\n      if (!remoteUrl) {\n        throw new InputError(\n          'No remote URL returned from create repository for Azure',\n        );\n      }\n\n      // blam: Repo contents is serialized into the path,\n      // so it's just the base path I think\n      const repoContentsUrl = remoteUrl;\n\n      await initRepoAndPush({\n        dir: getRepoSourceDirectory(ctx.workspacePath, ctx.input.sourcePath),\n        remoteUrl,\n        auth: {\n          username: 'notempty',\n          password: integrationConfig.config.token,\n        },\n        logger: ctx.logger,\n      });\n\n      ctx.output('remoteUrl', remoteUrl);\n      ctx.output('repoContentsUrl', repoContentsUrl);\n    },\n  });\n}\n","/*\n * Copyright 2021 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { InputError } from '@backstage/errors';\nimport { ScmIntegrationRegistry } from '@backstage/integration';\nimport { Gitlab } from '@gitbeaker/node';\nimport { initRepoAndPush } from '../../../stages/publish/helpers';\nimport { getRepoSourceDirectory, parseRepoUrl } from './util';\nimport { createTemplateAction } from '../../createTemplateAction';\n\nexport function createPublishGitlabAction(options: {\n  integrations: ScmIntegrationRegistry;\n}) {\n  const { integrations } = options;\n\n  return createTemplateAction<{\n    repoUrl: string;\n    repoVisibility: 'private' | 'internal' | 'public';\n    sourcePath?: string;\n  }>({\n    id: 'publish:gitlab',\n    description:\n      'Initializes a git repository of the content in the workspace, and publishes it to GitLab.',\n    schema: {\n      input: {\n        type: 'object',\n        required: ['repoUrl'],\n        properties: {\n          repoUrl: {\n            title: 'Repository Location',\n            type: 'string',\n          },\n          repoVisibility: {\n            title: 'Repository Visibility',\n            type: 'string',\n            enum: ['private', 'public', 'internal'],\n          },\n          sourcePath: {\n            title:\n              'Path within the workspace that will be used as the repository root. If omitted, the entire workspace will be published as the repository.',\n            type: 'string',\n          },\n        },\n      },\n      output: {\n        type: 'object',\n        properties: {\n          remoteUrl: {\n            title: 'A URL to the repository with the provider',\n            type: 'string',\n          },\n          repoContentsUrl: {\n            title: 'A URL to the root of the repository',\n            type: 'string',\n          },\n        },\n      },\n    },\n    async handler(ctx) {\n      const { repoUrl, repoVisibility = 'private' } = ctx.input;\n\n      const { owner, repo, host } = parseRepoUrl(repoUrl);\n\n      const integrationConfig = integrations.gitlab.byHost(host);\n\n      if (!integrationConfig) {\n        throw new InputError(\n          `No matching integration configuration for host ${host}, please check your integrations config`,\n        );\n      }\n\n      if (!integrationConfig.config.token) {\n        throw new InputError(`No token available for host ${host}`);\n      }\n\n      const client = new Gitlab({\n        host: integrationConfig.config.baseUrl,\n        token: integrationConfig.config.token,\n      });\n\n      let { id: targetNamespace } = (await client.Namespaces.show(owner)) as {\n        id: number;\n      };\n\n      if (!targetNamespace) {\n        const { id } = (await client.Users.current()) as {\n          id: number;\n        };\n        targetNamespace = id;\n      }\n\n      const { http_url_to_repo } = await client.Projects.create({\n        namespace_id: targetNamespace,\n        name: repo,\n        visibility: repoVisibility,\n      });\n\n      const remoteUrl = (http_url_to_repo as string).replace(/\\.git$/, '');\n      const repoContentsUrl = `${remoteUrl}/-/blob/master`;\n\n      await initRepoAndPush({\n        dir: getRepoSourceDirectory(ctx.workspacePath, ctx.input.sourcePath),\n        remoteUrl: http_url_to_repo as string,\n        auth: {\n          username: 'oauth2',\n          password: integrationConfig.config.token,\n        },\n        logger: ctx.logger,\n      });\n\n      ctx.output('remoteUrl', remoteUrl);\n      ctx.output('repoContentsUrl', repoContentsUrl);\n    },\n  });\n}\n","/*\n * Copyright 2021 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { InputError } from '@backstage/errors';\nimport {\n  BitbucketIntegrationConfig,\n  ScmIntegrationRegistry,\n} from '@backstage/integration';\nimport { initRepoAndPush } from '../../../stages/publish/helpers';\nimport { getRepoSourceDirectory, parseRepoUrl } from './util';\nimport fetch from 'cross-fetch';\nimport { createTemplateAction } from '../../createTemplateAction';\n\nconst createBitbucketCloudRepository = async (opts: {\n  owner: string;\n  repo: string;\n  description: string;\n  repoVisibility: 'private' | 'public';\n  authorization: string;\n}) => {\n  const { owner, repo, description, repoVisibility, authorization } = opts;\n\n  const options: RequestInit = {\n    method: 'POST',\n    body: JSON.stringify({\n      scm: 'git',\n      description: description,\n      is_private: repoVisibility === 'private',\n    }),\n    headers: {\n      Authorization: authorization,\n      'Content-Type': 'application/json',\n    },\n  };\n\n  let response: Response;\n  try {\n    response = await fetch(\n      `https://api.bitbucket.org/2.0/repositories/${owner}/${repo}`,\n      options,\n    );\n  } catch (e) {\n    throw new Error(`Unable to create repository, ${e}`);\n  }\n\n  if (response.status !== 200) {\n    throw new Error(\n      `Unable to create repository, ${response.status} ${\n        response.statusText\n      }, ${await response.text()}`,\n    );\n  }\n\n  const r = await response.json();\n  let remoteUrl = '';\n  for (const link of r.links.clone) {\n    if (link.name === 'https') {\n      remoteUrl = link.href;\n    }\n  }\n\n  // TODO use the urlReader to get the default branch\n  const repoContentsUrl = `${r.links.html.href}/src/master`;\n  return { remoteUrl, repoContentsUrl };\n};\n\nconst createBitbucketServerRepository = async (opts: {\n  host: string;\n  owner: string;\n  repo: string;\n  description: string;\n  repoVisibility: 'private' | 'public';\n  authorization: string;\n}) => {\n  const {\n    host,\n    owner,\n    repo,\n    description,\n    authorization,\n    repoVisibility,\n  } = opts;\n\n  let response: Response;\n  const options: RequestInit = {\n    method: 'POST',\n    body: JSON.stringify({\n      name: repo,\n      description: description,\n      is_private: repoVisibility === 'private',\n    }),\n    headers: {\n      Authorization: authorization,\n      'Content-Type': 'application/json',\n    },\n  };\n\n  try {\n    response = await fetch(\n      `https://${host}/rest/api/1.0/projects/${owner}/repos`,\n      options,\n    );\n  } catch (e) {\n    throw new Error(`Unable to create repository, ${e}`);\n  }\n\n  if (response.status !== 201) {\n    throw new Error(\n      `Unable to create repository, ${response.status} ${\n        response.statusText\n      }, ${await response.text()}`,\n    );\n  }\n\n  const r = await response.json();\n  let remoteUrl = '';\n  for (const link of r.links.clone) {\n    if (link.name === 'http') {\n      remoteUrl = link.href;\n    }\n  }\n\n  const repoContentsUrl = `${r.links.self[0].href}`;\n  return { remoteUrl, repoContentsUrl };\n};\n\nconst getAuthorizationHeader = (config: BitbucketIntegrationConfig) => {\n  if (config.username && config.appPassword) {\n    const buffer = Buffer.from(\n      `${config.username}:${config.appPassword}`,\n      'utf8',\n    );\n\n    return `Basic ${buffer.toString('base64')}`;\n  }\n\n  if (config.token) {\n    return `Bearer ${config.token}`;\n  }\n\n  throw new Error(\n    `Authorization has not been provided for Bitbucket. Please add either username + appPassword or token to the Integrations config`,\n  );\n};\n\nexport function createPublishBitbucketAction(options: {\n  integrations: ScmIntegrationRegistry;\n}) {\n  const { integrations } = options;\n\n  return createTemplateAction<{\n    repoUrl: string;\n    description: string;\n    repoVisibility: 'private' | 'public';\n    sourcePath?: string;\n  }>({\n    id: 'publish:bitbucket',\n    description:\n      'Initializes a git repository of the content in the workspace, and publishes it to Bitbucket.',\n    schema: {\n      input: {\n        type: 'object',\n        required: ['repoUrl'],\n        properties: {\n          repoUrl: {\n            title: 'Repository Location',\n            type: 'string',\n          },\n          description: {\n            title: 'Repository Description',\n            type: 'string',\n          },\n          repoVisibility: {\n            title: 'Repository Visibility',\n            type: 'string',\n            enum: ['private', 'public'],\n          },\n          sourcePath: {\n            title:\n              'Path within the workspace that will be used as the repository root. If omitted, the entire workspace will be published as the repository.',\n            type: 'string',\n          },\n        },\n      },\n      output: {\n        type: 'object',\n        properties: {\n          remoteUrl: {\n            title: 'A URL to the repository with the provider',\n            type: 'string',\n          },\n          repoContentsUrl: {\n            title: 'A URL to the root of the repository',\n            type: 'string',\n          },\n        },\n      },\n    },\n    async handler(ctx) {\n      const { repoUrl, description, repoVisibility = 'private' } = ctx.input;\n\n      const { owner, repo, host } = parseRepoUrl(repoUrl);\n\n      const integrationConfig = integrations.bitbucket.byHost(host);\n\n      if (!integrationConfig) {\n        throw new InputError(\n          `No matching integration configuration for host ${host}, please check your integrations config`,\n        );\n      }\n\n      const authorization = getAuthorizationHeader(integrationConfig.config);\n\n      const createMethod =\n        host === 'bitbucket.org'\n          ? createBitbucketCloudRepository\n          : createBitbucketServerRepository;\n\n      const { remoteUrl, repoContentsUrl } = await createMethod({\n        authorization,\n        host,\n        owner,\n        repo,\n        repoVisibility,\n        description,\n      });\n\n      await initRepoAndPush({\n        dir: getRepoSourceDirectory(ctx.workspacePath, ctx.input.sourcePath),\n        remoteUrl,\n        auth: {\n          username: integrationConfig.config.username\n            ? integrationConfig.config.username\n            : 'x-token-auth',\n          password: integrationConfig.config.appPassword\n            ? integrationConfig.config.appPassword\n            : integrationConfig.config.token ?? '',\n        },\n        logger: ctx.logger,\n      });\n\n      ctx.output('remoteUrl', remoteUrl);\n      ctx.output('repoContentsUrl', repoContentsUrl);\n    },\n  });\n}\n","/*\n * Copyright 2021 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from 'fs-extra';\nimport { dirname } from 'path';\nimport { InputError } from '@backstage/errors';\nimport { createTemplateAction } from '../../createTemplateAction';\n\n/**\n * This task is useful for local development and testing of both the scaffolder\n * and scaffolder templates.\n *\n * This action is not installed by default and should not be installed in\n * production, as it writes the files to the local filesystem of the scaffolder.\n */\nexport function createPublishFileAction() {\n  return createTemplateAction<{ path: string }>({\n    id: 'publish:file',\n    description: 'Writes contents of the workspace to a local directory',\n    schema: {\n      input: {\n        type: 'object',\n        required: ['path'],\n        properties: {\n          path: {\n            title: 'Path to a directory where the output will be written',\n            type: 'string',\n          },\n        },\n      },\n    },\n    async handler(ctx) {\n      const { path } = ctx.input;\n\n      const exists = await fs.pathExists(path);\n      if (exists) {\n        throw new InputError('Output path already exists');\n      }\n      await fs.ensureDir(dirname(path));\n      await fs.copy(ctx.workspacePath, path);\n    },\n  });\n}\n","/*\n * Copyright 2021 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { UrlReader } from '@backstage/backend-common';\nimport { CatalogApi } from '@backstage/catalog-client';\nimport { ScmIntegrations } from '@backstage/integration';\nimport { TemplaterBuilder } from '../../stages';\nimport { createCatalogRegisterAction } from './catalog';\nimport { createFetchCookiecutterAction, createFetchPlainAction } from './fetch';\nimport {\n  createPublishAzureAction,\n  createPublishBitbucketAction,\n  createPublishGithubAction,\n  createPublishGithubPullRequestAction,\n  createPublishGitlabAction,\n} from './publish';\n\nexport const createBuiltinActions = (options: {\n  reader: UrlReader;\n  integrations: ScmIntegrations;\n  catalogClient: CatalogApi;\n  templaters: TemplaterBuilder;\n}) => {\n  const { reader, integrations, templaters, catalogClient } = options;\n\n  return [\n    createFetchPlainAction({\n      reader,\n      integrations,\n    }),\n    createFetchCookiecutterAction({\n      reader,\n      integrations,\n      templaters,\n    }),\n    createPublishGithubAction({\n      integrations,\n    }),\n    createPublishGithubPullRequestAction({\n      integrations,\n    }),\n    createPublishGitlabAction({\n      integrations,\n    }),\n    createPublishBitbucketAction({\n      integrations,\n    }),\n    createPublishAzureAction({\n      integrations,\n    }),\n    createCatalogRegisterAction({ catalogClient, integrations }),\n  ];\n};\n","/*\n * Copyright 2021 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { InputBase, TemplateAction } from './types';\nimport { ConflictError, NotFoundError } from '@backstage/errors';\n\nexport class TemplateActionRegistry {\n  private readonly actions = new Map<string, TemplateAction<any>>();\n\n  register<Parameters extends InputBase>(action: TemplateAction<Parameters>) {\n    if (this.actions.has(action.id)) {\n      throw new ConflictError(\n        `Template action with ID '${action.id}' has already been registered`,\n      );\n    }\n    this.actions.set(action.id, action);\n  }\n\n  get(actionId: string): TemplateAction<any> {\n    const action = this.actions.get(actionId);\n    if (!action) {\n      throw new NotFoundError(\n        `Template action with ID '${actionId}' is not registered.`,\n      );\n    }\n    return action;\n  }\n\n  list(): TemplateAction<any>[] {\n    return [...this.actions.values()];\n  }\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport fs from 'fs-extra';\nimport path from 'path';\nimport { Git } from '@backstage/backend-common';\nimport { PreparerBase, PreparerOptions } from './types';\nimport parseGitUrl from 'git-url-parse';\nimport { AzureIntegrationConfig } from '@backstage/integration';\n\nexport class AzurePreparer implements PreparerBase {\n  static fromConfig(config: AzureIntegrationConfig) {\n    return new AzurePreparer({ token: config.token });\n  }\n\n  constructor(private readonly config: { token?: string }) {}\n\n  async prepare({ url, workspacePath, logger }: PreparerOptions) {\n    const parsedGitUrl = parseGitUrl(url);\n    const checkoutPath = path.join(workspacePath, 'checkout');\n    const targetPath = path.join(workspacePath, 'template');\n    const fullPathToTemplate = path.resolve(\n      checkoutPath,\n      parsedGitUrl.filepath ?? '',\n    );\n\n    // Username can be anything but the empty string according to:\n    // https://docs.microsoft.com/en-us/azure/devops/organizations/accounts/use-personal-access-tokens-to-authenticate?view=azure-devops&tabs=preview-page#use-a-pat\n    const git = this.config.token\n      ? Git.fromAuth({\n          password: this.config.token,\n          username: 'notempty',\n          logger,\n        })\n      : Git.fromAuth({ logger });\n\n    await git.clone({\n      url: parsedGitUrl.toString('https'),\n      ref: parsedGitUrl.ref,\n      dir: checkoutPath,\n    });\n\n    await fs.move(fullPathToTemplate, targetPath);\n\n    try {\n      await fs.rmdir(path.join(targetPath, '.git'));\n    } catch {\n      // Ignore intentionally\n    }\n  }\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport fs from 'fs-extra';\nimport path from 'path';\nimport { Git } from '@backstage/backend-common';\nimport { PreparerBase, PreparerOptions } from './types';\nimport { BitbucketIntegrationConfig } from '@backstage/integration';\nimport parseGitUrl from 'git-url-parse';\n\nexport class BitbucketPreparer implements PreparerBase {\n  static fromConfig(config: BitbucketIntegrationConfig) {\n    return new BitbucketPreparer({\n      username: config.username,\n      token: config.token,\n      appPassword: config.appPassword,\n    });\n  }\n\n  constructor(\n    private readonly config: {\n      username?: string;\n      token?: string;\n      appPassword?: string;\n    },\n  ) {}\n\n  async prepare({ url, workspacePath, logger }: PreparerOptions) {\n    const parsedGitUrl = parseGitUrl(url);\n    const checkoutPath = path.join(workspacePath, 'checkout');\n    const targetPath = path.join(workspacePath, 'template');\n    const fullPathToTemplate = path.resolve(\n      checkoutPath,\n      parsedGitUrl.filepath ?? '',\n    );\n\n    const git = Git.fromAuth({ logger, ...this.getAuth() });\n\n    await git.clone({\n      url: parsedGitUrl.toString('https'),\n      dir: checkoutPath,\n      ref: parsedGitUrl.ref,\n    });\n\n    await fs.move(fullPathToTemplate, targetPath);\n\n    try {\n      await fs.rmdir(path.join(targetPath, '.git'));\n    } catch {\n      // Ignore intentionally\n    }\n  }\n\n  private getAuth(): { username: string; password: string } | undefined {\n    const { username, token, appPassword } = this.config;\n\n    if (username && appPassword) {\n      return { username: username, password: appPassword };\n    }\n\n    if (token) {\n      return {\n        username: 'x-token-auth',\n        password: token! || appPassword!,\n      };\n    }\n\n    return undefined;\n  }\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport fs from 'fs-extra';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\nimport { InputError } from '@backstage/errors';\nimport { PreparerBase, PreparerOptions } from './types';\n\nexport class FilePreparer implements PreparerBase {\n  async prepare({ url, workspacePath }: PreparerOptions) {\n    if (!url.startsWith('file://')) {\n      throw new InputError(`Wrong location protocol, should be 'file', ${url}`);\n    }\n\n    const templatePath = fileURLToPath(url);\n\n    const targetDir = path.join(workspacePath, 'template');\n    await fs.ensureDir(targetDir);\n\n    await fs.copy(templatePath, targetDir, {\n      recursive: true,\n    });\n  }\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport fs from 'fs-extra';\nimport path from 'path';\nimport { Git } from '@backstage/backend-common';\nimport { PreparerBase, PreparerOptions } from './types';\nimport parseGitUrl from 'git-url-parse';\nimport {\n  GitHubIntegrationConfig,\n  GithubCredentialsProvider,\n} from '@backstage/integration';\n\nexport class GithubPreparer implements PreparerBase {\n  static fromConfig(config: GitHubIntegrationConfig) {\n    const credentialsProvider = GithubCredentialsProvider.create(config);\n    return new GithubPreparer({ credentialsProvider });\n  }\n\n  constructor(\n    private readonly config: { credentialsProvider: GithubCredentialsProvider },\n  ) {}\n\n  async prepare({ url, workspacePath, logger }: PreparerOptions) {\n    const parsedGitUrl = parseGitUrl(url);\n    const checkoutPath = path.join(workspacePath, 'checkout');\n    const targetPath = path.join(workspacePath, 'template');\n    const fullPathToTemplate = path.resolve(\n      checkoutPath,\n      parsedGitUrl.filepath ?? '',\n    );\n\n    const { token } = await this.config.credentialsProvider.getCredentials({\n      url,\n    });\n\n    const git = token\n      ? Git.fromAuth({\n          username: 'x-access-token',\n          password: token,\n          logger,\n        })\n      : Git.fromAuth({ logger });\n\n    await git.clone({\n      url: parsedGitUrl.toString('https'),\n      dir: checkoutPath,\n      ref: parsedGitUrl.ref,\n    });\n\n    await fs.move(fullPathToTemplate, targetPath);\n\n    try {\n      await fs.rmdir(path.join(targetPath, '.git'));\n    } catch {\n      // Ignore intentionally\n    }\n  }\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Git } from '@backstage/backend-common';\nimport { GitLabIntegrationConfig } from '@backstage/integration';\nimport fs from 'fs-extra';\nimport parseGitUrl from 'git-url-parse';\nimport path from 'path';\nimport { PreparerBase, PreparerOptions } from './types';\n\nexport class GitlabPreparer implements PreparerBase {\n  static fromConfig(config: GitLabIntegrationConfig) {\n    return new GitlabPreparer({ token: config.token });\n  }\n\n  constructor(private readonly config: { token?: string }) {}\n\n  async prepare({ url, workspacePath, logger }: PreparerOptions) {\n    const parsedGitUrl = parseGitUrl(url);\n    const checkoutPath = path.join(workspacePath, 'checkout');\n    const targetPath = path.join(workspacePath, 'template');\n    const fullPathToTemplate = path.resolve(\n      checkoutPath,\n      parsedGitUrl.filepath ?? '',\n    );\n    parsedGitUrl.git_suffix = true;\n\n    const git = this.config.token\n      ? Git.fromAuth({\n          password: this.config.token,\n          username: 'oauth2',\n          logger,\n        })\n      : Git.fromAuth({ logger });\n\n    await git.clone({\n      url: parsedGitUrl.toString('https'),\n      dir: checkoutPath,\n      ref: parsedGitUrl.ref,\n    });\n\n    await fs.move(fullPathToTemplate, targetPath);\n\n    try {\n      await fs.rmdir(path.join(targetPath, '.git'));\n    } catch {\n      // Ignore intentionally\n    }\n  }\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Config } from '@backstage/config';\nimport { PreparerBase, PreparerBuilder } from './types';\nimport { Logger } from 'winston';\n\nimport { GitlabPreparer } from './gitlab';\nimport { AzurePreparer } from './azure';\nimport { GithubPreparer } from './github';\nimport { BitbucketPreparer } from './bitbucket';\nimport { ScmIntegrations } from '@backstage/integration';\n\nexport class Preparers implements PreparerBuilder {\n  private preparerMap = new Map<string, PreparerBase>();\n\n  register(host: string, preparer: PreparerBase) {\n    this.preparerMap.set(host, preparer);\n  }\n\n  get(url: string): PreparerBase {\n    const preparer = this.preparerMap.get(new URL(url).host);\n    if (!preparer) {\n      throw new Error(\n        `Unable to find a preparer for URL: ${url}. Please make sure to register this host under an integration in app-config`,\n      );\n    }\n    return preparer;\n  }\n\n  static async fromConfig(\n    config: Config,\n    // eslint-disable-next-line\n    _: { logger: Logger },\n  ): Promise<PreparerBuilder> {\n    const preparers = new Preparers();\n    const scm = ScmIntegrations.fromConfig(config);\n    for (const integration of scm.azure.list()) {\n      preparers.register(\n        integration.config.host,\n        AzurePreparer.fromConfig(integration.config),\n      );\n    }\n\n    for (const integration of scm.github.list()) {\n      preparers.register(\n        integration.config.host,\n        GithubPreparer.fromConfig(integration.config),\n      );\n    }\n\n    for (const integration of scm.gitlab.list()) {\n      preparers.register(\n        integration.config.host,\n        GitlabPreparer.fromConfig(integration.config),\n      );\n    }\n\n    for (const integration of scm.bitbucket.list()) {\n      preparers.register(\n        integration.config.host,\n        BitbucketPreparer.fromConfig(integration.config),\n      );\n    }\n\n    return preparers;\n  }\n}\n","/*\n * Copyright 2021 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createTemplateAction } from '../actions';\nimport { FilePreparer, PreparerBuilder } from './prepare';\nimport { PublisherBuilder } from './publish';\nimport { TemplaterBuilder, TemplaterValues } from './templater';\n\ntype Options = {\n  preparers: PreparerBuilder;\n  templaters: TemplaterBuilder;\n  publishers: PublisherBuilder;\n};\n\nexport function createLegacyActions(options: Options) {\n  const { preparers, templaters, publishers } = options;\n\n  return [\n    createTemplateAction({\n      id: 'legacy:prepare',\n      async handler(ctx) {\n        ctx.logger.info('Preparing the skeleton');\n        const { protocol, url } = ctx.input;\n        const preparer =\n          protocol === 'file'\n            ? new FilePreparer()\n            : preparers.get(url as string);\n\n        await preparer.prepare({\n          url: url as string,\n          logger: ctx.logger,\n          workspacePath: ctx.workspacePath,\n        });\n      },\n    }),\n    createTemplateAction({\n      id: 'legacy:template',\n      async handler(ctx) {\n        ctx.logger.info('Running the templater');\n        const templater = templaters.get(ctx.input.templater as string);\n        await templater.run({\n          workspacePath: ctx.workspacePath,\n          logStream: ctx.logStream,\n          values: ctx.input.values as TemplaterValues,\n        });\n      },\n    }),\n    createTemplateAction({\n      id: 'legacy:publish',\n      async handler(ctx) {\n        const { values } = ctx.input;\n        if (\n          typeof values !== 'object' ||\n          values === null ||\n          Array.isArray(values)\n        ) {\n          throw new Error(\n            `Invalid values passed to publish, got ${typeof values}`,\n          );\n        }\n        const storePath = values.storePath as unknown;\n        if (typeof storePath !== 'string') {\n          throw new Error(\n            `Invalid store path passed to publish, got ${typeof storePath}`,\n          );\n        }\n        const owner = values.owner as unknown;\n        if (typeof owner !== 'string') {\n          throw new Error(\n            `Invalid owner passed to publish, got ${typeof owner}`,\n          );\n        }\n\n        const publisher = publishers.get(storePath);\n        ctx.logger.info('Will now store the template');\n        const { remoteUrl, catalogInfoUrl } = await publisher.publish({\n          values: {\n            ...values,\n            owner,\n            storePath,\n          },\n          workspacePath: ctx.workspacePath,\n          logger: ctx.logger,\n        });\n        ctx.output('remoteUrl', remoteUrl);\n        if (catalogInfoUrl) {\n          ctx.output('catalogInfoUrl', catalogInfoUrl);\n        }\n      },\n    }),\n  ];\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { PublisherBase, PublisherOptions, PublisherResult } from './types';\nimport { IGitApi } from 'azure-devops-node-api/GitApi';\nimport { GitRepositoryCreateOptions } from 'azure-devops-node-api/interfaces/GitInterfaces';\nimport { initRepoAndPush } from './helpers';\nimport { AzureIntegrationConfig } from '@backstage/integration';\nimport parseGitUrl from 'git-url-parse';\nimport { getPersonalAccessTokenHandler, WebApi } from 'azure-devops-node-api';\nimport path from 'path';\n\nexport class AzurePublisher implements PublisherBase {\n  static async fromConfig(config: AzureIntegrationConfig) {\n    if (!config.token) {\n      return undefined;\n    }\n    return new AzurePublisher({ token: config.token });\n  }\n\n  constructor(private readonly config: { token: string }) {}\n\n  async publish({\n    values,\n    workspacePath,\n    logger,\n  }: PublisherOptions): Promise<PublisherResult> {\n    const { owner, name, organization, resource } = parseGitUrl(\n      values.storePath,\n    );\n    const authHandler = getPersonalAccessTokenHandler(this.config.token);\n    const webApi = new WebApi(\n      `https://${resource}/${organization}`,\n      authHandler,\n    );\n    const client = await webApi.getGitApi();\n\n    const remoteUrl = await this.createRemote({\n      project: owner,\n      name,\n      client,\n    });\n\n    const catalogInfoUrl = `${remoteUrl}?path=%2Fcatalog-info.yaml`;\n\n    await initRepoAndPush({\n      dir: path.join(workspacePath, 'result'),\n      remoteUrl,\n      auth: {\n        username: 'notempty',\n        password: this.config.token,\n      },\n      logger,\n    });\n\n    return { remoteUrl, catalogInfoUrl };\n  }\n\n  private async createRemote(opts: {\n    name: string;\n    project: string;\n    client: IGitApi;\n  }) {\n    const { name, project, client } = opts;\n    const createOptions: GitRepositoryCreateOptions = { name };\n    const repo = await client.createRepository(createOptions, project);\n\n    return repo.remoteUrl || '';\n  }\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { PublisherBase, PublisherOptions, PublisherResult } from './types';\nimport { initRepoAndPush } from './helpers';\nimport fetch from 'cross-fetch';\nimport { BitbucketIntegrationConfig } from '@backstage/integration';\nimport parseGitUrl from 'git-url-parse';\nimport path from 'path';\n\nexport type RepoVisibilityOptions = 'private' | 'public';\n\n// TODO(blam): We should probably start to use a bitbucket client here that we can change\n// the baseURL to point at on-prem or public bitbucket versions like we do for\n// github and ghe. There's to much logic and not enough types here for us to say that this way is better than using\n// a supported bitbucket client if one exists.\nexport class BitbucketPublisher implements PublisherBase {\n  static async fromConfig(\n    config: BitbucketIntegrationConfig,\n    { repoVisibility }: { repoVisibility: RepoVisibilityOptions },\n  ) {\n    if (config.host !== 'bitbucket.org' && !config.username)\n      throw new Error(\n        'Bitbucket server requires the username to be set in your config',\n      );\n\n    return new BitbucketPublisher({\n      host: config.host,\n      token: config.token,\n      appPassword: config.appPassword,\n      username: config.username,\n      apiBaseUrl: config.apiBaseUrl,\n      repoVisibility,\n    });\n  }\n\n  constructor(\n    private readonly config: {\n      host: string;\n      token?: string;\n      appPassword?: string;\n      username?: string;\n      apiBaseUrl?: string;\n      repoVisibility: RepoVisibilityOptions;\n    },\n  ) {}\n\n  async publish({\n    values,\n    workspacePath,\n    logger,\n  }: PublisherOptions): Promise<PublisherResult> {\n    const { owner: project, name } = parseGitUrl(values.storePath);\n\n    const description = values.description as string;\n    const result = await this.createRemote({\n      project,\n      name,\n      description,\n    });\n\n    await initRepoAndPush({\n      dir: path.join(workspacePath, 'result'),\n      remoteUrl: result.remoteUrl,\n      auth: {\n        username: this.config.username ? this.config.username : 'x-token-auth',\n        password: this.config.appPassword\n          ? this.config.appPassword\n          : this.config.token ?? '',\n      },\n      logger,\n    });\n    return result;\n  }\n\n  private async createRemote(opts: {\n    project: string;\n    name: string;\n    description: string;\n  }): Promise<PublisherResult> {\n    if (this.config.host === 'bitbucket.org') {\n      return this.createBitbucketCloudRepository(opts);\n    }\n    return this.createBitbucketServerRepository(opts);\n  }\n\n  private async createBitbucketCloudRepository(opts: {\n    project: string;\n    name: string;\n    description: string;\n  }): Promise<PublisherResult> {\n    const { project, name, description } = opts;\n\n    let response: Response;\n\n    const options: RequestInit = {\n      method: 'POST',\n      body: JSON.stringify({\n        scm: 'git',\n        description: description,\n        is_private: this.config.repoVisibility === 'private',\n      }),\n      headers: {\n        Authorization: this.getAuthorizationHeader(),\n        'Content-Type': 'application/json',\n      },\n    };\n    try {\n      response = await fetch(\n        `https://api.bitbucket.org/2.0/repositories/${project}/${name}`,\n        options,\n      );\n    } catch (e) {\n      throw new Error(`Unable to create repository, ${e}`);\n    }\n    if (response.status === 200) {\n      const r = await response.json();\n      let remoteUrl = '';\n      for (const link of r.links.clone) {\n        if (link.name === 'https') {\n          remoteUrl = link.href;\n        }\n      }\n\n      // TODO use the urlReader to get the default branch\n      const catalogInfoUrl = `${r.links.html.href}/src/master/catalog-info.yaml`;\n      return { remoteUrl, catalogInfoUrl };\n    }\n    throw new Error(`Not a valid response code ${await response.text()}`);\n  }\n\n  private getAuthorizationHeader(): string {\n    if (this.config.username && this.config.appPassword) {\n      const buffer = Buffer.from(\n        `${this.config.username}:${this.config.appPassword}`,\n        'utf8',\n      );\n\n      return `Basic ${buffer.toString('base64')}`;\n    }\n\n    if (this.config.token) {\n      return `Bearer ${this.config.token}`;\n    }\n\n    throw new Error(\n      `Authorization has not been provided for Bitbucket. Please add either username + appPassword or token to the Integrations config`,\n    );\n  }\n\n  private async createBitbucketServerRepository(opts: {\n    project: string;\n    name: string;\n    description: string;\n  }): Promise<PublisherResult> {\n    const { project, name, description } = opts;\n\n    let response: Response;\n    const options: RequestInit = {\n      method: 'POST',\n      body: JSON.stringify({\n        name: name,\n        description: description,\n        is_private: this.config.repoVisibility === 'private',\n      }),\n      headers: {\n        Authorization: this.getAuthorizationHeader(),\n        'Content-Type': 'application/json',\n      },\n    };\n\n    try {\n      const baseUrl = this.config.apiBaseUrl\n        ? this.config.apiBaseUrl\n        : `https://${this.config.host}/rest/api/1.0`;\n\n      response = await fetch(`${baseUrl}/projects/${project}/repos`, options);\n    } catch (e) {\n      throw new Error(`Unable to create repository, ${e}`);\n    }\n    if (response.status === 201) {\n      const r = await response.json();\n      let remoteUrl = '';\n      for (const link of r.links.clone) {\n        if (link.name === 'http') {\n          remoteUrl = link.href;\n        }\n      }\n      const catalogInfoUrl = `${r.links.self[0].href}/catalog-info.yaml`;\n      return { remoteUrl, catalogInfoUrl };\n    }\n    throw new Error(`Not a valid response code ${await response.text()}`);\n  }\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { PublisherBase, PublisherOptions, PublisherResult } from './types';\nimport {\n  enableBranchProtectionOnDefaultRepoBranch,\n  initRepoAndPush,\n} from './helpers';\nimport {\n  GitHubIntegrationConfig,\n  GithubCredentialsProvider,\n} from '@backstage/integration';\nimport parseGitUrl from 'git-url-parse';\nimport { Octokit } from '@octokit/rest';\nimport path from 'path';\n\nexport type RepoVisibilityOptions = 'private' | 'internal' | 'public';\n\n/** @deprecated use createPublishGithubAction instead */\nexport class GithubPublisher implements PublisherBase {\n  static async fromConfig(\n    config: GitHubIntegrationConfig,\n    { repoVisibility }: { repoVisibility: RepoVisibilityOptions },\n  ) {\n    if (!config.token && !config.apps) {\n      return undefined;\n    }\n\n    const credentialsProvider = GithubCredentialsProvider.create(config);\n\n    return new GithubPublisher({\n      credentialsProvider,\n      repoVisibility,\n      apiBaseUrl: config.apiBaseUrl,\n    });\n  }\n\n  constructor(\n    private readonly config: {\n      credentialsProvider: GithubCredentialsProvider;\n      repoVisibility: RepoVisibilityOptions;\n      apiBaseUrl: string | undefined;\n    },\n  ) {}\n\n  async publish({\n    values,\n    workspacePath,\n    logger,\n  }: PublisherOptions): Promise<PublisherResult> {\n    const { owner, name } = parseGitUrl(values.storePath);\n\n    const { token } = await this.config.credentialsProvider.getCredentials({\n      url: values.storePath,\n    });\n\n    if (!token) {\n      throw new Error(\n        `No token could be acquired for URL: ${values.storePath}`,\n      );\n    }\n\n    const client = new Octokit({\n      auth: token,\n      baseUrl: this.config.apiBaseUrl,\n      previews: ['nebula-preview'],\n    });\n\n    const description = values.description as string;\n    const access = values.access as string;\n    const remoteUrl = await this.createRemote({\n      client,\n      description,\n      access,\n      name,\n      owner,\n    });\n\n    await initRepoAndPush({\n      dir: path.join(workspacePath, 'result'),\n      remoteUrl,\n      auth: {\n        username: 'x-access-token',\n        password: token,\n      },\n      logger,\n    });\n\n    const catalogInfoUrl = remoteUrl.replace(\n      /\\.git$/,\n      '/blob/master/catalog-info.yaml',\n    );\n\n    try {\n      await enableBranchProtectionOnDefaultRepoBranch({\n        owner,\n        client,\n        repoName: name,\n        logger,\n      });\n    } catch (e) {\n      throw new Error(`Failed to add branch protection to '${name}', ${e}`);\n    }\n\n    return { remoteUrl, catalogInfoUrl };\n  }\n\n  private async createRemote(opts: {\n    client: Octokit;\n    access: string;\n    name: string;\n    owner: string;\n    description: string;\n  }) {\n    const { client, access, description, owner, name } = opts;\n\n    const user = await client.users.getByUsername({\n      username: owner,\n    });\n\n    const repoCreationPromise =\n      user.data.type === 'Organization'\n        ? client.repos.createInOrg({\n            name,\n            org: owner,\n            private: this.config.repoVisibility !== 'public',\n            visibility: this.config.repoVisibility,\n            description,\n          })\n        : client.repos.createForAuthenticatedUser({\n            name,\n            private: this.config.repoVisibility === 'private',\n            description,\n          });\n\n    const { data: newRepo } = await repoCreationPromise;\n\n    try {\n      if (access?.startsWith(`${owner}/`)) {\n        const [, team] = access.split('/');\n        await client.teams.addOrUpdateRepoPermissionsInOrg({\n          org: owner,\n          team_slug: team,\n          owner,\n          repo: name,\n          permission: 'admin',\n        });\n        // no need to add access if it's the person who owns the personal account\n      } else if (access && access !== owner) {\n        await client.repos.addCollaborator({\n          owner,\n          repo: name,\n          username: access,\n          permission: 'admin',\n        });\n      }\n    } catch (e) {\n      throw new Error(\n        `Failed to add access to '${access}'. Status ${e.status} ${e.message}`,\n      );\n    }\n\n    return newRepo.clone_url;\n  }\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { PublisherBase, PublisherOptions, PublisherResult } from './types';\nimport { Gitlab } from '@gitbeaker/node';\nimport { Gitlab as GitlabClient } from '@gitbeaker/core';\nimport { initRepoAndPush } from './helpers';\nimport parseGitUrl from 'git-url-parse';\nimport path from 'path';\nimport { GitLabIntegrationConfig } from '@backstage/integration';\n\nexport type RepoVisibilityOptions = 'private' | 'internal' | 'public';\n\nexport class GitlabPublisher implements PublisherBase {\n  static async fromConfig(\n    config: GitLabIntegrationConfig,\n    { repoVisibility }: { repoVisibility: RepoVisibilityOptions },\n  ) {\n    if (!config.token) {\n      return undefined;\n    }\n\n    const client = new Gitlab({ host: config.baseUrl, token: config.token });\n    return new GitlabPublisher({\n      token: config.token,\n      client,\n      repoVisibility,\n    });\n  }\n\n  constructor(\n    private readonly config: {\n      token: string;\n      client: GitlabClient;\n      repoVisibility: RepoVisibilityOptions;\n    },\n  ) {}\n\n  async publish({\n    values,\n    workspacePath,\n    logger,\n  }: PublisherOptions): Promise<PublisherResult> {\n    const { owner, name } = parseGitUrl(values.storePath);\n\n    const remoteUrl = await this.createRemote({\n      owner,\n      name,\n    });\n\n    await initRepoAndPush({\n      dir: path.join(workspacePath, 'result'),\n      remoteUrl,\n      auth: {\n        username: 'oauth2',\n        password: this.config.token,\n      },\n      logger,\n    });\n\n    const catalogInfoUrl = remoteUrl.replace(\n      /\\.git$/,\n      '/-/blob/master/catalog-info.yaml',\n    );\n    return { remoteUrl, catalogInfoUrl };\n  }\n\n  private async createRemote(opts: { name: string; owner: string }) {\n    const { owner, name } = opts;\n\n    // TODO(blam): this needs cleaning up to be nicer. The amount of brackets is too damn high!\n    // Shouldn't have to cast things now\n    let targetNamespace = ((await this.config.client.Namespaces.show(\n      owner,\n    )) as {\n      id: number;\n    }).id;\n\n    if (!targetNamespace) {\n      targetNamespace = ((await this.config.client.Users.current()) as {\n        id: number;\n      }).id;\n    }\n\n    const project = (await this.config.client.Projects.create({\n      namespace_id: targetNamespace,\n      name: name,\n      visibility: this.config.repoVisibility,\n    })) as { http_url_to_repo: string };\n\n    return project?.http_url_to_repo;\n  }\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Config } from '@backstage/config';\nimport { PublisherBase, PublisherBuilder } from './types';\nimport {\n  GithubPublisher,\n  RepoVisibilityOptions as GithubRepoVisibilityOptions,\n} from './github';\nimport {\n  GitlabPublisher,\n  RepoVisibilityOptions as GitlabRepoVisibilityOptions,\n} from './gitlab';\nimport { AzurePublisher } from './azure';\nimport {\n  BitbucketPublisher,\n  RepoVisibilityOptions as BitbucketRepoVisibilityOptions,\n} from './bitbucket';\nimport { Logger } from 'winston';\nimport { ScmIntegrations } from '@backstage/integration';\n\nexport class Publishers implements PublisherBuilder {\n  private publisherMap = new Map<string, PublisherBase | undefined>();\n\n  register(host: string, preparer: PublisherBase | undefined) {\n    this.publisherMap.set(host, preparer);\n  }\n\n  get(url: string): PublisherBase {\n    const preparer = this.publisherMap.get(new URL(url).host);\n    if (!preparer) {\n      throw new Error(\n        `Unable to find a publisher for URL: ${url}. Please make sure to register this host under an integration in app-config`,\n      );\n    }\n    return preparer;\n  }\n\n  static async fromConfig(\n    config: Config,\n    _options: { logger: Logger },\n  ): Promise<PublisherBuilder> {\n    const publishers = new Publishers();\n\n    const scm = ScmIntegrations.fromConfig(config);\n\n    for (const integration of scm.azure.list()) {\n      const publisher = await AzurePublisher.fromConfig(integration.config);\n      if (publisher) {\n        publishers.register(integration.config.host, publisher);\n      }\n    }\n\n    for (const integration of scm.github.list()) {\n      const repoVisibility = (config.getOptionalString(\n        'scaffolder.github.visibility',\n      ) ?? 'public') as GithubRepoVisibilityOptions;\n\n      const publisher = await GithubPublisher.fromConfig(integration.config, {\n        repoVisibility,\n      });\n      if (publisher) {\n        publishers.register(integration.config.host, publisher);\n      }\n    }\n\n    for (const integration of scm.gitlab.list()) {\n      const repoVisibility = (config.getOptionalString(\n        'scaffolder.gitlab.visibility',\n      ) ?? 'public') as GitlabRepoVisibilityOptions;\n\n      const publisher = await GitlabPublisher.fromConfig(integration.config, {\n        repoVisibility,\n      });\n\n      if (publisher) {\n        publishers.register(integration.config.host, publisher);\n      }\n    }\n\n    for (const integration of scm.bitbucket.list()) {\n      const repoVisibility = (config.getOptionalString(\n        'scaffolder.bitbucket.visibility',\n      ) ?? 'public') as BitbucketRepoVisibilityOptions;\n\n      const publisher = await BitbucketPublisher.fromConfig(\n        integration.config,\n        {\n          repoVisibility,\n        },\n      );\n\n      if (publisher) {\n        publishers.register(integration.config.host, publisher);\n      }\n    }\n\n    return publishers;\n  }\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { InputError } from '@backstage/errors';\nimport { TemplateEntityV1alpha1 } from '@backstage/catalog-model';\nimport { spawn } from 'child_process';\nimport { PassThrough, Writable } from 'stream';\n\nexport type RunCommandOptions = {\n  command: string;\n  args: string[];\n  logStream?: Writable;\n};\n\n/**\n * Gets the templater key to use for templating from the entity\n * @param entity Template entity\n */\nexport const getTemplaterKey = (entity: TemplateEntityV1alpha1): string => {\n  const { templater } = entity.spec;\n\n  if (!templater) {\n    throw new InputError('Template does not have a required templating key');\n  }\n\n  return templater;\n};\n\n/**\n *\n * @param options the options object\n * @param options.command the command to run\n * @param options.args the arguments to pass the command\n * @param options.logStream the log streamer to capture log messages\n */\nexport const runCommand = async ({\n  command,\n  args,\n  logStream = new PassThrough(),\n}: RunCommandOptions) => {\n  await new Promise<void>((resolve, reject) => {\n    const process = spawn(command, args);\n\n    process.stdout.on('data', stream => {\n      logStream.write(stream);\n    });\n\n    process.stderr.on('data', stream => {\n      logStream.write(stream);\n    });\n\n    process.on('error', error => {\n      return reject(error);\n    });\n\n    process.on('close', code => {\n      if (code !== 0) {\n        return reject(`Command ${command} failed, exit code: ${code}`);\n      }\n      return resolve();\n    });\n  });\n};\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ContainerRunner } from '@backstage/backend-common';\nimport { JsonValue } from '@backstage/config';\nimport fs from 'fs-extra';\nimport path from 'path';\nimport { runCommand } from './helpers';\nimport { TemplaterBase, TemplaterRunOptions } from './types';\n\nconst commandExists = require('command-exists-promise');\n\nexport class CookieCutter implements TemplaterBase {\n  private readonly containerRunner: ContainerRunner;\n\n  constructor({ containerRunner }: { containerRunner: ContainerRunner }) {\n    this.containerRunner = containerRunner;\n  }\n\n  private async fetchTemplateCookieCutter(\n    directory: string,\n  ): Promise<Record<string, JsonValue>> {\n    try {\n      return await fs.readJSON(path.join(directory, 'cookiecutter.json'));\n    } catch (ex) {\n      if (ex.code !== 'ENOENT') {\n        throw ex;\n      }\n\n      return {};\n    }\n  }\n\n  public async run({\n    workspacePath,\n    values,\n    logStream,\n  }: TemplaterRunOptions): Promise<void> {\n    const templateDir = path.join(workspacePath, 'template');\n    const intermediateDir = path.join(workspacePath, 'intermediate');\n    await fs.ensureDir(intermediateDir);\n    const resultDir = path.join(workspacePath, 'result');\n\n    // First lets grab the default cookiecutter.json file\n    const cookieCutterJson = await this.fetchTemplateCookieCutter(templateDir);\n\n    const { imageName, ...valuesForCookieCutterJson } = values;\n    const cookieInfo = {\n      ...cookieCutterJson,\n      ...valuesForCookieCutterJson,\n    };\n\n    await fs.writeJSON(path.join(templateDir, 'cookiecutter.json'), cookieInfo);\n\n    // Directories to bind on container\n    const mountDirs = {\n      [templateDir]: '/input',\n      [intermediateDir]: '/output',\n    };\n\n    const cookieCutterInstalled = await commandExists('cookiecutter');\n    if (cookieCutterInstalled) {\n      await runCommand({\n        command: 'cookiecutter',\n        args: ['--no-input', '-o', intermediateDir, templateDir, '--verbose'],\n        logStream,\n      });\n    } else {\n      await this.containerRunner.runContainer({\n        imageName: imageName || 'spotify/backstage-cookiecutter',\n        command: 'cookiecutter',\n        args: ['--no-input', '-o', '/output', '/input', '--verbose'],\n        mountDirs,\n        workingDir: '/input',\n        // Set the home directory inside the container as something that applications can\n        // write to, otherwise they will just fail trying to write to /\n        envVars: { HOME: '/tmp' },\n        logStream,\n      });\n    }\n\n    // if cookiecutter was successful, intermediateDir will contain\n    // exactly one directory.\n    const [generated] = await fs.readdir(intermediateDir);\n\n    if (generated === undefined) {\n      throw new Error('No data generated by cookiecutter');\n    }\n\n    await fs.move(path.join(intermediateDir, generated), resultDir);\n  }\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  TemplaterBase,\n  SupportedTemplatingKey,\n  TemplaterBuilder,\n} from './types';\n\nexport class Templaters implements TemplaterBuilder {\n  private templaterMap = new Map<SupportedTemplatingKey, TemplaterBase>();\n\n  register(templaterKey: SupportedTemplatingKey, templater: TemplaterBase) {\n    this.templaterMap.set(templaterKey, templater);\n  }\n\n  get(templaterId: string): TemplaterBase {\n    const templater = this.templaterMap.get(templaterId);\n\n    if (!templater) {\n      throw new Error(`No templater registered for template: \"${templaterId}\"`);\n    }\n\n    return templater;\n  }\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ContainerRunner } from '@backstage/backend-common';\nimport fs from 'fs-extra';\nimport path from 'path';\nimport * as yaml from 'yaml';\nimport { TemplaterBase, TemplaterRunOptions } from '../types';\n\n// TODO(blam): Replace with the universal import from github-actions after a release\n// As it will break the E2E without it\nconst GITHUB_ACTIONS_ANNOTATION = 'github.com/project-slug';\n\nexport class CreateReactAppTemplater implements TemplaterBase {\n  private readonly containerRunner: ContainerRunner;\n\n  constructor({ containerRunner }: { containerRunner: ContainerRunner }) {\n    this.containerRunner = containerRunner;\n  }\n\n  public async run({\n    workspacePath,\n    values,\n    logStream,\n  }: TemplaterRunOptions): Promise<void> {\n    const {\n      component_id: componentName,\n      use_typescript: withTypescript,\n      use_github_actions: withGithubActions,\n      description,\n      owner,\n    } = values;\n    const intermediateDir = path.join(workspacePath, 'template');\n    await fs.ensureDir(intermediateDir);\n\n    const mountDirs = {\n      [intermediateDir]: '/template',\n      [intermediateDir]: '/result',\n    };\n\n    await this.containerRunner.runContainer({\n      imageName: 'node:lts-alpine',\n      command: ['npx'],\n      args: [\n        'create-react-app',\n        componentName as string,\n        withTypescript ? ' --template typescript' : '',\n      ],\n      mountDirs,\n      workingDir: '/result',\n      logStream: logStream,\n      // Set the home directory inside the container as something that applications can\n      // write to, otherwise they will just fail trying to write to /\n      envVars: { HOME: '/tmp' },\n    });\n\n    // if cookiecutter was successful, intermediateDir will contain\n    // exactly one directory.\n    const [generated] = await fs.readdir(intermediateDir);\n\n    if (generated === undefined) {\n      throw new Error('No data generated by cookiecutter');\n    }\n\n    const resultDir = path.join(workspacePath, 'result');\n    await fs.move(path.join(intermediateDir, generated), resultDir);\n\n    const extraAnnotations: Record<string, string> = {};\n    if (withGithubActions) {\n      await fs.mkdir(`${resultDir}/.github`);\n      await fs.mkdir(`${resultDir}/.github/workflows`);\n      const githubActionsYaml = `\nname: CRA Build\n\non:\n  push:\n    branches: [ master ]\n  pull_request:\n    branches: [ master ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [12.x]\n\n    steps:\n    - name: checkout code\n      uses: actions/checkout@v1\n    - name: get yarn cache\n      id: yarn-cache\n      run: echo \"::set-output name=dir::$(yarn cache dir)\"\n    - uses: actions/cache@v2\n      with:\n        path: \\${{ steps.yarn-cache.outputs.dir }}\n        key: \\${{ runner.os }}-yarn-\\${{ hashFiles('**/yarn.lock') }}\n        restore-keys: |\n          \\${{ runner.os }}-yarn-\n    - name: use node.js \\${{ matrix.node-version }}\n      uses: actions/setup-node@v1\n      with:\n        node-version: \\${{ matrix.node-version }}\n    - name: yarn install, build, and test\n      working-directory: .\n      run: |\n        yarn install\n        yarn build\n        yarn test\n      env:\n        CI: true\n      `;\n      await fs.writeFile(\n        `${resultDir}/.github/workflows/main.yml`,\n        githubActionsYaml,\n      );\n\n      extraAnnotations[\n        GITHUB_ACTIONS_ANNOTATION\n      ] = `${values?.destination?.git?.owner}/${values?.destination?.git?.name}`;\n    }\n\n    const componentInfo = {\n      apiVersion: 'backstage.io/v1alpha1',\n      kind: 'Component',\n      metadata: {\n        name: componentName,\n        description,\n        annotations: {\n          ...extraAnnotations,\n        },\n      },\n      spec: {\n        type: 'website',\n        lifecycle: 'experimental',\n        owner,\n      },\n    };\n\n    await fs.writeFile(\n      `${resultDir}/catalog-info.yaml`,\n      yaml.stringify(componentInfo),\n    );\n  }\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { InputError } from '@backstage/errors';\nimport {\n  LOCATION_ANNOTATION,\n  parseLocationReference,\n  TemplateEntityV1alpha1,\n} from '@backstage/catalog-model';\nimport { posix as posixPath } from 'path';\n\nexport type ParsedLocationAnnotation = {\n  protocol: 'file' | 'url';\n  location: string;\n};\n\nexport const parseLocationAnnotation = (\n  entity: TemplateEntityV1alpha1,\n): ParsedLocationAnnotation => {\n  const annotation = entity.metadata.annotations?.[LOCATION_ANNOTATION];\n  if (!annotation) {\n    throw new InputError(\n      `No location annotation provided in entity: ${entity.metadata.name}`,\n    );\n  }\n\n  const { type, target } = parseLocationReference(annotation);\n  return {\n    protocol: type as 'file' | 'url',\n    location: target,\n  };\n};\n\nexport function joinGitUrlPath(repoUrl: string, path?: string): string {\n  const parsed = new URL(repoUrl);\n\n  if (parsed.hostname.endsWith('azure.com')) {\n    const templatePath = posixPath.normalize(\n      posixPath.join(\n        posixPath.dirname(parsed.searchParams.get('path') || '/'),\n        path || '.',\n      ),\n    );\n    parsed.searchParams.set('path', templatePath);\n    return parsed.toString();\n  }\n\n  return new URL(path || '.', repoUrl).toString().replace(/\\/$/, '');\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { PassThrough } from 'stream';\nimport * as winston from 'winston';\nimport { JsonValue } from '@backstage/config';\n\nexport const makeLogStream = (meta: Record<string, JsonValue>) => {\n  const log: string[] = [];\n\n  // Create an empty stream to collect all the log lines into\n  // one variable for the API.\n  const stream = new PassThrough();\n  stream.on('data', chunk => {\n    const textValue = chunk.toString().trim();\n    if (textValue?.length > 1) log.push(textValue);\n  });\n\n  const logger = winston.createLogger({\n    level: process.env.LOG_LEVEL || 'info',\n    format: winston.format.combine(\n      winston.format.colorize(),\n      winston.format.timestamp(),\n      winston.format.simple(),\n    ),\n    defaultMeta: meta,\n  });\n\n  logger.add(new winston.transports.Stream({ stream }));\n\n  return {\n    log,\n    stream,\n    logger,\n  };\n};\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport os from 'os';\nimport fs from 'fs-extra';\nimport { Processor, Job, StageContext, StageInput } from './types';\nimport { TemplateEntityV1alpha1 } from '@backstage/catalog-model';\nimport * as uuid from 'uuid';\nimport path from 'path';\nimport { TemplaterValues } from '../stages/templater';\nimport { makeLogStream } from './logger';\nimport { Logger } from 'winston';\nimport { Config } from '@backstage/config';\n\nexport type JobAndDirectoryTuple = {\n  job: Job;\n  directory: string;\n};\n\nexport class JobProcessor implements Processor {\n  private readonly workingDirectory: string;\n  private readonly jobs: Map<string, Job>;\n\n  static async fromConfig({\n    config,\n    logger,\n  }: {\n    config: Config;\n    logger: Logger;\n  }) {\n    let workingDirectory: string;\n    if (config.has('backend.workingDirectory')) {\n      workingDirectory = config.getString('backend.workingDirectory');\n      try {\n        // Check if working directory exists and is writable\n        await fs.promises.access(\n          workingDirectory,\n          fs.constants.F_OK | fs.constants.W_OK,\n        );\n        logger.info(`using working directory: ${workingDirectory}`);\n      } catch (err) {\n        logger.error(\n          `working directory ${workingDirectory} ${\n            err.code === 'ENOENT' ? 'does not exist' : 'is not writable'\n          }`,\n        );\n        throw err;\n      }\n    } else {\n      workingDirectory = os.tmpdir();\n    }\n\n    return new JobProcessor(workingDirectory);\n  }\n\n  constructor(workingDirectory: string) {\n    this.workingDirectory = workingDirectory;\n    this.jobs = new Map<string, Job>();\n  }\n\n  create({\n    entity,\n    values,\n    stages,\n  }: {\n    entity: TemplateEntityV1alpha1;\n    values: TemplaterValues;\n    stages: StageInput[];\n  }): Job {\n    const id = uuid.v4();\n    const { logger, stream } = makeLogStream({ id });\n\n    const context: StageContext = {\n      entity,\n      values,\n      logger,\n      logStream: stream,\n      workspacePath: path.join(this.workingDirectory, id),\n    };\n\n    const job: Job = {\n      id,\n      context,\n      stages: stages.map(stage => ({\n        handler: stage.handler,\n        log: [],\n        name: stage.name,\n        status: 'PENDING',\n      })),\n      status: 'PENDING',\n    };\n\n    this.jobs.set(job.id, job);\n\n    return job;\n  }\n\n  get(id: string): Job | undefined {\n    return this.jobs.get(id);\n  }\n\n  async run(job: Job): Promise<void> {\n    if (job.status !== 'PENDING') {\n      throw new Error(\"Job is not in a 'PENDING' state\");\n    }\n\n    await fs.mkdir(job.context.workspacePath);\n\n    job.status = 'STARTED';\n\n    try {\n      for (const stage of job.stages) {\n        // Create a logger for each stage so we can create separate\n        // Streams for each step.\n        const { logger, log, stream } = makeLogStream({\n          id: job.id,\n          stage: stage.name,\n        });\n        // Attach the logger to the stage, and setup some timestamps.\n        stage.log = log;\n        stage.startedAt = Date.now();\n\n        try {\n          // Run the handler with the context created for the Job and some\n          // Additional logging helpers.\n          stage.status = 'STARTED';\n          const handlerResponse = await stage.handler({\n            ...job.context,\n            logger,\n            logStream: stream,\n          });\n\n          // If the handler returns something, then let's merge this onto the\n          // context for the next stage to use as it might be relevant.\n          if (handlerResponse) {\n            job.context = {\n              ...job.context,\n              ...handlerResponse,\n            };\n          }\n\n          // Complete the current stage\n          stage.status = 'COMPLETED';\n        } catch (error) {\n          // Log to the current stage the error that occurred and fail the stage.\n          stage.status = 'FAILED';\n          logger.error(`Stage failed with error: ${error.message}`);\n          logger.debug(error.stack);\n          // Throw the error so the job can be failed too.\n          throw error;\n        } finally {\n          // Always set the stage end timestamp.\n          stage.endedAt = Date.now();\n        }\n      }\n\n      // If all went to plan, complete the job.\n      job.status = 'COMPLETED';\n    } catch (error) {\n      // If something went wrong, fail the job, and set the error property on the job.\n      job.error = { name: error.name, message: error.message };\n      job.status = 'FAILED';\n    } finally {\n      await fs.remove(job.context.workspacePath);\n    }\n  }\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  TemplateEntityV1alpha1,\n  TemplateEntityV1beta2,\n} from '@backstage/catalog-model';\nimport { CatalogApi } from '@backstage/catalog-client';\nimport { ConflictError, NotFoundError } from '@backstage/errors';\n\n/**\n * A catalog client tailored for reading out entity data from the catalog.\n */\nexport class CatalogEntityClient {\n  constructor(private readonly catalogClient: CatalogApi) {}\n\n  /**\n   * Looks up a single template using a template name.\n   *\n   * Throws a NotFoundError or ConflictError if 0 or multiple templates are found.\n   */\n  async findTemplate(\n    templateName: string,\n    options?: { token?: string },\n  ): Promise<TemplateEntityV1alpha1 | TemplateEntityV1beta2> {\n    const { items: templates } = (await this.catalogClient.getEntities(\n      {\n        filter: {\n          kind: 'template',\n          'metadata.name': templateName,\n        },\n      },\n      options,\n    )) as { items: (TemplateEntityV1alpha1 | TemplateEntityV1beta2)[] };\n\n    if (templates.length !== 1) {\n      if (templates.length > 1) {\n        throw new ConflictError(\n          'Templates lookup resulted in multiple matches',\n        );\n      } else {\n        throw new NotFoundError('Template not found');\n      }\n    }\n\n    return templates[0];\n  }\n}\n","/*\n * Copyright 2021 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { JsonObject } from '@backstage/config';\nimport { resolvePackagePath } from '@backstage/backend-common';\nimport { ConflictError, NotFoundError } from '@backstage/errors';\nimport { Knex } from 'knex';\nimport { v4 as uuid } from 'uuid';\nimport {\n  DbTaskEventRow,\n  DbTaskRow,\n  Status,\n  TaskEventType,\n  TaskSecrets,\n  TaskSpec,\n  TaskStore,\n  TaskStoreEmitOptions,\n  TaskStoreGetEventsOptions,\n} from './types';\nimport { DateTime } from 'luxon';\n\nconst migrationsDir = resolvePackagePath(\n  '@backstage/plugin-scaffolder-backend',\n  'migrations',\n);\n\nexport type RawDbTaskRow = {\n  id: string;\n  spec: string;\n  status: Status;\n  last_heartbeat_at?: string;\n  created_at: string;\n  secrets?: string;\n};\n\nexport type RawDbTaskEventRow = {\n  id: number;\n  task_id: string;\n  body: string;\n  event_type: TaskEventType;\n  created_at: string;\n};\n\nexport class DatabaseTaskStore implements TaskStore {\n  static async create(knex: Knex): Promise<DatabaseTaskStore> {\n    await knex.migrate.latest({\n      directory: migrationsDir,\n    });\n    return new DatabaseTaskStore(knex);\n  }\n\n  constructor(private readonly db: Knex) {}\n\n  async getTask(taskId: string): Promise<DbTaskRow> {\n    const [result] = await this.db<RawDbTaskRow>('tasks')\n      .where({ id: taskId })\n      .select();\n    if (!result) {\n      throw new NotFoundError(`No task with id '${taskId}' found`);\n    }\n    try {\n      const spec = JSON.parse(result.spec);\n      const secrets = result.secrets ? JSON.parse(result.secrets) : undefined;\n      return {\n        id: result.id,\n        spec,\n        status: result.status,\n        lastHeartbeatAt: result.last_heartbeat_at,\n        createdAt: result.created_at,\n        secrets,\n      };\n    } catch (error) {\n      throw new Error(`Failed to parse spec of task '${taskId}', ${error}`);\n    }\n  }\n\n  async createTask(\n    spec: TaskSpec,\n    secrets?: TaskSecrets,\n  ): Promise<{ taskId: string }> {\n    const taskId = uuid();\n    await this.db<RawDbTaskRow>('tasks').insert({\n      id: taskId,\n      spec: JSON.stringify(spec),\n      secrets: secrets ? JSON.stringify(secrets) : undefined,\n      status: 'open',\n    });\n    return { taskId };\n  }\n\n  async claimTask(): Promise<DbTaskRow | undefined> {\n    return this.db.transaction(async tx => {\n      const [task] = await tx<RawDbTaskRow>('tasks')\n        .where({\n          status: 'open',\n        })\n        .limit(1)\n        .select();\n\n      if (!task) {\n        return undefined;\n      }\n\n      const updateCount = await tx<RawDbTaskRow>('tasks')\n        .where({ id: task.id, status: 'open' })\n        .update({\n          status: 'processing',\n          last_heartbeat_at: this.db.fn.now(),\n        });\n\n      if (updateCount < 1) {\n        return undefined;\n      }\n\n      try {\n        const spec = JSON.parse(task.spec);\n        const secrets = task.secrets ? JSON.parse(task.secrets) : undefined;\n        return {\n          id: task.id,\n          spec,\n          status: 'processing',\n          lastHeartbeatAt: task.last_heartbeat_at,\n          createdAt: task.created_at,\n          secrets,\n        };\n      } catch (error) {\n        throw new Error(`Failed to parse spec of task '${task.id}', ${error}`);\n      }\n    });\n  }\n\n  async heartbeatTask(taskId: string): Promise<void> {\n    const updateCount = await this.db<RawDbTaskRow>('tasks')\n      .where({ id: taskId, status: 'processing' })\n      .update({\n        last_heartbeat_at: this.db.fn.now(),\n      });\n    if (updateCount === 0) {\n      throw new ConflictError(`No running task with taskId ${taskId} found`);\n    }\n  }\n\n  async listStaleTasks({\n    timeoutS,\n  }: {\n    timeoutS: number;\n  }): Promise<{\n    tasks: { taskId: string }[];\n  }> {\n    const rawRows = await this.db<RawDbTaskRow>('tasks')\n      .where('status', 'processing')\n      .andWhere(\n        'last_heartbeat_at',\n        '<=',\n        this.db.client.config.client === 'sqlite3'\n          ? this.db.raw(`datetime('now', ?)`, [`-${timeoutS} seconds`])\n          : this.db.raw(`dateadd('second', ?, ?)`, [\n              `-${timeoutS}`,\n              this.db.fn.now(),\n            ]),\n      );\n    const tasks = rawRows.map(row => ({\n      taskId: row.id,\n    }));\n    return { tasks };\n  }\n\n  async completeTask({\n    taskId,\n    status,\n    eventBody,\n  }: {\n    taskId: string;\n    status: Status;\n    eventBody: JsonObject;\n  }): Promise<void> {\n    let oldStatus: string;\n    if (status === 'failed' || status === 'completed') {\n      oldStatus = 'processing';\n    } else {\n      throw new Error(\n        `Invalid status update of run '${taskId}' to status '${status}'`,\n      );\n    }\n    await this.db.transaction(async tx => {\n      const [task] = await tx<RawDbTaskRow>('tasks')\n        .where({\n          id: taskId,\n        })\n        .limit(1)\n        .select();\n\n      if (!task) {\n        throw new Error(`No task with taskId ${taskId} found`);\n      }\n      if (task.status !== oldStatus) {\n        throw new ConflictError(\n          `Refusing to update status of run '${taskId}' to status '${status}' ` +\n            `as it is currently '${task.status}', expected '${oldStatus}'`,\n        );\n      }\n      const updateCount = await tx<RawDbTaskRow>('tasks')\n        .where({\n          id: taskId,\n          status: oldStatus,\n        })\n        .update({\n          status,\n          secrets: null as any,\n        });\n      if (updateCount !== 1) {\n        throw new ConflictError(\n          `Failed to update status to '${status}' for taskId ${taskId}`,\n        );\n      }\n\n      await tx<RawDbTaskEventRow>('task_events').insert({\n        task_id: taskId,\n        event_type: 'completion',\n        body: JSON.stringify(eventBody),\n      });\n    });\n  }\n\n  async emitLogEvent({ taskId, body }: TaskStoreEmitOptions): Promise<void> {\n    const serliazedBody = JSON.stringify(body);\n    await this.db<RawDbTaskEventRow>('task_events').insert({\n      task_id: taskId,\n      event_type: 'log',\n      body: serliazedBody,\n    });\n  }\n\n  async listEvents({\n    taskId,\n    after,\n  }: TaskStoreGetEventsOptions): Promise<{ events: DbTaskEventRow[] }> {\n    const rawEvents = await this.db<RawDbTaskEventRow>('task_events')\n      .where({\n        task_id: taskId,\n      })\n      .andWhere(builder => {\n        if (typeof after === 'number') {\n          builder.where('id', '>', after).orWhere('event_type', 'completion');\n        }\n      })\n      .orderBy('id')\n      .select();\n\n    const events = rawEvents.map(event => {\n      try {\n        const body = JSON.parse(event.body) as JsonObject;\n        return {\n          id: Number(event.id),\n          taskId,\n          body,\n          type: event.event_type,\n          createdAt:\n            typeof event.created_at === 'string'\n              ? DateTime.fromSQL(event.created_at, { zone: 'UTC' }).toISO()\n              : event.created_at,\n        };\n      } catch (error) {\n        throw new Error(\n          `Failed to parse event body from event taskId=${taskId} id=${event.id}, ${error}`,\n        );\n      }\n    });\n    return { events };\n  }\n}\n","/*\n * Copyright 2021 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { JsonObject } from '@backstage/config';\nimport { Logger } from 'winston';\nimport {\n  CompletedTaskState,\n  Task,\n  TaskSecrets,\n  TaskSpec,\n  TaskStore,\n  TaskBroker,\n  DispatchResult,\n  DbTaskEventRow,\n  DbTaskRow,\n} from './types';\n\nexport class TaskAgent implements Task {\n  private isDone = false;\n\n  private heartbeatTimeoutId?: ReturnType<typeof setInterval>;\n\n  static create(state: TaskState, storage: TaskStore, logger: Logger) {\n    const agent = new TaskAgent(state, storage, logger);\n    agent.startTimeout();\n    return agent;\n  }\n\n  // Runs heartbeat internally\n  private constructor(\n    private readonly state: TaskState,\n    private readonly storage: TaskStore,\n    private readonly logger: Logger,\n  ) {}\n\n  get spec() {\n    return this.state.spec;\n  }\n\n  get secrets() {\n    return this.state.secrets;\n  }\n\n  async getWorkspaceName() {\n    return this.state.taskId;\n  }\n\n  get done() {\n    return this.isDone;\n  }\n\n  async emitLog(message: string, metadata?: JsonObject): Promise<void> {\n    await this.storage.emitLogEvent({\n      taskId: this.state.taskId,\n      body: { message, ...metadata },\n    });\n  }\n\n  async complete(\n    result: CompletedTaskState,\n    metadata?: JsonObject,\n  ): Promise<void> {\n    await this.storage.completeTask({\n      taskId: this.state.taskId,\n      status: result === 'failed' ? 'failed' : 'completed',\n      eventBody: {\n        message: `Run completed with status: ${result}`,\n        ...metadata,\n      },\n    });\n    this.isDone = true;\n    if (this.heartbeatTimeoutId) {\n      clearTimeout(this.heartbeatTimeoutId);\n    }\n  }\n\n  private startTimeout() {\n    this.heartbeatTimeoutId = setTimeout(async () => {\n      try {\n        await this.storage.heartbeatTask(this.state.taskId);\n        this.startTimeout();\n      } catch (error) {\n        this.isDone = true;\n\n        this.logger.error(\n          `Heartbeat for task ${this.state.taskId} failed`,\n          error,\n        );\n      }\n    }, 1000);\n  }\n}\n\ninterface TaskState {\n  spec: TaskSpec;\n  taskId: string;\n  secrets?: TaskSecrets;\n}\n\nfunction defer() {\n  let resolve = () => {};\n  const promise = new Promise<void>(_resolve => {\n    resolve = _resolve;\n  });\n  return { promise, resolve };\n}\n\nexport class StorageTaskBroker implements TaskBroker {\n  constructor(\n    private readonly storage: TaskStore,\n    private readonly logger: Logger,\n  ) {}\n  private deferredDispatch = defer();\n\n  async claim(): Promise<Task> {\n    for (;;) {\n      const pendingTask = await this.storage.claimTask();\n      if (pendingTask) {\n        return TaskAgent.create(\n          {\n            taskId: pendingTask.id,\n            spec: pendingTask.spec,\n            secrets: pendingTask.secrets,\n          },\n          this.storage,\n          this.logger,\n        );\n      }\n\n      await this.waitForDispatch();\n    }\n  }\n\n  async dispatch(\n    spec: TaskSpec,\n    secrets?: TaskSecrets,\n  ): Promise<DispatchResult> {\n    const taskRow = await this.storage.createTask(spec, secrets);\n    this.signalDispatch();\n    return {\n      taskId: taskRow.taskId,\n    };\n  }\n\n  async get(taskId: string): Promise<DbTaskRow> {\n    return this.storage.getTask(taskId);\n  }\n\n  observe(\n    options: {\n      taskId: string;\n      after: number | undefined;\n    },\n    callback: (\n      error: Error | undefined,\n      result: { events: DbTaskEventRow[] },\n    ) => void,\n  ): () => void {\n    const { taskId } = options;\n\n    let cancelled = false;\n    const unsubscribe = () => {\n      cancelled = true;\n    };\n\n    (async () => {\n      let after = options.after;\n      while (!cancelled) {\n        const result = await this.storage.listEvents({ taskId, after: after });\n        const { events } = result;\n        if (events.length) {\n          after = events[events.length - 1].id;\n          try {\n            callback(undefined, result);\n          } catch (error) {\n            callback(error, { events: [] });\n          }\n        }\n\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n    })();\n\n    return unsubscribe;\n  }\n\n  async vacuumTasks(timeoutS: { timeoutS: number }): Promise<void> {\n    const { tasks } = await this.storage.listStaleTasks(timeoutS);\n    await Promise.all(\n      tasks.map(async task => {\n        try {\n          await this.storage.completeTask({\n            taskId: task.taskId,\n            status: 'failed',\n            eventBody: {\n              message:\n                'The task was cancelled because the task worker lost connection to the task broker',\n            },\n          });\n        } catch (error) {\n          this.logger.warn(`Failed to cancel task '${task.taskId}', ${error}`);\n        }\n      }),\n    );\n  }\n\n  private waitForDispatch() {\n    return this.deferredDispatch.promise;\n  }\n\n  private signalDispatch() {\n    this.deferredDispatch.resolve();\n    this.deferredDispatch = defer();\n  }\n}\n","/*\n * Copyright 2021 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { PassThrough } from 'stream';\nimport { Logger } from 'winston';\nimport * as winston from 'winston';\nimport { JsonValue, JsonObject } from '@backstage/config';\nimport { validate as validateJsonSchema } from 'jsonschema';\nimport { TaskBroker, Task } from './types';\nimport fs from 'fs-extra';\nimport path from 'path';\nimport { TemplateActionRegistry } from '../actions/TemplateActionRegistry';\nimport * as Handlebars from 'handlebars';\nimport { InputError } from '@backstage/errors';\nimport { parseRepoUrl } from '../actions/builtin/publish/util';\n\ntype Options = {\n  logger: Logger;\n  taskBroker: TaskBroker;\n  workingDirectory: string;\n  actionRegistry: TemplateActionRegistry;\n};\n\nexport class TaskWorker {\n  private readonly handlebars: typeof Handlebars;\n\n  constructor(private readonly options: Options) {\n    this.handlebars = Handlebars.create();\n\n    // TODO(blam): this should be a public facing API but it's a little\n    // scary right now, so we're going to lock it off like the component API is\n    // in the frontend until we can work out a nice way to do it.\n    this.handlebars.registerHelper('parseRepoUrl', repoUrl => {\n      return JSON.stringify(parseRepoUrl(repoUrl));\n    });\n\n    this.handlebars.registerHelper('json', obj => JSON.stringify(obj));\n  }\n\n  start() {\n    (async () => {\n      for (;;) {\n        const task = await this.options.taskBroker.claim();\n        await this.runOneTask(task);\n      }\n    })();\n  }\n\n  async runOneTask(task: Task) {\n    let workspacePath: string | undefined = undefined;\n    try {\n      const { actionRegistry } = this.options;\n\n      workspacePath = path.join(\n        this.options.workingDirectory,\n        await task.getWorkspaceName(),\n      );\n      await fs.ensureDir(workspacePath);\n      await task.emitLog(\n        `Starting up task with ${task.spec.steps.length} steps`,\n      );\n\n      const templateCtx: {\n        parameters: JsonObject;\n        steps: {\n          [stepName: string]: { output: { [outputName: string]: JsonValue } };\n        };\n      } = { parameters: task.spec.values, steps: {} };\n\n      for (const step of task.spec.steps) {\n        const metadata = { stepId: step.id };\n        try {\n          const taskLogger = winston.createLogger({\n            level: process.env.LOG_LEVEL || 'info',\n            format: winston.format.combine(\n              winston.format.colorize(),\n              winston.format.timestamp(),\n              winston.format.simple(),\n            ),\n            defaultMeta: {},\n          });\n\n          const stream = new PassThrough();\n          stream.on('data', async data => {\n            const message = data.toString().trim();\n            if (message?.length > 1) {\n              await task.emitLog(message, metadata);\n            }\n          });\n\n          taskLogger.add(new winston.transports.Stream({ stream }));\n          await task.emitLog(`Beginning step ${step.name}`, {\n            ...metadata,\n            status: 'processing',\n          });\n\n          const action = actionRegistry.get(step.action);\n          if (!action) {\n            throw new Error(`Action '${step.action}' does not exist`);\n          }\n\n          const input =\n            step.input &&\n            JSON.parse(JSON.stringify(step.input), (_key, value) => {\n              if (typeof value === 'string') {\n                const templated = this.handlebars.compile(value, {\n                  noEscape: true,\n                  strict: true,\n                  data: false,\n                  preventIndent: true,\n                })(templateCtx);\n\n                // If it smells like a JSON object then give it a parse as an object and if it fails return the string\n                if (\n                  (templated.startsWith('{') && templated.endsWith('}')) ||\n                  (templated.startsWith('[') && templated.endsWith(']'))\n                ) {\n                  try {\n                    // Don't recursively JSON parse the values of this string.\n                    // Shouldn't need to, don't want to encourage the use of returning handlebars from somewhere else\n                    return JSON.parse(templated);\n                  } catch {\n                    return templated;\n                  }\n                }\n                return templated;\n              }\n\n              return value;\n            });\n\n          if (action.schema?.input) {\n            const validateResult = validateJsonSchema(\n              input,\n              action.schema.input,\n            );\n            if (!validateResult.valid) {\n              const errors = validateResult.errors.join(', ');\n              throw new InputError(\n                `Invalid input passed to action ${action.id}, ${errors}`,\n              );\n            }\n          }\n\n          const stepOutputs: { [name: string]: JsonValue } = {};\n\n          // Keep track of all tmp dirs that are created by the action so we can remove them after\n          const tmpDirs = new Array<string>();\n\n          await action.handler({\n            baseUrl: task.spec.baseUrl,\n            logger: taskLogger,\n            logStream: stream,\n            input,\n            token: task.secrets?.token,\n            workspacePath,\n            async createTemporaryDirectory() {\n              const tmpDir = await fs.mkdtemp(\n                `${workspacePath}_step-${step.id}-`,\n              );\n              tmpDirs.push(tmpDir);\n              return tmpDir;\n            },\n            output(name: string, value: JsonValue) {\n              stepOutputs[name] = value;\n            },\n          });\n\n          // Remove all temporary directories that were created when executing the action\n          for (const tmpDir of tmpDirs) {\n            await fs.remove(tmpDir);\n          }\n\n          templateCtx.steps[step.id] = { output: stepOutputs };\n\n          await task.emitLog(`Finished step ${step.name}`, {\n            ...metadata,\n            status: 'completed',\n          });\n        } catch (error) {\n          await task.emitLog(String(error.stack), {\n            ...metadata,\n            status: 'failed',\n          });\n          throw error;\n        }\n      }\n\n      const output = JSON.parse(\n        JSON.stringify(task.spec.output),\n        (_key, value) => {\n          if (typeof value === 'string') {\n            return this.handlebars.compile(value, {\n              noEscape: true,\n              strict: true,\n              data: false,\n              preventIndent: true,\n            })(templateCtx);\n          }\n          return value;\n        },\n      );\n\n      await task.complete('completed', { output });\n    } catch (error) {\n      await task.complete('failed', {\n        error: { name: error.name, message: error.message },\n      });\n    } finally {\n      if (workspacePath) {\n        await fs.remove(workspacePath);\n      }\n    }\n  }\n}\n","/*\n * Copyright 2021 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { resolve as resolvePath, dirname } from 'path';\nimport { TemplateEntityV1alpha1 } from '@backstage/catalog-model';\nimport parseGitUrl from 'git-url-parse';\nimport { TaskSpec } from './types';\nimport {\n  getTemplaterKey,\n  joinGitUrlPath,\n  parseLocationAnnotation,\n  TemplaterValues,\n} from '../stages';\n\nexport function templateEntityToSpec(\n  template: TemplateEntityV1alpha1,\n  inputValues: TemplaterValues,\n): TaskSpec {\n  const steps: TaskSpec['steps'] = [];\n\n  const { protocol, location } = parseLocationAnnotation(template);\n\n  let url: string;\n  if (protocol === 'file') {\n    const path = resolvePath(dirname(location), template.spec.path || '.');\n\n    url = `file://${path}`;\n  } else {\n    url = joinGitUrlPath(location, template.spec.path);\n  }\n  const templater = getTemplaterKey(template);\n\n  const values = {\n    ...inputValues,\n    destination: {\n      git: parseGitUrl(inputValues.storePath),\n    },\n  } as TemplaterValues;\n\n  steps.push({\n    id: 'prepare',\n    name: 'Prepare',\n    action: 'legacy:prepare',\n    input: {\n      protocol,\n      url,\n    },\n  });\n\n  steps.push({\n    id: 'template',\n    name: 'Template',\n    action: 'legacy:template',\n    input: {\n      templater,\n      values,\n    },\n  });\n\n  steps.push({\n    id: 'publish',\n    name: 'Publish',\n    action: 'legacy:publish',\n    input: {\n      values,\n    },\n  });\n\n  steps.push({\n    id: 'register',\n    name: 'Register',\n    action: 'catalog:register',\n    input: {\n      catalogInfoUrl: '{{ steps.publish.output.catalogInfoUrl }}',\n    },\n  });\n\n  return {\n    baseUrl: undefined, // not used by legacy actions\n    values: {},\n    steps,\n    output: {\n      remoteUrl: '{{ steps.publish.output.remoteUrl }}',\n      catalogInfoUrl: '{{ steps.register.output.catalogInfoUrl }}',\n      entityRef: '{{ steps.register.output.entityRef }}',\n    },\n  };\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Entity,\n  LOCATION_ANNOTATION,\n  parseLocationReference,\n  SOURCE_LOCATION_ANNOTATION,\n} from '@backstage/catalog-model';\nimport { Config } from '@backstage/config';\nimport fs from 'fs-extra';\nimport os from 'os';\nimport { Logger } from 'winston';\n\nexport async function getWorkingDirectory(\n  config: Config,\n  logger: Logger,\n): Promise<string> {\n  if (!config.has('backend.workingDirectory')) {\n    return os.tmpdir();\n  }\n\n  const workingDirectory = config.getString('backend.workingDirectory');\n  try {\n    // Check if working directory exists and is writable\n    await fs.access(workingDirectory, fs.constants.F_OK | fs.constants.W_OK);\n    logger.info(`using working directory: ${workingDirectory}`);\n  } catch (err) {\n    logger.error(\n      `working directory ${workingDirectory} ${\n        err.code === 'ENOENT' ? 'does not exist' : 'is not writable'\n      }`,\n    );\n    throw err;\n  }\n  return workingDirectory;\n}\n\n/**\n * Gets the base URL of the entity location that points to the source location\n * of the entity description within a repo. If there is not source location\n * or if it has an invalid type, undefined will be returned instead.\n *\n * For file locations this will return a `file://` URL.\n */\nexport function getEntityBaseUrl(entity: Entity): string | undefined {\n  let location = entity.metadata.annotations?.[SOURCE_LOCATION_ANNOTATION];\n  if (!location) {\n    location = entity.metadata.annotations?.[LOCATION_ANNOTATION];\n  }\n  if (!location) {\n    return undefined;\n  }\n\n  const { type, target } = parseLocationReference(location);\n  if (type === 'url') {\n    return target;\n  } else if (type === 'file') {\n    return `file://${target}`;\n  }\n\n  // Only url and file location are handled, as we otherwise don't know if\n  // what the url is pointing to makes sense to use as a baseUrl\n  return undefined;\n}\n","/*\n * Copyright 2020 Spotify AB\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Config } from '@backstage/config';\nimport express from 'express';\nimport Router from 'express-promise-router';\nimport { Logger } from 'winston';\nimport {\n  PreparerBuilder,\n  TemplaterBuilder,\n  TemplaterValues,\n  PublisherBuilder,\n} from '../scaffolder';\nimport { CatalogEntityClient } from '../lib/catalog';\nimport { validate } from 'jsonschema';\nimport {\n  DatabaseTaskStore,\n  StorageTaskBroker,\n  TaskWorker,\n} from '../scaffolder/tasks';\nimport { templateEntityToSpec } from '../scaffolder/tasks/TemplateConverter';\nimport { TemplateActionRegistry } from '../scaffolder/actions/TemplateActionRegistry';\nimport { createLegacyActions } from '../scaffolder/stages/legacy';\nimport { getEntityBaseUrl, getWorkingDirectory } from './helpers';\nimport { PluginDatabaseManager, UrlReader } from '@backstage/backend-common';\nimport { InputError, NotFoundError } from '@backstage/errors';\nimport { CatalogApi } from '@backstage/catalog-client';\nimport {\n  TemplateEntityV1alpha1,\n  TemplateEntityV1beta2,\n  Entity,\n} from '@backstage/catalog-model';\nimport { ScmIntegrations } from '@backstage/integration';\nimport { TemplateAction } from '../scaffolder/actions';\nimport { createBuiltinActions } from '../scaffolder/actions/builtin/createBuiltinActions';\n\nexport interface RouterOptions {\n  preparers: PreparerBuilder;\n  templaters: TemplaterBuilder;\n  publishers: PublisherBuilder;\n\n  logger: Logger;\n  config: Config;\n  reader: UrlReader;\n  database: PluginDatabaseManager;\n  catalogClient: CatalogApi;\n  actions?: TemplateAction<any>[];\n  taskWorkers?: number;\n}\n\nfunction isAlpha1Template(\n  entity: TemplateEntityV1alpha1 | TemplateEntityV1beta2,\n): entity is TemplateEntityV1alpha1 {\n  return (\n    entity.apiVersion === 'backstage.io/v1alpha1' ||\n    entity.apiVersion === 'backstage.io/v1beta1'\n  );\n}\n\nfunction isBeta2Template(\n  entity: TemplateEntityV1alpha1 | TemplateEntityV1beta2,\n): entity is TemplateEntityV1beta2 {\n  return entity.apiVersion === 'backstage.io/v1beta2';\n}\n\nexport async function createRouter(\n  options: RouterOptions,\n): Promise<express.Router> {\n  const router = Router();\n  router.use(express.json());\n\n  const {\n    preparers,\n    templaters,\n    publishers,\n    logger: parentLogger,\n    config,\n    reader,\n    database,\n    catalogClient,\n    actions,\n    taskWorkers,\n  } = options;\n\n  const logger = parentLogger.child({ plugin: 'scaffolder' });\n  const workingDirectory = await getWorkingDirectory(config, logger);\n  const entityClient = new CatalogEntityClient(catalogClient);\n  const integrations = ScmIntegrations.fromConfig(config);\n\n  const databaseTaskStore = await DatabaseTaskStore.create(\n    await database.getClient(),\n  );\n  const taskBroker = new StorageTaskBroker(databaseTaskStore, logger);\n  const actionRegistry = new TemplateActionRegistry();\n  const workers = [];\n  for (let i = 0; i < (taskWorkers || 1); i++) {\n    const worker = new TaskWorker({\n      logger,\n      taskBroker,\n      actionRegistry,\n      workingDirectory,\n    });\n    workers.push(worker);\n  }\n\n  const actionsToRegister = Array.isArray(actions)\n    ? actions\n    : [\n        ...createLegacyActions({\n          preparers,\n          publishers,\n          templaters,\n        }),\n        ...createBuiltinActions({\n          integrations,\n          catalogClient,\n          templaters,\n          reader,\n        }),\n      ];\n\n  actionsToRegister.forEach(action => actionRegistry.register(action));\n  workers.forEach(worker => worker.start());\n\n  router\n    .get(\n      '/v2/templates/:namespace/:kind/:name/parameter-schema',\n      async (req, res) => {\n        const { namespace, kind, name } = req.params;\n\n        if (namespace !== 'default') {\n          throw new InputError(\n            `Invalid namespace, only 'default' namespace is supported`,\n          );\n        }\n        if (kind.toLowerCase() !== 'template') {\n          throw new InputError(\n            `Invalid kind, only 'Template' kind is supported`,\n          );\n        }\n\n        const template = await entityClient.findTemplate(name, {\n          token: getBearerToken(req.headers.authorization),\n        });\n        if (isBeta2Template(template)) {\n          const parameters = [template.spec.parameters ?? []].flat();\n          res.json({\n            title: template.metadata.title ?? template.metadata.name,\n            steps: parameters.map(schema => ({\n              title: schema.title ?? 'Fill in template parameters',\n              schema,\n            })),\n          });\n        } else if (isAlpha1Template(template)) {\n          res.json({\n            title: template.metadata.title ?? template.metadata.name,\n            steps: [\n              {\n                title: 'Fill in template parameters',\n                schema: template.spec.schema,\n              },\n              {\n                title: 'Choose owner and repo',\n                schema: {\n                  type: 'object',\n                  required: ['storePath', 'owner'],\n                  properties: {\n                    owner: {\n                      type: 'string',\n                      title: 'Owner',\n                      description: 'Who is going to own this component',\n                    },\n                    storePath: {\n                      type: 'string',\n                      title: 'Store path',\n                      description:\n                        'A full URL to the repository that should be created. e.g https://github.com/backstage/new-repo',\n                    },\n                    access: {\n                      type: 'string',\n                      title: 'Access',\n                      description:\n                        'Who should have access, in org/team or user format',\n                    },\n                  },\n                },\n              },\n            ],\n          });\n        } else {\n          throw new InputError(\n            `Unsupported apiVersion field in schema entity, ${\n              (template as Entity).apiVersion\n            }`,\n          );\n        }\n      },\n    )\n    .get('/v2/actions', async (_req, res) => {\n      const actionsList = actionRegistry.list().map(action => {\n        return {\n          id: action.id,\n          description: action.description,\n          schema: action.schema,\n        };\n      });\n      res.json(actionsList);\n    })\n    .post('/v2/tasks', async (req, res) => {\n      const templateName: string = req.body.templateName;\n      const values: TemplaterValues = req.body.values;\n      const token = getBearerToken(req.headers.authorization);\n      const template = await entityClient.findTemplate(templateName, {\n        token,\n      });\n\n      let taskSpec;\n      if (isAlpha1Template(template)) {\n        logger.warn(\n          `[DEPRECATION] - Template: ${template.metadata.name} has version ${template.apiVersion} which is going to be deprecated. Please refer to https://backstage.io/docs/features/software-templates/migrating-from-v1alpha1-to-v1beta2 for help on migrating`,\n        );\n\n        const result = validate(values, template.spec.schema);\n        if (!result.valid) {\n          res.status(400).json({ errors: result.errors });\n          return;\n        }\n\n        taskSpec = templateEntityToSpec(template, values);\n      } else if (isBeta2Template(template)) {\n        for (const parameters of [template.spec.parameters ?? []].flat()) {\n          const result = validate(values, parameters);\n\n          if (!result.valid) {\n            res.status(400).json({ errors: result.errors });\n            return;\n          }\n        }\n\n        const baseUrl = getEntityBaseUrl(template);\n\n        taskSpec = {\n          baseUrl,\n          values,\n          steps: template.spec.steps.map((step, index) => ({\n            ...step,\n            id: step.id ?? `step-${index + 1}`,\n            name: step.name ?? step.action,\n          })),\n          output: template.spec.output ?? {},\n        };\n      } else {\n        throw new InputError(\n          `Unsupported apiVersion field in schema entity, ${\n            (template as Entity).apiVersion\n          }`,\n        );\n      }\n\n      const result = await taskBroker.dispatch(taskSpec, {\n        token: token,\n      });\n\n      res.status(201).json({ id: result.taskId });\n    })\n    .get('/v2/tasks/:taskId', async (req, res) => {\n      const { taskId } = req.params;\n      const task = await taskBroker.get(taskId);\n      if (!task) {\n        throw new NotFoundError(`Task with id ${taskId} does not exist`);\n      }\n      // Do not disclose secrets\n      delete task.secrets;\n      res.status(200).json(task);\n    })\n    .get('/v2/tasks/:taskId/eventstream', async (req, res) => {\n      const { taskId } = req.params;\n      const after = Number(req.query.after) || undefined;\n      logger.debug(`Event stream observing taskId '${taskId}' opened`);\n\n      // Mandatory headers and http status to keep connection open\n      res.writeHead(200, {\n        Connection: 'keep-alive',\n        'Cache-Control': 'no-cache',\n        'Content-Type': 'text/event-stream',\n      });\n\n      // After client opens connection send all events as string\n      const unsubscribe = taskBroker.observe(\n        { taskId, after },\n        (error, { events }) => {\n          if (error) {\n            logger.error(\n              `Received error from event stream when observing taskId '${taskId}', ${error}`,\n            );\n          }\n\n          for (const event of events) {\n            res.write(\n              `event: ${event.type}\\ndata: ${JSON.stringify(event)}\\n\\n`,\n            );\n            if (event.type === 'completion') {\n              unsubscribe();\n              // Closing the event stream here would cause the frontend\n              // to automatically reconnect because it lost connection.\n            }\n          }\n          res.flush();\n        },\n      );\n      // When client closes connection we update the clients list\n      // avoiding the disconnected one\n      req.on('close', () => {\n        unsubscribe();\n        logger.debug(`Event stream observing taskId '${taskId}' closed`);\n      });\n    });\n\n  const app = express();\n  app.set('logger', logger);\n  app.use('/', router);\n\n  return app;\n}\n\nfunction getBearerToken(header?: string): string | undefined {\n  return header?.match(/Bearer\\s+(\\S+)/i)?.[1];\n}\n"],"names":["InputError","getEntityName","isAbsolute","resolvePath","fs","path","Git","globby","normalizePath","joinPath","GithubCredentialsProvider","integration","Octokit","CustomErrorBase","createPullRequest","readFile","zipObject","getPersonalAccessTokenHandler","WebApi","Gitlab","fetch","dirname","ConflictError","NotFoundError","parseGitUrl","url","fileURLToPath","ScmIntegrations","PassThrough","spawn","yaml.stringify","LOCATION_ANNOTATION","parseLocationReference","posixPath","stream","winston.createLogger","winston.format","winston.transports","os","uuid.v4","resolvePackagePath","uuid","DateTime","Handlebars.create","validateJsonSchema","errors","SOURCE_LOCATION_ANNOTATION","Router","express","validate"],"mappings":"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"}