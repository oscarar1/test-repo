import { useApi, useRouteRef, ItemCardHeader, Button as Button$1, configApiRef, Page, Header, Lifecycle, Content, ContentHeader, SupportButton, Progress, WarningPanel, ItemCardGrid, StructuredMetadataTable, errorApiRef, InfoCard, Link as Link$2, useApp, ErrorPage, getComponentData } from '@backstage/core';
import '@backstage/errors';
import 'zen-observable';
import { E as EntityPicker, R as RepoUrlPicker, r as repoPickerValidation, O as OwnerPicker, a as rootRouteRef, b as registerComponentRouteRef, s as scaffolderApiRef, F as FIELD_EXTENSION_KEY, c as FIELD_EXTENSION_WRAPPER_KEY } from './index-c2dd3777.esm.js';
import { catalogApiRef, useStarredEntities, getEntityRelations, EntityRefLinks, entityRouteRef } from '@backstage/plugin-catalog-react';
import { makeStyles, Typography, Button, Divider, List, ListItem, Checkbox, ListItemText, Card, MenuItem, ListItemIcon, ListItemSecondaryAction, Toolbar, FormControl, Input, InputAdornment, IconButton, withStyles, Tooltip, useTheme, CardMedia, CardContent, Box, Chip, CardActions, Link, Stepper, Step, StepLabel, StepContent, Paper, LinearProgress, Grid, StepButton, CircularProgress, TableContainer, Table, TableHead, TableRow, TableCell, TableBody } from '@material-ui/core';
import '@material-ui/core/FormControl';
import '@material-ui/lab/Autocomplete';
import React, { createContext, useRef, useState, useEffect, useCallback, useContext, useMemo, memo } from 'react';
import { useAsyncFn, useAsync, useInterval } from 'react-use';
import '@material-ui/core/Select';
import '@material-ui/core/InputLabel';
import '@material-ui/core/Input';
import '@material-ui/core/FormHelperText';
import '@backstage/integration-react';
import { generatePath, useNavigate, Navigate, useParams as useParams$1, useOutlet, Routes, Route } from 'react-router';
import Star from '@material-ui/icons/Star';
import { Link as Link$1, useParams } from 'react-router-dom';
import Search from '@material-ui/icons/Search';
import Clear from '@material-ui/icons/Clear';
import { pageTheme } from '@backstage/theme';
import WarningIcon from '@material-ui/icons/Warning';
import { RELATION_OWNED_BY, parseEntityName } from '@backstage/catalog-model';
import StarBorder from '@material-ui/icons/StarBorder';
import parseGitUrl from 'git-url-parse';
import { withTheme } from '@rjsf/core';
import { Theme } from '@rjsf/material-ui';
import { makeStyles as makeStyles$1, createStyles } from '@material-ui/core/styles';
import Stepper$1 from '@material-ui/core/Stepper';
import Step$1 from '@material-ui/core/Step';
import StepLabel$1 from '@material-ui/core/StepLabel';
import Grid$1 from '@material-ui/core/Grid';
import Typography$1 from '@material-ui/core/Typography';
import { useImmerReducer } from 'use-immer';
import LazyLog from 'react-lazylog/build/LazyLog';
import { DateTime, Interval } from 'luxon';
import Check from '@material-ui/icons/Check';
import Cancel from '@material-ui/icons/Cancel';
import FiberManualRecordIcon from '@material-ui/icons/FiberManualRecord';
import classNames from 'classnames';
import LanguageIcon from '@material-ui/icons/Language';

const DEFAULT_SCAFFOLDER_FIELD_EXTENSIONS = [
  {
    component: EntityPicker,
    name: "EntityPicker"
  },
  {
    component: RepoUrlPicker,
    name: "RepoUrlPicker",
    validation: repoPickerValidation
  },
  {
    component: OwnerPicker,
    name: "OwnerPicker"
  }
];

const filterGroupsContext = createContext(void 0);

const EntityFilterGroupsProvider = ({
  children
}) => {
  const state = useProvideEntityFilters();
  return /* @__PURE__ */ React.createElement(filterGroupsContext.Provider, {
    value: state
  }, children);
};
function useProvideEntityFilters() {
  const catalogApi = useApi(catalogApiRef);
  const [{value: entities, error}, doReload] = useAsyncFn(async () => {
    const response = await catalogApi.getEntities({
      filter: {kind: "Template"}
    });
    return response.items;
  });
  const filterGroups = useRef({});
  const selectedFilterKeys = useRef({});
  const selectedCategories = useRef([]);
  const [filterGroupStates, setFilterGroupStates] = useState({});
  const [filteredEntities, setFilteredEntities] = useState([]);
  const [availableCategories, setAvailableCategories] = useState([]);
  const [isCatalogEmpty, setCatalogEmpty] = useState(false);
  useEffect(() => {
    doReload();
  }, [doReload]);
  const rebuild = useCallback(() => {
    setFilterGroupStates(buildStates(filterGroups.current, selectedFilterKeys.current, selectedCategories.current, entities, error));
    setFilteredEntities(buildMatchingEntities(filterGroups.current, selectedFilterKeys.current, selectedCategories.current, entities));
    setAvailableCategories(collectCategories(entities));
    setCatalogEmpty(entities !== void 0 && entities.length === 0);
  }, [entities, error]);
  const register = useCallback((filterGroupId, filterGroup, initialSelectedFilterIds) => {
    filterGroups.current[filterGroupId] = filterGroup;
    selectedFilterKeys.current[filterGroupId] = new Set(initialSelectedFilterIds != null ? initialSelectedFilterIds : []);
    rebuild();
  }, [rebuild]);
  const unregister = useCallback((filterGroupId) => {
    delete filterGroups.current[filterGroupId];
    delete selectedFilterKeys.current[filterGroupId];
    rebuild();
  }, [rebuild]);
  const setGroupSelectedFilters = useCallback((filterGroupId, filters) => {
    selectedFilterKeys.current[filterGroupId] = new Set(filters);
    rebuild();
  }, [rebuild]);
  const setSelectedCategories = useCallback((categories) => {
    selectedCategories.current = categories;
    rebuild();
  }, [rebuild]);
  const reload = useCallback(async () => {
    await doReload();
  }, [doReload]);
  return {
    register,
    unregister,
    setGroupSelectedFilters,
    setSelectedCategories,
    reload,
    selectedCategories: selectedCategories.current,
    loading: !error && !entities,
    error,
    filterGroupStates,
    filteredEntities,
    availableCategories,
    isCatalogEmpty
  };
}
function buildStates(filterGroups, selectedFilterKeys, selectedCategories, entities, error) {
  var _a;
  if (error) {
    return Object.fromEntries(Object.keys(filterGroups).map((filterGroupId) => [
      filterGroupId,
      {type: "error", error}
    ]));
  }
  if (!entities) {
    return Object.fromEntries(Object.keys(filterGroups).map((filterGroupId) => [
      filterGroupId,
      {type: "loading"}
    ]));
  }
  const result = {};
  for (const [filterGroupId, filterGroup] of Object.entries(filterGroups)) {
    const otherMatchingEntities = buildMatchingEntities(filterGroups, selectedFilterKeys, selectedCategories, entities, filterGroupId);
    const groupState = {filters: {}};
    for (const [filterId, filterFn] of Object.entries(filterGroup.filters)) {
      const isSelected = !!((_a = selectedFilterKeys[filterGroupId]) == null ? void 0 : _a.has(filterId));
      const matchCount = otherMatchingEntities.filter((entity) => filterFn(entity)).length;
      groupState.filters[filterId] = {isSelected, matchCount};
    }
    result[filterGroupId] = {type: "ready", state: groupState};
  }
  return result;
}
function collectCategories(entities) {
  const categories = new Set();
  (entities || []).forEach((e) => {
    var _a;
    if ((_a = e.spec) == null ? void 0 : _a.type) {
      categories.add(e.spec.type);
    }
  });
  return Array.from(categories).sort();
}
function buildMatchingEntities(filterGroups, selectedFilterKeys, selectedCategories, entities, excludeFilterGroupId) {
  var _a, _b;
  const allFilters = [];
  for (const [filterGroupId, filterGroup] of Object.entries(filterGroups)) {
    if (excludeFilterGroupId === filterGroupId) {
      continue;
    }
    const groupFilters = [];
    for (const [filterId, filterFn] of Object.entries(filterGroup.filters)) {
      if (!!((_a = selectedFilterKeys[filterGroupId]) == null ? void 0 : _a.has(filterId))) {
        groupFilters.push(filterFn);
      }
    }
    if (groupFilters.length) {
      allFilters.push((entity) => groupFilters.some((fn) => fn(entity)));
    }
  }
  if (selectedCategories.length > 0) {
    allFilters.push((entity) => selectedCategories.some((c) => {
      var _a2;
      return ((_a2 = entity.spec) == null ? void 0 : _a2.type) === c;
    }));
  }
  return (_b = entities == null ? void 0 : entities.filter((entity) => allFilters.every((fn) => fn(entity)))) != null ? _b : [];
}

const useEntityFilterGroup = (filterGroupId, filterGroup, initialSelectedFilters) => {
  const context = useContext(filterGroupsContext);
  if (!context) {
    throw new Error(`Must be used inside an EntityFilterGroupsProvider`);
  }
  const {
    register,
    unregister,
    setGroupSelectedFilters,
    filterGroupStates
  } = context;
  const initialMemo = useMemo(() => initialSelectedFilters == null ? void 0 : initialSelectedFilters.slice(), []);
  useEffect(() => {
    register(filterGroupId, filterGroup, initialMemo);
    return () => unregister(filterGroupId);
  }, [register, unregister, filterGroupId, filterGroup, initialMemo]);
  const setSelectedFilters = useCallback((filters) => {
    setGroupSelectedFilters(filterGroupId, filters);
  }, [setGroupSelectedFilters, filterGroupId]);
  let state = filterGroupStates[filterGroupId];
  if (!state) {
    state = {type: "loading"};
  }
  return {state, setSelectedFilters};
};

function useFilteredEntities() {
  const context = useContext(filterGroupsContext);
  if (!context) {
    throw new Error(`Must be used inside an EntityFilterGroupsProvider`);
  }
  return {
    loading: context.loading,
    error: context.error,
    filteredEntities: context.filteredEntities,
    availableCategories: context.availableCategories,
    isCatalogEmpty: context.isCatalogEmpty,
    reload: context.reload
  };
}

const useStyles = makeStyles((theme) => ({
  filterBox: {
    display: "flex",
    margin: theme.spacing(2, 0, 0, 0)
  },
  filterBoxTitle: {
    margin: theme.spacing(1, 0, 0, 1),
    fontWeight: "bold",
    flex: 1
  },
  title: {
    margin: theme.spacing(1, 0, 0, 1),
    textTransform: "uppercase",
    fontSize: 12,
    fontWeight: "bold"
  },
  checkbox: {
    padding: theme.spacing(0, 1, 0, 1)
  }
}));
const ResultsFilter = ({availableCategories}) => {
  const classes = useStyles();
  const context = useContext(filterGroupsContext);
  if (!context) {
    throw new Error(`Must be used inside an EntityFilterGroupsProvider`);
  }
  const {selectedCategories, setSelectedCategories} = context;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
    className: classes.filterBox
  }, /* @__PURE__ */ React.createElement(Typography, {
    variant: "subtitle2",
    className: classes.filterBoxTitle
  }, "Refine Results"), " ", /* @__PURE__ */ React.createElement(Button, {
    onClick: () => setSelectedCategories([])
  }, "Clear")), /* @__PURE__ */ React.createElement(Divider, null), /* @__PURE__ */ React.createElement(Typography, {
    variant: "subtitle2",
    className: classes.title
  }, "Categories"), /* @__PURE__ */ React.createElement(List, {
    disablePadding: true,
    dense: true
  }, availableCategories.map((category) => {
    const labelId = `checkbox-list-label-${category}`;
    return /* @__PURE__ */ React.createElement(ListItem, {
      key: category,
      dense: true,
      button: true,
      onClick: () => setSelectedCategories(selectedCategories.includes(category) ? selectedCategories.filter((selectedCategory) => selectedCategory !== category) : [...selectedCategories, category])
    }, /* @__PURE__ */ React.createElement(Checkbox, {
      edge: "start",
      color: "primary",
      checked: selectedCategories.includes(category),
      tabIndex: -1,
      disableRipple: true,
      className: classes.checkbox,
      inputProps: {"aria-labelledby": labelId}
    }), /* @__PURE__ */ React.createElement(ListItemText, {
      id: labelId,
      primary: category.charAt(0).toLocaleUpperCase("en-US") + category.slice(1)
    }));
  })));
};

const useStyles$1 = makeStyles((theme) => ({
  root: {
    backgroundColor: "rgba(0, 0, 0, .11)",
    boxShadow: "none"
  },
  title: {
    margin: theme.spacing(1, 0, 0, 1),
    textTransform: "uppercase",
    fontSize: 12,
    fontWeight: "bold"
  },
  listIcon: {
    minWidth: 30,
    color: theme.palette.text.primary
  },
  menuItem: {
    minHeight: theme.spacing(6)
  },
  groupWrapper: {
    margin: theme.spacing(1, 1, 2, 1)
  },
  menuTitle: {
    fontWeight: 500
  }
}));
const ScaffolderFilter = ({
  buttonGroups,
  onChange,
  initiallySelected
}) => {
  const classes = useStyles$1();
  const {currentFilter, setCurrentFilter, getFilterCount} = useFilter(buttonGroups, initiallySelected);
  const onChangeRef = useRef();
  useEffect(() => {
    onChangeRef.current = onChange;
  }, [onChange]);
  const setCurrent = useCallback((item) => {
    var _a;
    setCurrentFilter(item.id);
    (_a = onChangeRef.current) == null ? void 0 : _a.call(onChangeRef, {id: item.id, label: item.label});
  }, [setCurrentFilter]);
  useEffect(() => {
    var _a;
    const items = buttonGroups.flatMap((g) => g.items);
    const item = items.find((i) => i.id === initiallySelected) || items[0];
    if (item) {
      (_a = onChangeRef.current) == null ? void 0 : _a.call(onChangeRef, {id: item.id, label: item.label});
    }
  }, []);
  return /* @__PURE__ */ React.createElement(Card, {
    className: classes.root
  }, buttonGroups.map((group) => /* @__PURE__ */ React.createElement(React.Fragment, {
    key: group.name
  }, /* @__PURE__ */ React.createElement(Typography, {
    variant: "subtitle2",
    className: classes.title
  }, group.name), /* @__PURE__ */ React.createElement(Card, {
    className: classes.groupWrapper
  }, /* @__PURE__ */ React.createElement(List, {
    disablePadding: true,
    dense: true
  }, group.items.map((item) => {
    var _a;
    return /* @__PURE__ */ React.createElement(MenuItem, {
      key: item.id,
      button: true,
      divider: true,
      onClick: () => setCurrent(item),
      selected: item.id === currentFilter,
      className: classes.menuItem
    }, item.icon && /* @__PURE__ */ React.createElement(ListItemIcon, {
      className: classes.listIcon
    }, /* @__PURE__ */ React.createElement(item.icon, {
      fontSize: "small"
    })), /* @__PURE__ */ React.createElement(ListItemText, null, /* @__PURE__ */ React.createElement(Typography, {
      variant: "body1",
      className: classes.menuTitle
    }, item.label)), /* @__PURE__ */ React.createElement(ListItemSecondaryAction, null, (_a = getFilterCount(item.id)) != null ? _a : "-"));
  }))))));
};
function useFilter(buttonGroups, initiallySelected) {
  const [currentFilter, setCurrentFilter] = useState(initiallySelected);
  const filterGroup = useMemo(() => ({
    filters: Object.fromEntries(buttonGroups.flatMap((g) => g.items).map((i) => [i.id, i.filterFn]))
  }), [buttonGroups]);
  const {setSelectedFilters, state} = useEntityFilterGroup("primary-sidebar", filterGroup, [initiallySelected]);
  const setCurrent = useCallback((filterId) => {
    setCurrentFilter(filterId);
    setSelectedFilters([filterId]);
  }, [setCurrentFilter, setSelectedFilters]);
  const getFilterCount = useCallback((filterId) => {
    if (state.type !== "ready") {
      return void 0;
    }
    return state.state.filters[filterId].matchCount;
  }, [state]);
  return {
    currentFilter,
    setCurrentFilter: setCurrent,
    getFilterCount
  };
}

const useStyles$2 = makeStyles((_theme) => ({
  searchToolbar: {
    paddingLeft: 0,
    paddingRight: 0
  }
}));
const SearchToolbar = ({search, setSearch}) => {
  const styles = useStyles$2();
  return /* @__PURE__ */ React.createElement(Toolbar, {
    className: styles.searchToolbar
  }, /* @__PURE__ */ React.createElement(FormControl, null, /* @__PURE__ */ React.createElement(Input, {
    id: "input-with-icon-adornment",
    placeholder: "Search",
    autoComplete: "off",
    onChange: (event) => setSearch(event.target.value),
    value: search,
    startAdornment: /* @__PURE__ */ React.createElement(InputAdornment, {
      position: "start"
    }, /* @__PURE__ */ React.createElement(Search, null)),
    endAdornment: /* @__PURE__ */ React.createElement(InputAdornment, {
      position: "end"
    }, /* @__PURE__ */ React.createElement(IconButton, {
      "aria-label": "clear search",
      onClick: () => setSearch(""),
      edge: "end",
      disabled: search.length === 0
    }, /* @__PURE__ */ React.createElement(Clear, null)))
  })));
};

const YellowStar = withStyles({
  root: {
    color: "#f3ba37"
  }
})(Star);
const WhiteBorderStar = withStyles({
  root: {
    color: "#ffffff"
  }
})(StarBorder);
const useStyles$3 = makeStyles((theme) => ({
  starButton: {
    position: "absolute",
    top: theme.spacing(0.5),
    right: theme.spacing(0.5),
    padding: "0.25rem"
  }
}));
const favouriteTemplateTooltip = (isStarred) => isStarred ? "Remove from favorites" : "Add to favorites";
const favouriteTemplateIcon = (isStarred) => isStarred ? /* @__PURE__ */ React.createElement(YellowStar, null) : /* @__PURE__ */ React.createElement(WhiteBorderStar, null);
const FavouriteTemplate = (props) => {
  const classes = useStyles$3();
  const {toggleStarredEntity, isStarredEntity} = useStarredEntities();
  const isStarred = useMemo(() => isStarredEntity(props.entity), [
    isStarredEntity,
    props.entity
  ]);
  return /* @__PURE__ */ React.createElement(IconButton, {
    color: "inherit",
    className: classes.starButton,
    ...props,
    onClick: () => toggleStarredEntity(props.entity)
  }, /* @__PURE__ */ React.createElement(Tooltip, {
    title: favouriteTemplateTooltip(isStarred)
  }, favouriteTemplateIcon(isStarred)));
};

const useStyles$4 = makeStyles((theme) => ({
  cardHeader: {
    position: "relative"
  },
  title: {
    backgroundImage: ({backgroundImage}) => backgroundImage
  },
  box: {
    overflow: "hidden",
    textOverflow: "ellipsis",
    display: "-webkit-box",
    "-webkit-line-clamp": 10,
    "-webkit-box-orient": "vertical",
    paddingBottom: "0.8em"
  },
  label: {
    color: theme.palette.text.secondary,
    textTransform: "uppercase",
    fontSize: "0.65rem",
    fontWeight: "bold",
    letterSpacing: 0.5,
    lineHeight: 1,
    paddingBottom: "0.2rem"
  }
}));
const useDeprecationStyles = makeStyles((theme) => ({
  deprecationIcon: {
    position: "absolute",
    top: theme.spacing(0.5),
    right: theme.spacing(3.5),
    padding: "0.25rem"
  },
  link: {
    color: theme.palette.warning.light
  }
}));
const getTemplateCardProps = (template) => {
  var _a, _b, _c, _d, _e;
  return {
    key: template.metadata.uid,
    name: template.metadata.name,
    title: `${(_a = template.metadata.title || template.metadata.name) != null ? _a : ""}`,
    type: (_b = template.spec.type) != null ? _b : "",
    description: (_c = template.metadata.description) != null ? _c : "-",
    tags: (_e = (_d = template.metadata) == null ? void 0 : _d.tags) != null ? _e : []
  };
};
const DeprecationWarning = () => {
  const styles = useDeprecationStyles();
  const Title = /* @__PURE__ */ React.createElement(Typography, {
    style: {padding: 10, maxWidth: 300}
  }, "This template syntax is deprecated. Click for more info.");
  return /* @__PURE__ */ React.createElement("div", {
    className: styles.deprecationIcon
  }, /* @__PURE__ */ React.createElement(Tooltip, {
    title: Title
  }, /* @__PURE__ */ React.createElement(Link, {
    href: "https://backstage.io/docs/features/software-templates/migrating-from-v1alpha1-to-v1beta2",
    className: styles.link
  }, /* @__PURE__ */ React.createElement(WarningIcon, null))));
};
const TemplateCard = ({template, deprecated}) => {
  var _a;
  const backstageTheme = useTheme();
  const rootLink = useRouteRef(rootRouteRef);
  const templateProps = getTemplateCardProps(template);
  const ownedByRelations = getEntityRelations(template, RELATION_OWNED_BY);
  const themeId = pageTheme[templateProps.type] ? templateProps.type : "other";
  const theme = backstageTheme.getPageTheme({themeId});
  const classes = useStyles$4({backgroundImage: theme.backgroundImage});
  const href = generatePath(`${rootLink()}/templates/:templateName`, {
    templateName: templateProps.name
  });
  return /* @__PURE__ */ React.createElement(Card, null, /* @__PURE__ */ React.createElement(CardMedia, {
    className: classes.cardHeader
  }, /* @__PURE__ */ React.createElement(FavouriteTemplate, {
    entity: template
  }), deprecated && /* @__PURE__ */ React.createElement(DeprecationWarning, null), /* @__PURE__ */ React.createElement(ItemCardHeader, {
    title: templateProps.title,
    subtitle: templateProps.type,
    classes: {root: classes.title}
  })), /* @__PURE__ */ React.createElement(CardContent, {
    style: {display: "grid"}
  }, /* @__PURE__ */ React.createElement(Box, {
    className: classes.box
  }, /* @__PURE__ */ React.createElement(Typography, {
    variant: "body2",
    className: classes.label
  }, "Description"), templateProps.description), /* @__PURE__ */ React.createElement(Box, {
    className: classes.box
  }, /* @__PURE__ */ React.createElement(Typography, {
    variant: "body2",
    className: classes.label
  }, "Owner"), /* @__PURE__ */ React.createElement(EntityRefLinks, {
    entityRefs: ownedByRelations,
    defaultKind: "Group"
  })), /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(Typography, {
    variant: "body2",
    className: classes.label
  }, "Tags"), (_a = templateProps.tags) == null ? void 0 : _a.map((tag) => /* @__PURE__ */ React.createElement(Chip, {
    size: "small",
    label: tag,
    key: tag
  })))), /* @__PURE__ */ React.createElement(CardActions, null, /* @__PURE__ */ React.createElement(Button$1, {
    color: "primary",
    to: href,
    "aria-label": `Choose ${templateProps.title}`
  }, "Choose")));
};

const useStyles$5 = makeStyles((theme) => ({
  contentWrapper: {
    display: "grid",
    gridTemplateAreas: "'filters' 'grid'",
    gridTemplateColumns: "250px 1fr",
    gridColumnGap: theme.spacing(2)
  }
}));
const ScaffolderPageContents = () => {
  var _a;
  const styles = useStyles$5();
  const {
    loading,
    error,
    filteredEntities,
    availableCategories
  } = useFilteredEntities();
  const configApi = useApi(configApiRef);
  const orgName = (_a = configApi.getOptionalString("organization.name")) != null ? _a : "Company";
  const {isStarredEntity} = useStarredEntities();
  const filterGroups = useMemo(() => [
    {
      name: orgName,
      items: [
        {
          id: "all",
          label: "All",
          filterFn: () => true
        }
      ]
    },
    {
      name: "Personal",
      items: [
        {
          id: "starred",
          label: "Starred",
          icon: Star,
          filterFn: isStarredEntity
        }
      ]
    }
  ], [isStarredEntity, orgName]);
  const [search, setSearch] = useState("");
  const [matchingEntities, setMatchingEntities] = useState([]);
  const matchesQuery = (metadata, query) => {
    var _a2;
    return `${metadata.title}`.toLocaleUpperCase("en-US").includes(query) || ((_a2 = metadata.tags) == null ? void 0 : _a2.join("").toLocaleUpperCase("en-US").indexOf(query)) !== -1;
  };
  const registerComponentLink = useRouteRef(registerComponentRouteRef);
  useEffect(() => {
    if (search.length === 0) {
      return setMatchingEntities(filteredEntities);
    }
    return setMatchingEntities(filteredEntities.filter((template) => matchesQuery(template.metadata, search.toLocaleUpperCase("en-US"))));
  }, [search, filteredEntities]);
  return /* @__PURE__ */ React.createElement(Page, {
    themeId: "home"
  }, /* @__PURE__ */ React.createElement(Header, {
    pageTitleOverride: "Create a New Component",
    title: /* @__PURE__ */ React.createElement(React.Fragment, null, "Create a New Component ", /* @__PURE__ */ React.createElement(Lifecycle, {
      alpha: true,
      shorthand: true
    })),
    subtitle: "Create new software components using standard templates"
  }), /* @__PURE__ */ React.createElement(Content, null, /* @__PURE__ */ React.createElement(ContentHeader, {
    title: "Available Templates"
  }, registerComponentLink && /* @__PURE__ */ React.createElement(Button, {
    component: Link$1,
    variant: "contained",
    color: "primary",
    to: registerComponentLink()
  }, "Register Existing Component"), /* @__PURE__ */ React.createElement(SupportButton, null, "Create new software components using standard templates. Different templates create different kinds of components (services, websites, documentation, ...).")), /* @__PURE__ */ React.createElement("div", {
    className: styles.contentWrapper
  }, /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement(SearchToolbar, {
    search,
    setSearch
  }), /* @__PURE__ */ React.createElement(ScaffolderFilter, {
    buttonGroups: filterGroups,
    initiallySelected: "all"
  }), /* @__PURE__ */ React.createElement(ResultsFilter, {
    availableCategories
  })), /* @__PURE__ */ React.createElement("div", null, loading && /* @__PURE__ */ React.createElement(Progress, null), error && /* @__PURE__ */ React.createElement(WarningPanel, {
    title: "Oops! Something went wrong loading the templates"
  }, error.message), !error && !loading && matchingEntities && !matchingEntities.length && /* @__PURE__ */ React.createElement(Typography, {
    variant: "body2"
  }, "No templates found that match your filter. Learn more about", " ", /* @__PURE__ */ React.createElement(Link, {
    href: "https://backstage.io/docs/features/software-templates/adding-templates"
  }, "adding templates"), "."), /* @__PURE__ */ React.createElement(ItemCardGrid, null, matchingEntities && (matchingEntities == null ? void 0 : matchingEntities.length) > 0 && matchingEntities.map((template, i) => /* @__PURE__ */ React.createElement(TemplateCard, {
    key: i,
    template,
    deprecated: template.apiVersion === "backstage.io/v1alpha1"
  })))))));
};
const ScaffolderPage = () => /* @__PURE__ */ React.createElement(EntityFilterGroupsProvider, null, /* @__PURE__ */ React.createElement(ScaffolderPageContents, null));

function isObject(value) {
  return typeof value === "object" && value !== null && !Array.isArray(value);
}
function extractUiSchema(schema, uiSchema) {
  if (!isObject(schema)) {
    return;
  }
  const {properties, anyOf, oneOf, allOf} = schema;
  for (const propName in schema) {
    if (!schema.hasOwnProperty(propName)) {
      continue;
    }
    if (propName.startsWith("ui:")) {
      uiSchema[propName] = schema[propName];
      delete schema[propName];
    }
  }
  if (isObject(properties)) {
    for (const propName in properties) {
      if (!properties.hasOwnProperty(propName)) {
        continue;
      }
      const schemaNode = properties[propName];
      if (!isObject(schemaNode)) {
        continue;
      }
      const innerUiSchema = {};
      uiSchema[propName] = innerUiSchema;
      extractUiSchema(schemaNode, innerUiSchema);
    }
  }
  if (Array.isArray(anyOf)) {
    for (const schemaNode of anyOf) {
      if (!isObject(schemaNode)) {
        continue;
      }
      extractUiSchema(schemaNode, uiSchema);
    }
  }
  if (Array.isArray(oneOf)) {
    for (const schemaNode of oneOf) {
      if (!isObject(schemaNode)) {
        continue;
      }
      extractUiSchema(schemaNode, uiSchema);
    }
  }
  if (Array.isArray(allOf)) {
    for (const schemaNode of allOf) {
      if (!isObject(schemaNode)) {
        continue;
      }
      extractUiSchema(schemaNode, uiSchema);
    }
  }
}
function transformSchemaToProps(inputSchema) {
  inputSchema.type = inputSchema.type || "object";
  const schema = JSON.parse(JSON.stringify(inputSchema));
  delete schema.title;
  const uiSchema = {};
  extractUiSchema(schema, uiSchema);
  return {schema, uiSchema};
}

const Form = withTheme(Theme);
const MultistepJsonForm = ({
  steps,
  formData,
  onChange,
  onReset,
  onFinish,
  fields,
  widgets
}) => {
  const [activeStep, setActiveStep] = useState(0);
  const handleReset = () => {
    setActiveStep(0);
    onReset();
  };
  const handleNext = () => setActiveStep(Math.min(activeStep + 1, steps.length));
  const handleBack = () => setActiveStep(Math.max(activeStep - 1, 0));
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Stepper, {
    activeStep,
    orientation: "vertical"
  }, steps.map(({title, schema, ...formProps}, index) => {
    return /* @__PURE__ */ React.createElement(Step, {
      key: title
    }, /* @__PURE__ */ React.createElement(StepLabel, {
      "aria-label": `Step ${index + 1} ${title}`,
      "aria-disabled": "false",
      tabIndex: 0
    }, /* @__PURE__ */ React.createElement(Typography, {
      variant: "h6",
      component: "h3"
    }, title)), /* @__PURE__ */ React.createElement(StepContent, {
      key: title
    }, /* @__PURE__ */ React.createElement(Form, {
      showErrorList: false,
      fields,
      widgets,
      noHtml5Validate: true,
      formData,
      onChange,
      onSubmit: (e) => {
        if (e.errors.length === 0)
          handleNext();
      },
      ...formProps,
      ...transformSchemaToProps(schema)
    }, /* @__PURE__ */ React.createElement(Button, {
      disabled: activeStep === 0,
      onClick: handleBack
    }, "Back"), /* @__PURE__ */ React.createElement(Button, {
      variant: "contained",
      color: "primary",
      type: "submit"
    }, "Next step"))));
  })), activeStep === steps.length && /* @__PURE__ */ React.createElement(Content, null, /* @__PURE__ */ React.createElement(Paper, {
    square: true,
    elevation: 0
  }, /* @__PURE__ */ React.createElement(Typography, {
    variant: "h6"
  }, "Review and create"), /* @__PURE__ */ React.createElement(StructuredMetadataTable, {
    dense: true,
    metadata: formData
  }), /* @__PURE__ */ React.createElement(Box, {
    mb: 4
  }), /* @__PURE__ */ React.createElement(Button, {
    onClick: handleBack
  }, "Back"), /* @__PURE__ */ React.createElement(Button, {
    onClick: handleReset
  }, "Reset"), /* @__PURE__ */ React.createElement(Button, {
    variant: "contained",
    color: "primary",
    onClick: onFinish
  }, "Create"))));
};

const useTemplateParameterSchema = (templateName) => {
  const scaffolderApi = useApi(scaffolderApiRef);
  const {value, loading, error} = useAsync(() => scaffolderApi.getTemplateParameterSchema({
    name: templateName,
    kind: "template",
    namespace: "default"
  }), [scaffolderApi, templateName]);
  return {schema: value, loading, error};
};
function isObject$1(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj);
}
const createValidator = (rootSchema, validators) => {
  function validate(schema, formData, errors) {
    const schemaProps = schema.properties;
    if (!isObject$1(schemaProps)) {
      return;
    }
    for (const [key, propData] of Object.entries(formData)) {
      const propValidation = errors[key];
      if (isObject$1(propData)) {
        const propSchemaProps = schemaProps[key];
        if (isObject$1(propSchemaProps)) {
          validate(propSchemaProps, propData, propValidation);
        }
      } else {
        const propSchema = schemaProps[key];
        const fieldName = isObject$1(propSchema) && propSchema["ui:field"];
        if (fieldName && typeof validators[fieldName] === "function") {
          validators[fieldName](propData, propValidation);
        }
      }
    }
  }
  return (formData, errors) => {
    validate(rootSchema, formData, errors);
    return errors;
  };
};
const storePathValidator = (formData, errors) => {
  const {storePath} = formData;
  if (!storePath) {
    errors.storePath.addError("Store path is required and not present");
    return errors;
  }
  try {
    const parsedUrl = parseGitUrl(storePath);
    if (!parsedUrl.resource || !parsedUrl.owner || !parsedUrl.name) {
      if (parsedUrl.resource === "dev.azure.com") {
        errors.storePath.addError("The store path should be formatted like https://dev.azure.com/{org}/{project}/_git/{repo} for Azure URL's");
      } else {
        errors.storePath.addError("The store path should be a complete Git URL to the new repository location. For example: https://github.com/{owner}/{repo}");
      }
    }
  } catch (ex) {
    errors.storePath.addError(`Failed validation of the store path with message ${ex.message}`);
  }
  return errors;
};
const TemplatePage = ({
  customFieldExtensions = []
}) => {
  const errorApi = useApi(errorApiRef);
  const scaffolderApi = useApi(scaffolderApiRef);
  const {templateName} = useParams();
  const navigate = useNavigate();
  const rootLink = useRouteRef(rootRouteRef);
  const {schema, loading, error} = useTemplateParameterSchema(templateName);
  const [formState, setFormState] = useState({});
  const handleFormReset = () => setFormState({});
  const handleChange = useCallback((e) => setFormState(e.formData), [setFormState]);
  const handleCreate = async () => {
    try {
      const id = await scaffolderApi.scaffold(templateName, formState);
      navigate(generatePath(`${rootLink()}/tasks/:taskId`, {taskId: id}));
    } catch (e) {
      errorApi.post(e);
    }
  };
  if (error) {
    errorApi.post(new Error(`Failed to load template, ${error}`));
    return /* @__PURE__ */ React.createElement(Navigate, {
      to: rootLink()
    });
  }
  if (!loading && !schema) {
    errorApi.post(new Error("Template was not found."));
    return /* @__PURE__ */ React.createElement(Navigate, {
      to: rootLink()
    });
  }
  const customFieldComponents = Object.fromEntries(customFieldExtensions.map(({name, component}) => [name, component]));
  const customFieldValidators = Object.fromEntries(customFieldExtensions.map(({name, validation}) => [name, validation]));
  return /* @__PURE__ */ React.createElement(Page, {
    themeId: "home"
  }, /* @__PURE__ */ React.createElement(Header, {
    pageTitleOverride: "Create a New Component",
    title: /* @__PURE__ */ React.createElement(React.Fragment, null, "Create a New Component ", /* @__PURE__ */ React.createElement(Lifecycle, {
      alpha: true,
      shorthand: true
    })),
    subtitle: "Create new software components using standard templates"
  }), /* @__PURE__ */ React.createElement(Content, null, loading && /* @__PURE__ */ React.createElement(LinearProgress, {
    "data-testid": "loading-progress"
  }), schema && /* @__PURE__ */ React.createElement(InfoCard, {
    title: schema.title,
    noPadding: true,
    titleTypographyProps: {component: "h2"}
  }, /* @__PURE__ */ React.createElement(MultistepJsonForm, {
    formData: formState,
    fields: customFieldComponents,
    onChange: handleChange,
    onReset: handleFormReset,
    onFinish: handleCreate,
    steps: schema.steps.map((step) => {
      var _a, _b;
      if ((_b = (_a = step.schema) == null ? void 0 : _a.properties) == null ? void 0 : _b.storePath) {
        return {
          ...step,
          validate: (a, b) => storePathValidator(a, b)
        };
      }
      return {
        ...step,
        validate: createValidator(step.schema, customFieldValidators)
      };
    })
  }))));
};

function reducer(draft, action) {
  var _a, _b, _c;
  switch (action.type) {
    case "INIT": {
      draft.steps = action.data.spec.steps.reduce((current, next) => {
        current[next.id] = {status: "open", id: next.id};
        return current;
      }, {});
      draft.stepLogs = action.data.spec.steps.reduce((current, next) => {
        current[next.id] = [];
        return current;
      }, {});
      draft.loading = false;
      draft.error = void 0;
      draft.completed = false;
      draft.task = action.data;
      return;
    }
    case "LOGS": {
      const entries = action.data;
      for (const entry of entries) {
        const logLine = `${entry.createdAt} ${entry.body.message}`;
        if (!entry.body.stepId || !((_a = draft.steps) == null ? void 0 : _a[entry.body.stepId])) {
          continue;
        }
        const currentStepLog = (_b = draft.stepLogs) == null ? void 0 : _b[entry.body.stepId];
        const currentStep = (_c = draft.steps) == null ? void 0 : _c[entry.body.stepId];
        if (entry.body.status && entry.body.status !== currentStep.status) {
          currentStep.status = entry.body.status;
          if (currentStep.status === "processing") {
            currentStep.startedAt = entry.createdAt;
          }
          if (["cancelled", "failed", "completed"].includes(currentStep.status)) {
            currentStep.endedAt = entry.createdAt;
          }
        }
        currentStepLog == null ? void 0 : currentStepLog.push(logLine);
      }
      return;
    }
    case "COMPLETED": {
      draft.completed = true;
      draft.output = action.data.body.output;
      return;
    }
    case "ERROR": {
      draft.error = action.data;
      draft.loading = false;
      draft.completed = true;
      return;
    }
    default:
      return;
  }
}
const useTaskEventStream = (taskId) => {
  const scaffolderApi = useApi(scaffolderApiRef);
  const [state, dispatch] = useImmerReducer(reducer, {
    loading: true,
    completed: false,
    stepLogs: {},
    steps: {}
  });
  useEffect(() => {
    let didCancel = false;
    let subscription;
    let logPusher;
    scaffolderApi.getTask(taskId).then((task) => {
      if (didCancel) {
        return;
      }
      dispatch({type: "INIT", data: task});
      const observable = scaffolderApi.streamLogs({taskId});
      const collectedLogEvents = new Array();
      function emitLogs() {
        if (collectedLogEvents.length) {
          const logs = collectedLogEvents.splice(0, collectedLogEvents.length);
          dispatch({type: "LOGS", data: logs});
        }
      }
      logPusher = setInterval(emitLogs, 500);
      subscription = observable.subscribe({
        next: (event) => {
          switch (event.type) {
            case "log":
              return collectedLogEvents.push(event);
            case "completion":
              emitLogs();
              dispatch({type: "COMPLETED", data: event});
              return void 0;
            default:
              throw new Error(`Unhandled event type ${event.type} in observer`);
          }
        },
        error: (error) => {
          emitLogs();
          dispatch({type: "ERROR", data: error});
        }
      });
    }, (error) => {
      if (!didCancel) {
        dispatch({type: "ERROR", data: error});
      }
    });
    return () => {
      didCancel = true;
      if (subscription) {
        subscription.unsubscribe();
      }
      if (logPusher) {
        clearInterval(logPusher);
      }
    };
  }, [scaffolderApi, dispatch, taskId]);
  return state;
};

const useStyles$6 = makeStyles({
  svgIcon: {
    display: "inline-block",
    "& svg": {
      display: "inline-block",
      fontSize: "inherit",
      verticalAlign: "baseline"
    }
  }
});
const IconLink = (props) => {
  const {href, text, Icon, ...linkProps} = props;
  const classes = useStyles$6();
  return /* @__PURE__ */ React.createElement(Grid, {
    container: true,
    direction: "row",
    spacing: 1
  }, /* @__PURE__ */ React.createElement(Grid, {
    item: true
  }, /* @__PURE__ */ React.createElement(Typography, {
    component: "div",
    className: classes.svgIcon
  }, Icon ? /* @__PURE__ */ React.createElement(Icon, null) : /* @__PURE__ */ React.createElement(LanguageIcon, null))), /* @__PURE__ */ React.createElement(Grid, {
    item: true
  }, /* @__PURE__ */ React.createElement(Link$2, {
    to: href,
    ...linkProps
  }, text || href)));
};

const TaskPageLinks = ({output}) => {
  const {entityRef, remoteUrl} = output;
  let {links = []} = output;
  const app = useApp();
  const entityRoute = useRouteRef(entityRouteRef);
  const iconResolver = (key) => {
    var _a;
    return key ? (_a = app.getSystemIcon(key)) != null ? _a : LanguageIcon : LanguageIcon;
  };
  if (remoteUrl) {
    links = [{url: remoteUrl, title: "Repo"}, ...links];
  }
  if (entityRef) {
    const entityName = parseEntityName(entityRef);
    const target = entityRoute(entityName);
    links = [
      {
        url: target,
        title: "Open in catalog",
        icon: "catalog"
      },
      ...links
    ];
  }
  return /* @__PURE__ */ React.createElement(Box, {
    px: 3,
    pb: 3
  }, links.map(({url, title, icon}, i) => /* @__PURE__ */ React.createElement(IconLink, {
    key: `output-link-${i}`,
    href: url,
    text: title != null ? title : url,
    Icon: iconResolver(icon),
    target: "_blank"
  })));
};

const humanizeDuration = require("humanize-duration");
const useStyles$7 = makeStyles$1((theme) => createStyles({
  root: {
    width: "100%"
  },
  button: {
    marginTop: theme.spacing(1),
    marginRight: theme.spacing(1)
  },
  actionsContainer: {
    marginBottom: theme.spacing(2)
  },
  resetContainer: {
    padding: theme.spacing(3)
  },
  labelWrapper: {
    display: "flex",
    flex: 1,
    flexDirection: "row",
    justifyContent: "space-between"
  },
  stepWrapper: {
    width: "100%"
  }
}));
const StepTimeTicker = ({step}) => {
  const [time, setTime] = useState("");
  useInterval(() => {
    if (!step.startedAt) {
      setTime("");
      return;
    }
    const end = step.endedAt ? DateTime.fromISO(step.endedAt) : DateTime.local();
    const startedAt = DateTime.fromISO(step.startedAt);
    const formatted = Interval.fromDateTimes(startedAt, end).toDuration().valueOf();
    setTime(humanizeDuration(formatted, {round: true}));
  }, 1e3);
  return /* @__PURE__ */ React.createElement(Typography$1, {
    variant: "caption"
  }, time);
};
const useStepIconStyles = makeStyles$1((theme) => createStyles({
  root: {
    color: theme.palette.text.disabled,
    display: "flex",
    height: 22,
    alignItems: "center"
  },
  completed: {
    color: theme.palette.status.ok
  },
  error: {
    color: theme.palette.status.error
  }
}));
function TaskStepIconComponent(props) {
  const classes = useStepIconStyles();
  const {active, completed, error} = props;
  const getMiddle = () => {
    if (active) {
      return /* @__PURE__ */ React.createElement(CircularProgress, {
        size: "24px"
      });
    }
    if (completed) {
      return /* @__PURE__ */ React.createElement(Check, null);
    }
    if (error) {
      return /* @__PURE__ */ React.createElement(Cancel, null);
    }
    return /* @__PURE__ */ React.createElement(FiberManualRecordIcon, null);
  };
  return /* @__PURE__ */ React.createElement("div", {
    className: classNames(classes.root, {
      [classes.completed]: completed,
      [classes.error]: error
    })
  }, getMiddle());
}
const TaskStatusStepper = memo(({
  steps,
  currentStepId,
  onUserStepChange
}) => {
  const classes = useStyles$7();
  return /* @__PURE__ */ React.createElement("div", {
    className: classes.root
  }, /* @__PURE__ */ React.createElement(Stepper$1, {
    activeStep: steps.findIndex((s) => s.id === currentStepId),
    orientation: "vertical",
    nonLinear: true
  }, steps.map((step, index) => {
    const isCompleted = step.status === "completed";
    const isFailed = step.status === "failed";
    const isActive = step.status === "processing";
    return /* @__PURE__ */ React.createElement(Step$1, {
      key: String(index),
      expanded: true
    }, /* @__PURE__ */ React.createElement(StepButton, {
      onClick: () => onUserStepChange(step.id)
    }, /* @__PURE__ */ React.createElement(StepLabel$1, {
      StepIconProps: {
        completed: isCompleted,
        error: isFailed,
        active: isActive
      },
      StepIconComponent: TaskStepIconComponent,
      className: classes.stepWrapper
    }, /* @__PURE__ */ React.createElement("div", {
      className: classes.labelWrapper
    }, /* @__PURE__ */ React.createElement(Typography$1, {
      variant: "subtitle2"
    }, step.name), /* @__PURE__ */ React.createElement(StepTimeTicker, {
      step
    })))));
  })));
});
const TaskLogger = memo(({log}) => {
  return /* @__PURE__ */ React.createElement("div", {
    style: {height: "80vh"}
  }, /* @__PURE__ */ React.createElement(LazyLog, {
    text: log,
    extraLines: 1,
    follow: true,
    selectableLines: true,
    enableSearch: true
  }));
});
const hasLinks = ({entityRef, remoteUrl, links = []}) => !!(entityRef || remoteUrl || links.length > 0);
const TaskPage = () => {
  const [userSelectedStepId, setUserSelectedStepId] = useState(void 0);
  const [lastActiveStepId, setLastActiveStepId] = useState(void 0);
  const {taskId} = useParams$1();
  const taskStream = useTaskEventStream(taskId);
  const completed = taskStream.completed;
  const steps = useMemo(() => {
    var _a, _b;
    return (_b = (_a = taskStream.task) == null ? void 0 : _a.spec.steps.map((step) => {
      var _a2;
      return {
        ...step,
        ...(_a2 = taskStream == null ? void 0 : taskStream.steps) == null ? void 0 : _a2[step.id]
      };
    })) != null ? _b : [];
  }, [taskStream]);
  useEffect(() => {
    var _a;
    const mostRecentFailedOrActiveStep = steps.find((step) => ["failed", "processing"].includes(step.status));
    if (completed && !mostRecentFailedOrActiveStep) {
      setLastActiveStepId((_a = steps[steps.length - 1]) == null ? void 0 : _a.id);
      return;
    }
    setLastActiveStepId(mostRecentFailedOrActiveStep == null ? void 0 : mostRecentFailedOrActiveStep.id);
  }, [steps, completed]);
  const currentStepId = userSelectedStepId != null ? userSelectedStepId : lastActiveStepId;
  const logAsString = useMemo(() => {
    if (!currentStepId) {
      return "Loading...";
    }
    const log = taskStream.stepLogs[currentStepId];
    if (!(log == null ? void 0 : log.length)) {
      return "Waiting for logs...";
    }
    return log.join("\n");
  }, [taskStream.stepLogs, currentStepId]);
  const taskNotFound = taskStream.completed === true && taskStream.loading === false && !taskStream.task;
  const {output} = taskStream;
  return /* @__PURE__ */ React.createElement(Page, {
    themeId: "home"
  }, /* @__PURE__ */ React.createElement(Header, {
    pageTitleOverride: `Task ${taskId}`,
    title: /* @__PURE__ */ React.createElement(React.Fragment, null, "Task Activity ", /* @__PURE__ */ React.createElement(Lifecycle, {
      alpha: true,
      shorthand: true
    })),
    subtitle: `Activity for task: ${taskId}`
  }), /* @__PURE__ */ React.createElement(Content, null, taskNotFound ? /* @__PURE__ */ React.createElement(ErrorPage, {
    status: "404",
    statusMessage: "Task not found",
    additionalInfo: "No task found with this ID"
  }) : /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement(Grid$1, {
    container: true
  }, /* @__PURE__ */ React.createElement(Grid$1, {
    item: true,
    xs: 3
  }, /* @__PURE__ */ React.createElement(Paper, null, /* @__PURE__ */ React.createElement(TaskStatusStepper, {
    steps,
    currentStepId,
    onUserStepChange: setUserSelectedStepId
  }), output && hasLinks(output) && /* @__PURE__ */ React.createElement(TaskPageLinks, {
    output
  }))), /* @__PURE__ */ React.createElement(Grid$1, {
    item: true,
    xs: 9
  }, /* @__PURE__ */ React.createElement(TaskLogger, {
    log: logAsString
  }))))));
};

const useStyles$8 = makeStyles((theme) => ({
  code: {
    fontFamily: "Menlo, monospace",
    padding: theme.spacing(1),
    backgroundColor: theme.palette.type === "dark" ? theme.palette.grey[700] : theme.palette.grey[300],
    display: "inline-block",
    borderRadius: 5,
    border: `1px solid ${theme.palette.grey[500]}`,
    position: "relative"
  },
  codeRequired: {
    "&::after": {
      position: "absolute",
      content: '"*"',
      top: 0,
      right: theme.spacing(0.5),
      fontWeight: "bolder",
      color: theme.palette.error.light
    }
  }
}));
const ActionsPage = () => {
  const api = useApi(scaffolderApiRef);
  const classes = useStyles$8();
  const {loading, value, error} = useAsync(async () => {
    return api.listActions();
  });
  if (loading) {
    return /* @__PURE__ */ React.createElement(Progress, null);
  }
  if (error) {
    return /* @__PURE__ */ React.createElement(ErrorPage, {
      statusMessage: "Failed to load installed actions",
      status: "500"
    });
  }
  const formatRows = (input) => {
    const properties = input.properties;
    if (!properties) {
      return void 0;
    }
    return Object.entries(properties).map((entry) => {
      var _a;
      const [key] = entry;
      const props = entry[1];
      const codeClassname = classNames(classes.code, {
        [classes.codeRequired]: (_a = input.required) == null ? void 0 : _a.includes(key)
      });
      return /* @__PURE__ */ React.createElement(TableRow, {
        key
      }, /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement("div", {
        className: codeClassname
      }, key)), /* @__PURE__ */ React.createElement(TableCell, null, props.title), /* @__PURE__ */ React.createElement(TableCell, null, props.description), /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement("span", {
        className: classes.code
      }, props.type)));
    });
  };
  const renderTable = (input) => {
    if (!input.properties) {
      return void 0;
    }
    return /* @__PURE__ */ React.createElement(TableContainer, {
      component: Paper
    }, /* @__PURE__ */ React.createElement(Table, {
      size: "small"
    }, /* @__PURE__ */ React.createElement(TableHead, null, /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, null, "Name"), /* @__PURE__ */ React.createElement(TableCell, null, "Title"), /* @__PURE__ */ React.createElement(TableCell, null, "Description"), /* @__PURE__ */ React.createElement(TableCell, null, "Type"))), /* @__PURE__ */ React.createElement(TableBody, null, formatRows(input))));
  };
  const renderTables = (name, input) => {
    if (!input) {
      return void 0;
    }
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, {
      variant: "h6"
    }, name), input.map((i, index) => /* @__PURE__ */ React.createElement("div", {
      key: index
    }, renderTable(i))));
  };
  const items = value == null ? void 0 : value.map((action) => {
    var _a, _b, _c, _d;
    if (action.id.startsWith("legacy:")) {
      return void 0;
    }
    const oneOf = renderTables("oneOf", (_b = (_a = action.schema) == null ? void 0 : _a.input) == null ? void 0 : _b.oneOf);
    return /* @__PURE__ */ React.createElement(Box, {
      pb: 4,
      key: action.id
    }, /* @__PURE__ */ React.createElement(Typography, {
      variant: "h4",
      className: classes.code
    }, action.id), /* @__PURE__ */ React.createElement(Typography, null, action.description), ((_c = action.schema) == null ? void 0 : _c.input) && /* @__PURE__ */ React.createElement(Box, {
      pb: 2
    }, /* @__PURE__ */ React.createElement(Typography, {
      variant: "h5"
    }, "Input"), renderTable(action.schema.input), oneOf), ((_d = action.schema) == null ? void 0 : _d.output) && /* @__PURE__ */ React.createElement(Box, {
      pb: 2
    }, /* @__PURE__ */ React.createElement(Typography, {
      variant: "h5"
    }, "Output"), renderTable(action.schema.output)));
  });
  return /* @__PURE__ */ React.createElement(Page, {
    themeId: "home"
  }, /* @__PURE__ */ React.createElement(Header, {
    pageTitleOverride: "Create a New Component",
    title: "Installed actions",
    subtitle: "This is the collection of all installed actions"
  }), /* @__PURE__ */ React.createElement(Content, null, items));
};

const collectComponentData = (children, componentDataKey) => {
  const stack = [children];
  const found = [];
  while (stack.length) {
    const current = stack.pop();
    React.Children.forEach(current, (child) => {
      if (!React.isValidElement(child)) {
        return;
      }
      const data = getComponentData(child, componentDataKey);
      if (data) {
        found.push(data);
      }
      if (child.props.children) {
        stack.push(child.props.children);
      }
    });
  }
  return found;
};
const collectChildren = (component, componentDataKey) => {
  const stack = [component];
  const found = [];
  while (stack.length) {
    const current = stack.pop();
    React.Children.forEach(current, (child) => {
      if (!React.isValidElement(child)) {
        return;
      }
      if (child.props.children) {
        if (getComponentData(child, componentDataKey)) {
          found.push(child.props.children);
        }
        stack.push(child.props.children);
      }
    });
  }
  return found;
};

const Router = () => {
  const outlet = useOutlet();
  const fieldExtensions = useMemo(() => {
    const registeredExtensions = collectComponentData(collectChildren(outlet, FIELD_EXTENSION_WRAPPER_KEY).flat(), FIELD_EXTENSION_KEY);
    return registeredExtensions.length ? registeredExtensions : DEFAULT_SCAFFOLDER_FIELD_EXTENSIONS;
  }, [outlet]);
  return /* @__PURE__ */ React.createElement(Routes, null, /* @__PURE__ */ React.createElement(Route, {
    path: "/",
    element: /* @__PURE__ */ React.createElement(ScaffolderPage, null)
  }), /* @__PURE__ */ React.createElement(Route, {
    path: "/templates/:templateName",
    element: /* @__PURE__ */ React.createElement(TemplatePage, {
      customFieldExtensions: fieldExtensions
    })
  }), /* @__PURE__ */ React.createElement(Route, {
    path: "/tasks/:taskId",
    element: /* @__PURE__ */ React.createElement(TaskPage, null)
  }), /* @__PURE__ */ React.createElement(Route, {
    path: "/actions",
    element: /* @__PURE__ */ React.createElement(ActionsPage, null)
  }));
};

export { Router };
//# sourceMappingURL=Router-f3e2f864.esm.js.map
